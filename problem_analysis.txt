=== PROBLEM FILES ANALYSIS ===

--- API.TS (shift exports) ---
  Employee,
  AccessRole,
  User,
  Store,
  RecipeItem,
  Shift,
  TimesheetEntry,
  Payroll,
  PayrollSettings,
} from "./config/entities";

--

  // Extract data from StandardResponse
  return responseData.data;
};

export async function fetchData(
  resource: string,
  id?: string,
  data?: Record<string, any>,
  method: "GET" | "POST" | "PUT" | "DELETE" = "GET"
): Promise<any | null> {
--
  // Return the data part of the standard response
  return finalResponse.data;
}

// Authentication - UPDATED for new response format
export async function loginEmployee(
  email: string,
  password: string
): Promise<Employee & { store_id: string }> {
  const url = `${BASE_URL}/login`;
  console.log("loginEmployee: Starting login process...");
--
    store_id: employee.store_id,
  };
}

// Core POS functions - THESE SHOULD NOW WORK CORRECTLY
export const useFoods = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/foods`,
    fetcher
  );
  return {
--
    isError: error,
    refreshMenuItems: mutate,
  };
};

export const useCategories = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/categories`,
    fetcher
  );
  return {
--
    isError: error,
    refreshCategories: mutate,
  };
};

export const useTables = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/tables`,
    fetcher
  );
  return {
--
    isError: error,
    refreshTables: mutate,
  };
};

export const useCreateOrder = () => {
  const toast = useToast();

  const createOrder = async (order: any) => {
    try {
      const newOrder = await fetchData("orders", undefined, order, "POST");
--
    }
  };
  return { createOrder };
};

export const useOrders = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/orders`,
    fetcher
  );
  return {
--
    isError: error,
    refreshOrders: mutate,
  };
};

export const useUpdateOrder = () => {
  const toast = useToast();

  const updateOrder = async (orderId: string, updatedOrder: any) => {
    try {
      const result = await fetchData("orders", orderId, updatedOrder, "PUT");
--
    }
  };
  return { updateOrder };
};

export const useInventoryProducts = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/inventory_products`,
    fetcher
  );
  return {
--
    refreshInventoryProducts: mutate,
  };
};

// HR functions - UPDATED to handle new response format
export async function getEmployees(): Promise<any[]> {
  const response = await fetchData("employees");
  return response; // This is now the actual array
}

export async function getShifts(): Promise<any[]> {
  const response = await fetchData("shifts");
  return response; // This is now the actual array
}

export async function createShift(newShift: any): Promise<any> {
  const response = await fetchData("shifts", undefined, newShift, "POST");
  return response; // This is now the created shift object
}

export async function updateShift(shiftId: string, updates: any): Promise<any> {
  const response = await fetchData("shifts", shiftId, updates, "PUT");
  return response; // This is now the updated shift object
}

export async function updateShiftStatus(
  shiftId: string,
  status: boolean
): Promise<any> {
  const response = await fetchData(
    `shifts/${shiftId}/status`,
    undefined,
    { active: status },
    "PUT"
  );
  return response; // This is now the updated shift object
}

export async function getTimesheets(): Promise<any[]> {
  const response = await fetchData("timesheet_entries");
  return response; // This is now the actual array
}

export async function clockIn(
  employeeId: string,
  storeId: string
): Promise<any> {
  const response = await fetchData(
    "timesheet_entries/clock-in",
--
    "POST"
  );
  return response; // This is now the created timesheet entry
}

export async function clockOut(timesheetId: string): Promise<any> {
  const response = await fetchData(
    `timesheet_entries/${timesheetId}/clock-out`,
    undefined,
    {},
    "POST"
  );
  return response; // This is now the updated timesheet entry
}

// Inventory functions
export async function getPurchaseOrders(): Promise<any[]> {
  const response = await fetchData("purchase_orders");
  return response; // This is now the actual array
}

export async function createPurchaseOrder(orderData: any): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
    undefined,
    orderData,
    "POST"
  );
  return response; // This is now the created purchase order
}

export async function updatePurchaseOrder(
  orderId: string,
  orderData: any
): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
--
    "PUT"
  );
  return response; // This is now the updated purchase order
}

export async function getGoodsReceipts(): Promise<any[]> {
  const response = await fetchData("goods_receipts");
  return response; // This is now the actual array
}

export async function createGoodsReceipt(receiptData: any): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
    undefined,
    receiptData,
    "POST"
  );
  return response; // This is now the created goods receipt
}

export async function getSuppliers(): Promise<any[]> {
  const response = await fetchData("suppliers");
  return response; // This is now the actual array
}

// Additional functions (payroll, low stock, etc.)
export async function getPayrolls(): Promise<any[]> {
  const response = await fetchData("payroll");
  return response; // This is now the actual array
}

export async function getLowStockItems(): Promise<any[]> {
  const response = await fetchData("inventory/low-stock");
  return response; // This is now the actual array of low stock items
}

export async function deleteItem(
  resource: string,
  id: string
): Promise<{ message: string }> {
  await fetchData(resource, id, undefined, "DELETE");
  return { message: "Item deleted successfully" };
}

// Other previously missing functions
export const useFood = (foodId: string | undefined) => {
  const { data, error, isLoading, mutate } = useSWR<Food>(
    foodId ? `${BASE_URL}/foods/${foodId}` : null,
    fetcher
  );
  return {
--
    isError: error,
    refreshFood: mutate,
  };
};

export const useCreateFood = () => {
  const toast = useToast();
  const createFood = async (food: Food) => {
    try {
      const newFood = await fetchData("foods", undefined, food, "POST");
      toast({
--
    }
  };
  return createFood;
};

export const useUpdateFood = () => {
  const toast = useToast();
  const updateFood = async (foodId: string, food: Partial<Food>) => {
    try {
      const updatedFood = await fetchData("foods", foodId, food, "PUT");
      toast({
--
    }
  };
  return updateFood;
};

export const useDeleteFood = () => {
  const toast = useToast();
  const deleteFood = async (foodId: string) => {
    try {
      await fetchData("foods", foodId, undefined, "DELETE");
      toast({
--
    }
  };
  return deleteFood;
};

export async function getAccessRoles(): Promise<any[]> {
  const response = await fetchData("access_roles");
  return response; // This is now the actual array
}

export async function getJobTitles(): Promise<any[]> {
  const response = await fetchData("job_titles");
  return response; // This is now the actual array
}

export async function getPayrollSettings(): Promise<any> {
  const response = await fetchData("payroll_settings");
  return response; // This is now the settings object (not an array anymore)
}

// Add a test function to verify connection
export async function testConnection(): Promise<boolean> {
  try {
    const response = await fetch(`${BASE_URL}/health`);
    const data: StandardResponse = await response.json();
    console.log("Health check:", data);
    return data.code === 200;
--
    return false;
  }
}

// Department functions
export async function getDepartments(): Promise<any[]> {
  const response = await fetchData("departments");
  return response; // This is now the actual array
}

// In api.ts - Update the getUsers function
export async function getUsers(): Promise<any[]> {
  const response = await fetchData("users");
  // Transform the data to match your frontend expectations
  return response.map((user: any) => ({
    ...user,
    // Create name field from first_name and last_name
--
    remember_token: user.remember_token || null,
  }));
}

// Also update the useUsers hook
export const useUsers = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/users`,
    async (url) => {
      const users = await fetcher(url);
      return users.map((user: any) => ({
--
    isError: error,
    refreshUsers: mutate,
  };
};

export const useDepartments = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/departments`,
    fetcher
  );
  return {
--
    isError: error,
    refreshDepartments: mutate,
  };
};

export const useAccessRoles = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/access_roles`,
    fetcher
  );
  return {
--
    isError: error,
    refreshAccessRoles: mutate,
  };
};

export const useJobTitles = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/job_titles`,
    fetcher
  );
  return {
--
    refreshJobTitles: mutate,
  };
};

// Enhanced fetchData with better error handling
export async function enhancedFetchData(
  resource: string,
  id?: string,
  data?: Record<string, any>,
  method: "GET" | "POST" | "PUT" | "DELETE" = "GET"
): Promise<any | null> {
--
    console.error(`API Error for ${resource}:`, error);
    throw error;
  }
}

export async function calculatePayroll(
  employeeId: string,
  periodStart: string,
  periodEnd: string
): Promise<any> {
  const response = await fetchData(
--
    "POST"
  );
  return response;
}

export async function processPayroll(payrollId: string): Promise<any> {
  const response = await fetchData(
    `payroll/${payrollId}/process`,
    undefined,
    {},
    "POST"
  );
  return response;
}

export async function createPayroll(payrollData: any): Promise<any> {
  const response = await fetchData("payroll", undefined, payrollData, "POST");
  return response;
}

export async function updatePayrollSettings(settings: any): Promise<any> {
  const response = await fetchData(
    "payroll_settings",
    undefined,
    settings,
    "POST"
  );
  return response;
}

// Inventory functions
export async function getInventoryProducts(): Promise<any[]> {
  const response = await fetchData("inventory_products");
  return response;
}

// Add these functions to your api.ts file

// Sites functions
export async function getSites(): Promise<any[]> {
  const response = await fetchData("sites");
  return response;
}

export async function createSite(siteData: any): Promise<any> {
  const response = await fetchData("sites", undefined, siteData, "POST");
  return response;
}

export async function updateSite(siteId: string, siteData: any): Promise<any> {
  const response = await fetchData("sites", siteId, siteData, "PUT");
  return response;
}

export async function deleteSite(siteId: string): Promise<any> {
  const response = await fetchData("sites", siteId, undefined, "DELETE");
  return response;
}

export async function deletePurchaseOrder(orderId: string): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
    orderId,
    undefined,
    "DELETE"
  );
  return response;
}

export async function updateGoodsReceipt(
  receiptId: string,
  receiptData: any
): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
--
    "PUT"
  );
  return response;
}

export async function deleteGoodsReceipt(receiptId: string): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
    receiptId,
    undefined,
    "DELETE"
  );
  return response;
}

export async function createInventoryProduct(productData: any): Promise<any> {
  const response = await fetchData(
    "inventory_products",
    undefined,
    productData,
    "POST"
  );
  return response;
}

export async function updateInventoryProduct(
  productId: string,
  productData: any
): Promise<any> {
  const response = await fetchData(
    "inventory_products",
--
    "PUT"
  );
  return response;
}

export async function deleteInventoryProduct(productId: string): Promise<any> {
  const response = await fetchData(
    "inventory_products",
    productId,
    undefined,
    "DELETE"

--- SHIFTMANAGEMENT.TSX (full file) ---
// src/app/pos/management/[entityName]/ShiftManagement.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Box,
  Center,
  Flex,
  Heading,
  Spinner,
  useToast,
  useDisclosure,
  Text,
  Alert,
  AlertIcon,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Button,
  HStack,
} from "@chakra-ui/react";
import ShiftCalendar from "./ShiftManagementComponents/ShiftCalendar";
import EmployeeList from "./ShiftManagementComponents/EmployeeList";
import ShiftModal from "./ShiftManagementComponents/ShiftModal";
import ShiftUpdateModal from "./ShiftManagementComponents/ShiftUpdateModal";
import {
  getShifts,
  getEmployees,
  createShift,
  updateShift,
  deleteShift,
} from "@/lib/api";
import { usePOSStore } from "@/lib/usePOSStore";
import moment from "moment";
import {
  Employee as EmployeeDetails,
  Shift as ShiftDetails,
} from "@/lib/config/entities";
import { logger } from "@/lib/logger";
import { FaSync, FaExclamationTriangle } from "react-icons/fa";

export interface Employee extends EmployeeDetails {
  name?: string;
  role?: string;
}

export interface Shift extends ShiftDetails {
  recurs: boolean;
  recurringDay?: number;
  start: Date;
  end: Date;
  employee_name?: string;
  color?: string;
  active?: boolean;
}

export default function ShiftsPage() {
  const {
    shifts,
    setShifts,
    addShift,
    updateShift: updateStoreShift,
    deleteShift: deleteStoreShift,
    employees: storeEmployees,
    setEmployees,
  } = usePOSStore();

  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee | null>(
    null
  );
  const [selectedShift, setSelectedShift] = useState<Shift | null>(null);
  const [error, setError] = useState<string | null>(null);
  const toast = useToast();
  const { isOpen, onOpen, onClose } = useDisclosure();

  useEffect(() => {
    logger.info("ShiftManagement: useEffect triggered. Starting data load.");
    const loadData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [fetchedShifts, fetchedEmployees] = await Promise.all([
          getShifts(),
          getEmployees(),
        ]);

        logger.info("ShiftManagement: Raw data from API received.");
        logger.info("   - Fetched Shifts: ", fetchedShifts);
        logger.info("   - Fetched Employees: ", fetchedEmployees);

        // Map employees with proper typing
        const mappedEmployees: Employee[] = fetchedEmployees.map((emp) => ({
          ...emp,
          name: `${emp.first_name} ${emp.last_name}`,
          role: emp.job_title_id,
          // Ensure color is set for calendar display
          color: emp.color || "#3182CE",
        }));

        logger.info(
          "ShiftManagement: Processed and mapped employees.",
          mappedEmployees
        );

        // Process shifts with proper date handling and employee enrichment
        const shiftsWithNamesAndDates: Shift[] = fetchedShifts
          .map((shift: any) => {
            try {
              const employee = mappedEmployees.find(
                (e) => e.id === shift.employee_id
              );

              // Handle date conversion safely
              let startDate: Date;
              let endDate: Date;

              try {
                startDate = moment(shift.start).toDate();
                endDate = moment(shift.end).toDate();
              } catch (dateError) {
                logger.error(
                  "ShiftManagement: Invalid date format, using current date as fallback",
                  shift
                );
                startDate = new Date();
                endDate = new Date();
              }

              return {
                ...shift,
                id: shift.id,
                employee_id: shift.employee_id,
                start: startDate,
                end: endDate,
                employee_name: employee ? employee.name : "Unknown",
                color: employee?.color || "#3182CE",
                recurs: shift.recurs || false,
                recurringDay: shift.recurringDay,
                active: shift.active !== false, // Default to true if not specified
                title: shift.title || `Shift - ${employee?.name || "Unknown"}`,
                created_at: shift.created_at,
                updated_at: shift.updated_at,
              };
            } catch (error) {
              logger.error(
                "ShiftManagement: Error processing shift, skipping.",
                shift,
                error
              );
              return null;
            }
          })
          .filter(Boolean) as Shift[];

        logger.info(
          "ShiftManagement: Processed shifts with employee names.",
          shiftsWithNamesAndDates
        );

        setShifts(shiftsWithNamesAndDates);
        setEmployees(mappedEmployees);
        logger.info("ShiftManagement: Data successfully set in Zustand store.");
      } catch (error: any) {
        logger.error("ShiftManagement: Failed to load data", error);
        setError(error.message || "Failed to load shift data.");
        toast({
          title: "Failed to load data.",
          description:
            error.message ||
            "Could not fetch shifts or employees. Please try again.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [setShifts, setEmployees, toast]);

  const handleAddShift = async (newShiftData: {
    employeeId: string;
    start: Date;
    end: Date;
    recurs: boolean;
  }) => {
    if (!selectedEmployee) return;

    try {
      setIsProcessing(true);
      const { employeeId, start, end, recurs } = newShiftData;

      // Calculate recurring day if needed
      const recurringDay = recurs ? moment(start).day() : undefined;

      // Prepare API payload
      const apiPayload = {
        employee_id: employeeId,
        start: start.toISOString(),
        end: end.toISOString(),
        recurs: recurs,
        recurringDay: recurringDay,
        active: true,
        title: `Shift - ${selectedEmployee.name}`,
        // Include store_id if available
        store_id: selectedEmployee.store_id || "default-store",
      };

      logger.info("ShiftManagement: Creating shift with payload:", apiPayload);

      const createdShift = await createShift(apiPayload);

      // Convert the created shift to the frontend format
      const shiftToAdd: Shift = {
        ...createdShift,
        start: moment(createdShift.start).toDate(),
        end: moment(createdShift.end).toDate(),
        employee_name: selectedEmployee.name,
        color: selectedEmployee.color,
        recurs: createdShift.recurs || false,
        recurringDay: createdShift.recurringDay,
        active: createdShift.active !== false,
        title: createdShift.title || `Shift - ${selectedEmployee.name}`,
      };

      addShift(shiftToAdd);

      toast({
        title: "Shift added successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to add shift", error);
      toast({
        title: "Failed to add shift.",
        description:
          error.message || "An error occurred while saving the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleUpdateShift = async (
    shiftId: string,
    updates: Partial<Shift>
  ) => {
    try {
      setIsProcessing(true);
      const originalShift = shifts.find((s) => s.id === shiftId);
      if (!originalShift) {
        logger.error("Shift not found for update:", shiftId);
        toast({
          title: "Error Updating Shift",
          description: "Original shift not found.",
          status: "error",
          duration: 4000,
          isClosable: true,
        });
        return;
      }

      // Prepare API payload with proper date formatting
      const apiPayload = {
        ...originalShift,
        ...updates,
        start: updates.start
          ? updates.start.toISOString()
          : originalShift.start.toISOString(),
        end: updates.end
          ? updates.end.toISOString()
          : originalShift.end.toISOString(),
        // Preserve recurrence settings
        recurs: originalShift.recurs,
        recurringDay: originalShift.recurs
          ? moment(updates.start || originalShift.start).day()
          : undefined,
        // Ensure required fields
        employee_id: originalShift.employee_id,
        active:
          updates.active !== undefined ? updates.active : originalShift.active,
      };

      logger.info("ShiftManagement: Updating shift with payload:", apiPayload);

      const updatedShift = await updateShift(shiftId, apiPayload);

      // Convert to frontend format
      const shiftToUpdate: Shift = {
        ...updatedShift,
        start: moment(updatedShift.start).toDate(),
        end: moment(updatedShift.end).toDate(),
        employee_name: originalShift.employee_name,
        color: originalShift.color,
        recurs: updatedShift.recurs || false,
        recurringDay: updatedShift.recurringDay,
        active: updatedShift.active !== false,
      };

      updateStoreShift(shiftId, shiftToUpdate);

      toast({
        title: "Shift updated successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to update shift", error);
      toast({
        title: "Failed to update shift.",
        description:
          error.message || "An error occurred while updating the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleDeleteShift = async (shiftId: string) => {
    try {
      setIsProcessing(true);
      await deleteShift(shiftId);
      deleteStoreShift(shiftId);

      toast({
        title: "Shift deleted successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to delete shift", error);
      toast({
        title: "Failed to delete shift.",
        description:
          error.message || "An error occurred while deleting the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSelectEmployee = (employee: Employee) => {
    setSelectedEmployee(employee);
    setSelectedShift(null);
    onOpen();
  };

  const handleEditShift = (shift: Shift) => {
    setSelectedShift(shift);
    const employee = storeEmployees.find((emp) => emp.id === shift.employee_id);
    setSelectedEmployee(employee || null);
    onOpen();
  };

  const handleModalClose = () => {
    setSelectedEmployee(null);
    setSelectedShift(null);
    onClose();
  };

  const refreshData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [fetchedShifts, fetchedEmployees] = await Promise.all([
        getShifts(),
        getEmployees(),
      ]);

      const mappedEmployees: Employee[] = fetchedEmployees.map((emp) => ({
        ...emp,
        name: `${emp.first_name} ${emp.last_name}`,
        role: emp.job_title_id,
        color: emp.color || "#3182CE",
      }));

      const shiftsWithNamesAndDates: Shift[] = fetchedShifts
        .map((shift: any) => {
          try {
            const employee = mappedEmployees.find(
              (e) => e.id === shift.employee_id
            );
            return {
              ...shift,
              start: moment(shift.start).toDate(),
              end: moment(shift.end).toDate(),
              employee_name: employee ? employee.name : "Unknown",
              color: employee?.color || "#3182CE",
              recurs: shift.recurs || false,
              recurringDay: shift.recurringDay,
              active: shift.active !== false,
            };
          } catch (error) {
            return null;
          }
        })
        .filter(Boolean) as Shift[];

      setShifts(shiftsWithNamesAndDates);
      setEmployees(mappedEmployees);
    } catch (error: any) {
      setError(error.message || "Failed to refresh data.");
    } finally {
      setIsLoading(false);
    }
  };

  // Calculate statistics
  const activeShifts = shifts.filter((s) => s.active);
  const todayShifts = activeShifts.filter((shift) =>
    moment(shift.start).isSame(moment(), "day")
  );
  const upcomingShifts = activeShifts.filter((shift) =>
    moment(shift.start).isAfter(moment())
  );

  if (isLoading) {
    return (
      <Center minH="400px">
        <Spinner size="xl" />
      </Center>
    );
  }

  return (
    <Box bg="gray.50" minH="100vh">
      <Flex
        as="header"
        position="sticky"
        top="0"
        zIndex="10"
        bg="white"
        p={5}
        borderBottom="1px"
        borderColor="gray.200"
        justifyContent="space-between"
        alignItems="center"
      >
        <Heading as="h1" size="xl">
          Shift Management
        </Heading>
        <HStack spacing={4}>
          <Button
            leftIcon={<FaSync />}
            onClick={refreshData}
            isLoading={isProcessing}
          >
            Refresh
          </Button>
        </HStack>
      </Flex>

      {error && (
        <Alert status="error" mx={5} mt={5} borderRadius="md">
          <AlertIcon />
          {error}
        </Alert>
      )}

      {/* Statistics Overview */}
      <SimpleGrid columns={3} spacing={4} p={5}>
        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Total Shifts</StatLabel>
          <StatNumber>{activeShifts.length}</StatNumber>
          <StatHelpText>Active shifts</StatHelpText>
        </Stat>

        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Today's Shifts</StatLabel>
          <StatNumber color="blue.500">{todayShifts.length}</StatNumber>
          <StatHelpText>Scheduled for today</StatHelpText>
        </Stat>

        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Upcoming Shifts</StatLabel>
          <StatNumber color="green.500">{upcomingShifts.length}</StatNumber>
          <StatHelpText>Future shifts</StatHelpText>
        </Stat>
      </SimpleGrid>

      <Box p={5}>
        <Flex direction={{ base: "column", md: "row" }} gap={6}>
          {/* Employee List - Fixed width to match sidebar */}
          <Box flex="0 0 240px" bg="white" p={6} rounded="md" shadow="sm">
            <EmployeeList
              employees={storeEmployees || []}
              onEmployeeClick={handleSelectEmployee}
            />
          </Box>

          {/* Calendar - Takes remaining space */}
          <Box flex="1" bg="white" p={6} rounded="md" shadow="sm" minWidth="0">
            <Heading as="h2" size="lg" mb={4}>
              Shift Calendar
            </Heading>
            {activeShifts.length === 0 ? (
              <Center h="300px" flexDirection="column">
                <FaExclamationTriangle size={48} color="#CBD5E0" />
                <Text color="gray.500" mt={4}>
                  No shifts scheduled. Click on an employee to create a shift.
                </Text>
              </Center>
            ) : (
              <ShiftCalendar
                shifts={activeShifts}
                employees={storeEmployees || []}
                onUpdateShift={handleUpdateShift}
                onDeleteShift={handleDeleteShift}
                onSelectShift={handleEditShift}
              />
            )}
          </Box>
        </Flex>
      </Box>

      {/* Modals */}
      {selectedShift ? (
        <ShiftUpdateModal
          isOpen={isOpen}
          onClose={handleModalClose}
          selectedShift={selectedShift}
          employee={selectedEmployee}
          onUpdateShift={handleUpdateShift}
          onDeleteShift={handleDeleteShift}
          isLoading={isProcessing}
        />
      ) : (
        <ShiftModal
          isOpen={isOpen}
          onClose={handleModalClose}
          employee={selectedEmployee}
          existingShifts={shifts.filter(
            (s) => s.employee_id === selectedEmployee?.id && s.active
          )}
          onAddShift={handleAddShift}
          isLoading={isProcessing}
        />
      )}
    </Box>
  );
}

--- PAGE.TSX (handleEdit area) ---
455-      user: {},
456-      other_access_roles: [],
457-      is_active: true,
458-      is_available: true,
459-    });
460-    setCurrentRecipes([]);
461-    setIsEditing(false);
462-    onOpen();
463-  };
464-
465:  const handleEdit = useCallback(
466-    (item: any) => {
467-      const otherRoles = Array.isArray(item.other_access_roles)
468-        ? item.other_access_roles
469-        : [];
470-      setSelectedItem({
471-        ...item,
472-        user: { ...item.user } || {},
473-        other_access_roles: otherRoles,
474-      });
475-      setCurrentRecipes(item.recipes || []);
--
632-  const actionColumn = useMemo(
633-    () => ({
634-      accessorKey: "actions",
635-      header: "Actions",
636-      isSortable: false,
637-      cell: (row: any) => (
638-        <HStack>
639-          <IconButton
640-            aria-label="Edit"
641-            icon={<FaEdit />}
642:            onClick={() => handleEdit(row)}
643-            size="sm"
644-            colorScheme="blue"
645-          />
646-          <IconButton
647-            aria-label="Delete"
648-            icon={<FaTrash />}
649-            onClick={() => handleDelete(row.id)}
650-            size="sm"
651-            colorScheme="red"
652-          />
653-        </HStack>
654-      ),
655-    }),
656:    [handleDelete, handleEdit]
657-  );
658-
659-  const columns: Column[] = useMemo(() => {
660-    if (!entityConfig) {
661-      return [];
662-    }
663-
664-    let entityColumns: Column[] = [];
665-
666-    if (entityName === "employees") {
