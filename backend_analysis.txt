=== MAIN FASTAPI FILE ===
# app/main.py - UPDATED WITH LOGGING
from fastapi import FastAPI, HTTPException
from app.routes import core, hr, inventory, auth
from app.database import client
from fastapi.middleware.cors import CORSMiddleware
from app.middleware.logging_middleware import LoggingMiddleware
from app.logging_config import get_logger, setup_logging
from app.routes import core, hr, inventory, auth, log_router
import os

# Setup logging
setup_logging()
logger = get_logger("api.main")

app = FastAPI(title="POS System API", version="1.0.0")

# Add logging middleware
app.add_middleware(LoggingMiddleware)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers - FIXED: Remove duplicate prefix since routers already have /api
app.include_router(core.router)
app.include_router(hr.router) 
app.include_router(inventory.router)
app.include_router(auth.router)
app.include_router(log_router)

@app.on_event("startup")
async def startup_event():
    try:
        await client.admin.command('ping')
        logger.info("✅ Connected to MongoDB!")
        print("✅ Connected to MongoDB!")
    except Exception as e:
        logger.error(f"❌ Could not connect to MongoDB: {e}")
        print(f"❌ Could not connect to MongoDB: {e}")

@app.on_event("shutdown")
async def shutdown_event():
    client.close()
    logger.info("✅ MongoDB connection closed.")
    print("✅ MongoDB connection closed.")

@app.get("/")
async def root():
    logger.info("Root endpoint accessed")
    return {"message": "POS System API is running"}

@app.get("/health")
async def health_check():
    try:
        await client.admin.command('ping')
        logger.info("Health check: OK")
        return {"status": "healthy", "database": "connected"}
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {"status": "unhealthy", "database": "disconnected"}

=== CORE CONFIG ===
# app/core.py - Core models and business logic
from .base import MongoModel
from typing import Optional, List, Dict, Any
from pydantic import Field, EmailStr
from datetime import datetime

# Add your core models here that were previously missing
class CoreBusinessLogic:
    """Core business logic that can be shared across modules"""
    
    @staticmethod
    def calculate_order_totals(items: List[Dict]) -> Dict[str, float]:
        """Calculate order subtotal, tax, and total"""
        subtotal = sum(item.get('price', 0) * item.get('quantity', 0) for item in items)
        tax = subtotal * 0.1  # 10% tax
        total = subtotal + tax
        
        return {
            "subtotal": subtotal,
            "tax": tax,
            "total": total
        }

# Add any missing core models that might be needed
class SimpleModel(MongoModel):
    """A simple model for testing"""
    name: str
    description: Optional[str] = None

=== DATABASE CONFIG ===
# app/database.py - FIXED VERSION
from motor.motor_asyncio import AsyncIOMotorClient
import os
from dotenv import load_dotenv
from app.utils.db_logger import log_find, log_insert, log_update, log_delete, log_error
from app.logging_config import get_logger

load_dotenv()

logger = get_logger("api.database")

MONGO_DETAILS = os.getenv("MONGODB_URL")

if not MONGO_DETAILS:
    raise Exception("MONGODB_URL environment variable is missing or empty. Please check your .env file.")

client = AsyncIOMotorClient(MONGO_DETAILS)
database = client.pos_system

# Collection references
def get_collection(collection_name):
    return LoggedCollection(database[collection_name], collection_name)

# Helper to convert MongoDB documents
def document_helper(document) -> dict:
    if document:
        document["id"] = str(document["_id"])
        del document["_id"]
    return document

# Wrapper class for logged collection operations - FIXED VERSION
class LoggedCollection:
    def __init__(self, collection, collection_name):
        self.collection = collection
        self.collection_name = collection_name
    
    async def find(self, query=None, **kwargs):
        try:
            cursor = self.collection.find(query or {}, **kwargs)
            results = await cursor.to_list(length=None)
            log_find(self.collection_name, query, len(results))
            return results
        except Exception as e:
            log_error(self.collection_name, "find", str(e), query)
            raise
    
    async def find_one(self, query=None, **kwargs):
        try:
            result = await self.collection.find_one(query or {}, **kwargs)
            log_find(self.collection_name, query, 1 if result else 0)
            return result
        except Exception as e:
            log_error(self.collection_name, "find_one", str(e), query)
            raise
    
    async def insert_one(self, document, **kwargs):
        try:
            result = await self.collection.insert_one(document, **kwargs)
            log_insert(self.collection_name, document, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "insert_one", str(e))
            raise
    
    async def insert_many(self, documents, **kwargs):
        try:
            result = await self.collection.insert_many(documents, **kwargs)
            log_insert(self.collection_name, documents, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "insert_many", str(e))
            raise
    
    async def update_one(self, filter, update, **kwargs):
        try:
            result = await self.collection.update_one(filter, update, **kwargs)
            log_update(self.collection_name, filter, update, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "update_one", str(e), filter)
            raise
    
    async def update_many(self, filter, update, **kwargs):
        try:
            result = await self.collection.update_many(filter, update, **kwargs)
            log_update(self.collection_name, filter, update, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "update_many", str(e), filter)
            raise
    
    async def delete_one(self, filter, **kwargs):
        try:
            result = await self.collection.delete_one(filter, **kwargs)
            log_delete(self.collection_name, filter, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "delete_one", str(e), filter)
            raise
    
    async def delete_many(self, filter, **kwargs):
        try:
            result = await self.collection.delete_many(filter, **kwargs)
            log_delete(self.collection_name, filter, result)
            return result
        except Exception as e:
            log_error(self.collection_name, "delete_many", str(e), filter)
            raise
    
    def __getattr__(self, name):
        """Forward any other attributes to the underlying collection"""
        return getattr(self.collection, name)

=== LOGGING CONFIG ===
# app/logging_config.py
import logging
import sys
from logging.handlers import RotatingFileHandler
import os
from datetime import datetime
import json

# Create logs directory if it doesn't exist
os.makedirs("logs", exist_ok=True)

# Custom formatter that includes timestamps with milliseconds
class DetailedFormatter(logging.Formatter):
    def format(self, record):
        # Add current timestamp with milliseconds
        record.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
        
        # Format message for JSON-like structure
        if hasattr(record, 'extra_data'):
            extra_data = json.dumps(record.extra_data, default=str)
            record.msg = f"{record.msg} | Extra: {extra_data}"
        
        return super().format(record)

def setup_logging():
    """Setup comprehensive logging configuration"""
    
    # Create logger
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # Clear any existing handlers
    logger.handlers.clear()
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    console_format = DetailedFormatter(
        '%(timestamp)s | %(levelname)-8s | %(name)-20s | %(message)s'
    )
    console_handler.setFormatter(console_format)
    
    # File handler with rotation
    file_handler = RotatingFileHandler(
        'logs/api.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.INFO)
    file_format = DetailedFormatter(
        '%(timestamp)s | %(levelname)-8s | %(name)-20s | %(filename)s:%(lineno)d | %(message)s'
    )
    file_handler.setFormatter(file_format)
    
    # Add handlers
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    # Set specific log levels for noisy libraries
    logging.getLogger('motor').setLevel(logging.WARNING)
    logging.getLogger('urllib3').setLevel(logging.WARNING)
    logging.getLogger('asyncio').setLevel(logging.WARNING)
    logging.getLogger('watchfiles').setLevel(logging.WARNING)  # ADD THIS LINE
    logging.getLogger('uvicorn.access').setLevel(logging.WARNING)


# Create logger instances for different modules
def get_logger(name):
    """Get a named logger instance"""
    return logging.getLogger(name)

# Initialize logging when module is imported
setup_logging()

=== AUTH ROUTES ===
from fastapi import APIRouter, HTTPException, Depends, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from app.database import get_collection
from app.models.hr import Employee
from app.models.response import StandardResponse, EmployeeResponse, LoginResponse
from app.utils.response_helpers import success_response, error_response, handle_generic_exception
from bson import ObjectId
import bcrypt
import jwt
import os
from datetime import datetime, timedelta
from typing import Dict, List, Any

router = APIRouter(prefix="/api", tags=["auth"])
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/login")

# --- Configuration & Environment Variables ---
SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your-secret-key-here-change-in-production")
ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))

# --- Utility Functions ---

def hash_password(password: str) -> str:
    """Hash a password for storing."""
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a stored password against one provided by user."""
    if not hashed_password.startswith("$2b$"):
        return plain_password == hashed_password
    return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))

def create_access_token(data: dict, expires_delta: timedelta = None):
    """Creates a signed JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire, "iat": datetime.utcnow()})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def _fetch_and_enrich_employee_data(employee_id: str) -> Dict[str, Any]:
    """
    Fetches employee data and enriches it with detailed role information.
    """
    try:
        employees_collection = get_collection("employees")
        access_roles_collection = get_collection("access_roles")
        
        employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
        if not employee:
            raise HTTPException(status_code=404, detail="Employee data not found")
            
        # Convert MongoDB document to Employee Pydantic model for base data
        employee_data = Employee.from_mongo(employee)
        employee_dict = employee_data.model_dump()
        
        # 1. Get main access role details
        main_access_role = None
        if employee.get("main_access_role_id"):
            main_access_role = await access_roles_collection.find_one(
                {"_id": ObjectId(employee["main_access_role_id"])}
            )
        
        if main_access_role:
            employee_dict["main_access_role"] = {
                "id": str(main_access_role["_id"]),
                "name": main_access_role.get("name", ""),
                "description": main_access_role.get("description", ""),
                "permissions": main_access_role.get("permissions", []),
                "landing_page": main_access_role.get("landing_page", "")
            }
        
        # 2. Get all access roles for the employee - FIXED: Use await instead of async for
        employee_access_roles: List[Dict] = []
        role_ids = [ObjectId(rid) for rid in employee.get("access_role_ids", [])]
        if role_ids:
            # FIX: Use await and iterate over the list result
            roles = await access_roles_collection.find({"_id": {"$in": role_ids}})
            for role in roles:
                employee_access_roles.append({
                    "id": str(role["_id"]),
                    "name": role.get("name", ""),
                    "description": role.get("description", ""),
                    "permissions": role.get("permissions", []),
                    "landing_page": role.get("landing_page", "")
                })
        
        employee_dict["access_roles"] = employee_access_roles
        
        return employee_dict
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/debug/users", response_model=StandardResponse[List[dict]])
async def debug_users():
    """Debug endpoint to see all users and their emails"""
    try:
        users_collection = get_collection("users")
        users = []
        # FIX: Use await and iterate over list
        user_docs = await users_collection.find()
        for user in user_docs:
            users.append({
                "id": str(user["_id"]),
                "username": user.get("username"),
                "email": user.get("email"),
                "has_password": bool(user.get("password")),
                "password_length": len(user.get("password", "")),
                "password_prefix": user.get("password", "")[:10] + "..." if user.get("password") else None
            })
        return success_response(data=users)
    except Exception as e:
        return handle_generic_exception(e)

# --- JWT Functions ---

async def get_current_employee(token: str = Depends(oauth2_scheme)):
    """Verifies the JWT token and returns the employee data."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        employee_id: str = payload.get("employee_id")
        if employee_id is None:
            raise credentials_exception
            
        employees_collection = get_collection("employees")
        employee_doc = await employees_collection.find_one({"_id": ObjectId(employee_id)})

        if employee_doc is None:
            raise credentials_exception

        return {"id": employee_id, "store_id": payload.get("store_id")}

    except jwt.PyJWTError:
        raise credentials_exception

# --- Public Endpoints ---

@router.post("/register", response_model=StandardResponse[EmployeeResponse])
async def register_employee(employee: Employee):
    """Registers a new employee."""
    try:
        employees_collection = get_collection("employees")
        
        # Check for duplicate email
        if await employees_collection.find_one({"email": employee.email}):
            return error_response(
                message=f"Employee with email '{employee.email}' already exists.",
                code=409
            )

        # Insert the new employee using the helper function
        from app.utils.mongo_helpers import to_mongo_dict
        employee_dict = to_mongo_dict(employee)
        employee_dict["password"] = hash_password("defaultpassword")
        
        new_employee = await employees_collection.insert_one(employee_dict)
        created_employee = await employees_collection.find_one({"_id": new_employee.inserted_id})
        
        return success_response(
            data=Employee.from_mongo(created_employee),
            message="Employee registered successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/login", response_model=StandardResponse[LoginResponse])
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """Handles employee login, validates credentials, and generates a JWT."""
    try:
        users_collection = get_collection("users")
        
        # Find user by email or username
        user = await users_collection.find_one({
            "$or": [
                {"email": form_data.username},
                {"username": form_data.username}
            ]
        })
        
        if not user:
            return error_response(message="Invalid credentials", code=401)
        
        # Check password
        password_valid = verify_password(form_data.password, user.get("password", ""))
        
        if not password_valid:
            return error_response(message="Invalid credentials", code=401)
        
        # Find employee linked to this user
        employees_collection = get_collection("employees")
        employee = await employees_collection.find_one({"user_id": str(user["_id"])})
        
        if not employee:
            return error_response(message="Account not authorized for employee access", code=403)
        
        employee_id = str(employee["_id"])
        
        # Get enriched employee data
        enriched_employee_data = await _fetch_and_enrich_employee_data(employee_id)
        
        # Create access token
        access_token = create_access_token(data={
            "sub": user["email"], 
            "user_id": str(user["_id"]),
            "employee_id": employee_id,
            "store_id": enriched_employee_data.get("store_id", ""),
            "roles": enriched_employee_data.get("access_role_ids", [])
        })
        
        return success_response(data={
            "access_token": access_token,
            "token_type": "bearer",
            "employee": enriched_employee_data
        })
    except HTTPException as e:
        return error_response(message=str(e.detail), code=e.status_code)
    except Exception as e:
        return handle_generic_exception(e)

async def get_current_employee_full(token: str = Depends(oauth2_scheme)) -> Dict[str, Any]:
    """
    Decodes the JWT token and fetches the current employee's detailed information.
    """
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        employee_id: str = payload.get("employee_id")
        if employee_id is None:
            raise credentials_exception
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired", headers={"WWW-Authenticate": "Bearer"})
    except jwt.JWTError:
        raise credentials_exception
    
    # Fetch and enrich employee data
    try:
        enriched_employee_data = await _fetch_and_enrich_employee_data(employee_id)
    except HTTPException:
        raise credentials_exception
    
    return enriched_employee_data

@router.get("/employees/me", response_model=StandardResponse[EmployeeResponse])
async def read_employees_me(current_employee: Dict[str, Any] = Depends(get_current_employee_full)):
    """Retrieves the full profile of the currently authenticated employee."""
    return success_response(data=current_employee)

@router.post("/logout", response_model=StandardResponse[dict])
async def logout():
    """Provides a successful logout message."""
    return success_response(data=None, message="Successfully logged out")

@router.post("/refresh-token", response_model=StandardResponse[LoginResponse])
async def refresh_token(current_employee: Dict[str, Any] = Depends(get_current_employee_full)):
    """Generates a new JWT for an authenticated user."""
    try:
        users_collection = get_collection("users")
        user = await users_collection.find_one({"_id": ObjectId(current_employee.get("user_id"))})
        
        if not user:
            return error_response(message="User not found", code=404)
        
        access_token = create_access_token(data={
            "sub": user["email"], 
            "user_id": str(user["_id"]),
            "employee_id": current_employee.get("id"),
            "store_id": current_employee.get("store_id", ""),
            "roles": current_employee.get("access_role_ids", [])
        })
        
        return success_response(data={
            "access_token": access_token,
            "token_type": "bearer",
            "employee": current_employee
        })
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/forgot-password", response_model=StandardResponse[dict])
async def forgot_password(email: str):
    """Initiates the password reset process."""
    try:
        users_collection = get_collection("users")
        user = await users_collection.find_one({"email": email})
        
        if user:
            # Placeholder for password reset logic
            pass
        
        # Always return the same message for security
        return success_response(
            data=None,
            message="If an account with that email exists, a password reset link has been sent."
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/reset-password", response_model=StandardResponse[dict])
async def reset_password(token: str, new_password: str):
    """Processes the password reset request using the token."""
    try:
        # Placeholder for password reset logic
        return success_response(
            data=None,
            message="If the token is valid, your password has been reset successfully."
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/verify-token", response_model=StandardResponse[dict])
async def verify_token(current_employee: Dict[str, Any] = Depends(get_current_employee_full)):
    """Used by the frontend to verify if the token is still valid."""
    return success_response(data={
        "valid": True,
        "employee_id": current_employee.get("id"),
        "store_id": current_employee.get("store_id"),
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
    })

@router.get("/health")
async def auth_health_check():
    """Health check for the authentication service."""
    return success_response(data={"status": "healthy", "module": "auth"})

=== CORE ROUTES ===
# app/routes/core.py - COMPLETELY UPDATED
from fastapi import APIRouter, HTTPException, Depends, Query, status
from typing import List, Optional
from app.database import get_collection
from app.models.core import (
    Food, Order, Category, Customer, Table, Store, PurchaseOrder, GoodsReceipt, 
    Reservation, Tenant, Domain, Site, PaymentMethod, Tax, Payment, Brand, ContactMessage, User, Report, PasswordReset, Job, FailedJob
)
from app.models.inventory import InventoryProduct
from app.models.response import (
    StandardResponse, FoodResponse, OrderResponse, CategoryResponse, CustomerResponse, 
    TableResponse, StoreResponse, PurchaseOrderResponse, 
    GoodsReceiptResponse, ReservationResponse,
    InventoryProductResponse, TenantResponse, DomainResponse, 
    SiteResponse, PaymentMethodResponse, TaxResponse, PaymentResponse, 
    BrandResponse, ContactMessageResponse, UserResponse, ReportResponse, PasswordResetResponse, JobResponse, FailedJobResponse
)
from app.utils.response_helpers import success_response, error_response, handle_http_exception, handle_generic_exception
from app.utils.mongo_helpers import to_mongo_dict, to_mongo_update_dict
from bson import ObjectId
from datetime import datetime
import math

router = APIRouter(prefix="/api", tags=["core"])

# --- Generic CRUD Helper Functions ---

async def _create_item(collection_name: str, item_model, response_model):
    """Generic function to create a new item with proper response handling"""
    try:
        collection = get_collection(collection_name)
        item_dict = to_mongo_dict(item_model)
        result = await collection.insert_one(item_dict)
        new_item = await collection.find_one({"_id": result.inserted_id})
        
        # Handle different model types with to_response_dict method
        if hasattr(item_model, 'to_response_dict'):
            item_instance = item_model.__class__.from_mongo(new_item)
            response_data = item_instance.to_response_dict()
        else:
            response_data = item_model.from_mongo(new_item)
            
        return success_response(
            data=response_data,
            message=f"{collection_name[:-1].capitalize()} created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

async def _get_all_items(collection_name: str, item_model, query: dict = None):
    """Generic function to retrieve a list of items with proper response handling"""
    try:
        collection = get_collection(collection_name)
        items_data = await collection.find(query or {})
        items = []
        for item in items_data:
            # Handle models with to_response_dict method
            item_instance = item_model.from_mongo(item)
            if hasattr(item_instance, 'to_response_dict'):
                items.append(item_instance.to_response_dict())
            else:
                items.append(item_instance)
        return success_response(data=items)
    except Exception as e:
        return handle_generic_exception(e)

async def _get_item_by_id(collection_name: str, item_id: str, item_model):
    """Generic function to retrieve a single item by ID with proper response handling"""
    try:
        collection = get_collection(collection_name)
        item = await collection.find_one({"_id": ObjectId(item_id)})
    except Exception:
        return error_response(message=f"Invalid ID format for {collection_name}", code=400)
        
    if item:
        # Handle models with to_response_dict method
        item_instance = item_model.from_mongo(item)
        if hasattr(item_instance, 'to_response_dict'):
            return success_response(data=item_instance.to_response_dict())
        else:
            return success_response(data=item_instance)
    return error_response(message=f"{collection_name[:-1].capitalize()} not found", code=404)

async def _update_item(collection_name: str, item_id: str, item_model, response_model):
    """Generic function to update an item with proper response handling"""
    try:
        collection = get_collection(collection_name)
        item_dict = to_mongo_update_dict(item_model, exclude_unset=True)
        
        result = await collection.update_one(
            {"_id": ObjectId(item_id)}, {"$set": item_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message=f"{collection_name[:-1].capitalize()} not found", code=404)
            
        updated_item = await collection.find_one({"_id": ObjectId(item_id)})
        
        # Handle models with to_response_dict method
        item_instance = item_model.__class__.from_mongo(updated_item)
        if hasattr(item_instance, 'to_response_dict'):
            response_data = item_instance.to_response_dict()
        else:
            response_data = item_instance
            
        return success_response(
            data=response_data,
            message=f"{collection_name[:-1].capitalize()} updated successfully"
        )
    except Exception as e:
        return handle_generic_exception(e)

async def _delete_item(collection_name: str, item_id: str):
    """Generic function to delete an item."""
    try:
        collection = get_collection(collection_name)
        result = await collection.delete_one({"_id": ObjectId(item_id)})
        if result.deleted_count == 0:
            return error_response(message=f"{collection_name[:-1].capitalize()} not found", code=404)
        return success_response(
            data=None,
            message=f"{collection_name[:-1].capitalize()} deleted successfully"
        )
    except Exception as e:
        return handle_generic_exception(e)

# --------------------------
# --- Food Endpoints ---
# --------------------------
@router.get("/foods", response_model=StandardResponse[List[FoodResponse]])
async def get_foods(store_id: Optional[str] = Query(None)):
    return await _get_all_items("foods", Food, {"store_id": store_id} if store_id else {})

@router.get("/foods/{food_id}", response_model=StandardResponse[FoodResponse])
async def get_food(food_id: str):
    return await _get_item_by_id("foods", food_id, Food)

@router.post("/foods", response_model=StandardResponse[FoodResponse])
async def create_food(food: Food):
    return await _create_item("foods", food, FoodResponse)

@router.put("/foods/{food_id}", response_model=StandardResponse[FoodResponse])
async def update_food(food_id: str, food: Food):
    return await _update_item("foods", food_id, food, FoodResponse)

@router.delete("/foods/{food_id}", response_model=StandardResponse[dict])
async def delete_food(food_id: str):
    return await _delete_item("foods", food_id)

# --------------------------
# --- Orders Endpoints ---
# --------------------------
@router.get("/orders", response_model=StandardResponse[List[OrderResponse]])
async def get_orders(store_id: Optional[str] = Query(None), status: Optional[str] = Query(None)):
    query = {}
    if store_id:
        query["store_id"] = store_id
    if status:
        query["status"] = status
    return await _get_all_items("orders", Order, query)

@router.get("/orders/{order_id}", response_model=StandardResponse[OrderResponse])
async def get_order(order_id: str):
    return await _get_item_by_id("orders", order_id, Order)

@router.post("/orders", response_model=StandardResponse[OrderResponse])
async def create_order(order: Order):
    try:
        orders_collection = get_collection("orders")
        inventory_collection = get_collection("inventory_products")
        
        order_dict = to_mongo_dict(order)
        
        # Check inventory and deduct quantities
        stock_warnings = []
        for item in order.items:
            foods_collection = get_collection("foods")
            food = await foods_collection.find_one({"_id": ObjectId(item.food_id)})
            
            if food and food.get("recipes"):
                for recipe in food["recipes"]:
                    inventory_product = await inventory_collection.find_one(
                        {"_id": ObjectId(recipe["inventory_product_id"])}
                    )
                    if inventory_product:
                        required_quantity = recipe["quantity_used"] * item.quantity
                        if inventory_product["quantity_in_stock"] < required_quantity:
                            stock_warnings.append(
                                f"Low stock warning: {inventory_product['name']} "
                                f"(required: {required_quantity}, available: {inventory_product['quantity_in_stock']})"
                            )
                        
                        # Deduct from inventory
                        new_stock = inventory_product["quantity_in_stock"] - required_quantity
                        await inventory_collection.update_one(
                            {"_id": ObjectId(recipe["inventory_product_id"])},
                            {"$set": {"quantity_in_stock": max(0, new_stock)}}
                        )
        
        result = await orders_collection.insert_one(order_dict)
        new_order = await orders_collection.find_one({"_id": result.inserted_id})
        order_response = Order.from_mongo(new_order)
        
        # Add stock warnings to response if any
        if stock_warnings:
            order_response.stock_warnings = stock_warnings
        
        return success_response(
            data=OrderResponse.model_validate(order_response.model_dump()),
            message="Order created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/orders/{order_id}", response_model=StandardResponse[OrderResponse])
async def update_order(order_id: str, order: Order):
    return await _update_item("orders", order_id, order, OrderResponse)

@router.delete("/orders/{order_id}", response_model=StandardResponse[dict])
async def delete_order(order_id: str):
    return await _delete_item("orders", order_id)

# --------------------------
# --- Categories Endpoints ---
# --------------------------
@router.get("/categories", response_model=StandardResponse[List[CategoryResponse]])
async def get_categories(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("categories", Category, query)

@router.get("/categories/{category_id}", response_model=StandardResponse[CategoryResponse])
async def get_category(category_id: str):
    return await _get_item_by_id("categories", category_id, Category)

@router.post("/categories", response_model=StandardResponse[CategoryResponse])
async def create_category(category: Category):
    return await _create_item("categories", category, CategoryResponse)

@router.put("/categories/{category_id}", response_model=StandardResponse[CategoryResponse])
async def update_category(category_id: str, category: Category):
    return await _update_item("categories", category_id, category, CategoryResponse)

@router.delete("/categories/{category_id}", response_model=StandardResponse[dict])
async def delete_category(category_id: str):
    return await _delete_item("categories", category_id)

# --------------------------
# --- Customers Endpoints ---
# --------------------------
@router.get("/customers", response_model=StandardResponse[List[CustomerResponse]])
async def get_customers(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("customers", Customer, query)

@router.get("/customers/{customer_id}", response_model=StandardResponse[CustomerResponse])
async def get_customer(customer_id: str):
    return await _get_item_by_id("customers", customer_id, Customer)

@router.post("/customers", response_model=StandardResponse[CustomerResponse])
async def create_customer(customer: Customer):
    return await _create_item("customers", customer, CustomerResponse)

@router.put("/customers/{customer_id}", response_model=StandardResponse[CustomerResponse])
async def update_customer(customer_id: str, customer: Customer):
    return await _update_item("customers", customer_id, customer, CustomerResponse)

@router.delete("/customers/{customer_id}", response_model=StandardResponse[dict])
async def delete_customer(customer_id: str):
    return await _delete_item("customers", customer_id)

# --------------------------
# --- Tables Endpoints ---
# --------------------------
@router.get("/tables", response_model=StandardResponse[List[TableResponse]])
async def get_tables(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("tables", Table, query)

@router.get("/tables/{table_id}", response_model=StandardResponse[TableResponse])
async def get_table(table_id: str):
    return await _get_item_by_id("tables", table_id, Table)

@router.post("/tables", response_model=StandardResponse[TableResponse])
async def create_table(table: Table):
    return await _create_item("tables", table, TableResponse)

@router.put("/tables/{table_id}", response_model=StandardResponse[TableResponse])
async def update_table(table_id: str, table: Table):
    return await _update_item("tables", table_id, table, TableResponse)

@router.delete("/tables/{table_id}", response_model=StandardResponse[dict])
async def delete_table(table_id: str):
    return await _delete_item("tables", table_id)

# --------------------------
# --- Stores Endpoints ---
# --------------------------
@router.get("/stores", response_model=StandardResponse[List[StoreResponse]])
async def get_stores():
    return await _get_all_items("stores", Store)

@router.get("/stores/{store_id}", response_model=StandardResponse[StoreResponse])
async def get_store(store_id: str):
    return await _get_item_by_id("stores", store_id, Store)

@router.post("/stores", response_model=StandardResponse[StoreResponse])
async def create_store(store: Store):
    return await _create_item("stores", store, StoreResponse)

@router.put("/stores/{store_id}", response_model=StandardResponse[StoreResponse])
async def update_store(store_id: str, store: Store):
    return await _update_item("stores", store_id, store, StoreResponse)

@router.delete("/stores/{store_id}", response_model=StandardResponse[dict])
async def delete_store(store_id: str):
    return await _delete_item("stores", store_id)

# --------------------------
# --- Purchase Orders Endpoints ---
# --------------------------
@router.get("/purchase_orders", response_model=StandardResponse[List[PurchaseOrderResponse]])
async def get_purchase_orders():
    return await _get_all_items("purchase_orders", PurchaseOrder)

@router.get("/purchase_orders/{po_id}", response_model=StandardResponse[PurchaseOrderResponse])
async def get_purchase_order(po_id: str):
    return await _get_item_by_id("purchase_orders", po_id, PurchaseOrder)

@router.post("/purchase_orders", response_model=StandardResponse[PurchaseOrderResponse])
async def create_purchase_order(po: PurchaseOrder):
    return await _create_item("purchase_orders", po, PurchaseOrderResponse)

@router.put("/purchase_orders/{po_id}", response_model=StandardResponse[PurchaseOrderResponse])
async def update_purchase_order(po_id: str, po: PurchaseOrder):
    return await _update_item("purchase_orders", po_id, po, PurchaseOrderResponse)

@router.delete("/purchase_orders/{po_id}", response_model=StandardResponse[dict])
async def delete_purchase_order(po_id: str):
    return await _delete_item("purchase_orders", po_id)

# --------------------------
# --- Goods Receipts Endpoints ---
# --------------------------
@router.get("/goods_receipts", response_model=StandardResponse[List[GoodsReceiptResponse]])
async def get_goods_receipts():
    return await _get_all_items("goods_receipts", GoodsReceipt)

@router.get("/goods_receipts/{gr_id}", response_model=StandardResponse[GoodsReceiptResponse])
async def get_goods_receipt(gr_id: str):
    return await _get_item_by_id("goods_receipts", gr_id, GoodsReceipt)

@router.post("/goods_receipts", response_model=StandardResponse[GoodsReceiptResponse])
async def create_goods_receipt(gr: GoodsReceipt):
    try:
        gr_collection = get_collection("goods_receipts")
        products_collection = get_collection("inventory_products")

        # Update inventory quantities based on received items
        for item in gr.items:
            if item.condition == 'good':
                product = await products_collection.find_one({"_id": ObjectId(item.inventory_product_id)})
                if not product:
                    return error_response(message=f"Inventory Product with id {item.inventory_product_id} not found.", code=404)
                
                current_stock = product.get("quantity_in_stock", 0)
                new_stock = current_stock + item.received_quantity
                
                await products_collection.update_one(
                    {"_id": ObjectId(item.inventory_product_id)},
                    {"$set": {"quantity_in_stock": new_stock, "last_restocked_at": datetime.utcnow().isoformat()}}
                )

        # Insert the goods receipt
        gr_dict = to_mongo_dict(gr)
        
        result = await gr_collection.insert_one(gr_dict)
        new_gr = await gr_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=GoodsReceipt.from_mongo(new_gr),
            message="Goods receipt created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/goods_receipts/{gr_id}", response_model=StandardResponse[GoodsReceiptResponse])
async def update_goods_receipt(gr_id: str, gr: GoodsReceipt):
    return await _update_item("goods_receipts", gr_id, gr, GoodsReceiptResponse)

@router.delete("/goods_receipts/{gr_id}", response_model=StandardResponse[dict])
async def delete_goods_receipt(gr_id: str):
    return await _delete_item("goods_receipts", gr_id)

# --------------------------
# --- Reservations Endpoints ---
# --------------------------
@router.get("/reservations", response_model=StandardResponse[List[ReservationResponse]])
async def get_reservations(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("reservations", Reservation, query)

@router.get("/reservations/{reservation_id}", response_model=StandardResponse[ReservationResponse])
async def get_reservation(reservation_id: str):
    return await _get_item_by_id("reservations", reservation_id, Reservation)

@router.post("/reservations", response_model=StandardResponse[ReservationResponse])
async def create_reservation(reservation: Reservation):
    return await _create_item("reservations", reservation, ReservationResponse)

@router.put("/reservations/{reservation_id}", response_model=StandardResponse[ReservationResponse])
async def update_reservation(reservation_id: str, reservation: Reservation):
    return await _update_item("reservations", reservation_id, reservation, ReservationResponse)

@router.delete("/reservations/{reservation_id}", response_model=StandardResponse[dict])
async def delete_reservation(reservation_id: str):
    return await _delete_item("reservations", reservation_id)

# ----------------------------------------------------
# --- NEW CRUD Endpoints for Missing Core Models ---
# ----------------------------------------------------

# Brands Endpoints
@router.get("/brands", response_model=StandardResponse[List[BrandResponse]])
async def get_brands():
    return await _get_all_items("brands", Brand)

@router.get("/brands/{brand_id}", response_model=StandardResponse[BrandResponse])
async def get_brand(brand_id: str):
    return await _get_item_by_id("brands", brand_id, Brand)

@router.post("/brands", response_model=StandardResponse[BrandResponse])
async def create_brand(brand: Brand):
    return await _create_item("brands", brand, BrandResponse)

@router.put("/brands/{brand_id}", response_model=StandardResponse[BrandResponse])
async def update_brand(brand_id: str, brand: Brand):
    return await _update_item("brands", brand_id, brand, BrandResponse)

@router.delete("/brands/{brand_id}", response_model=StandardResponse[dict])
async def delete_brand(brand_id: str):
    return await _delete_item("brands", brand_id)

# Contact Messages Endpoints
@router.get("/contact_messages", response_model=StandardResponse[List[ContactMessageResponse]])
async def get_contact_messages():
    return await _get_all_items("contact_messages", ContactMessage)

@router.get("/contact_messages/{message_id}", response_model=StandardResponse[ContactMessageResponse])
async def get_contact_message(message_id: str):
    return await _get_item_by_id("contact_messages", message_id, ContactMessage)

@router.post("/contact_messages", response_model=StandardResponse[ContactMessageResponse])
async def create_contact_message(message: ContactMessage):
    return await _create_item("contact_messages", message, ContactMessageResponse)

@router.delete("/contact_messages/{message_id}", response_model=StandardResponse[dict])
async def delete_contact_message(message_id: str):
    return await _delete_item("contact_messages", message_id)

# Domains Endpoints
@router.get("/domains", response_model=StandardResponse[List[DomainResponse]])
async def get_domains(tenant_id: Optional[str] = Query(None)):
    query = {"tenant_id": tenant_id} if tenant_id else {}
    return await _get_all_items("domains", Domain, query)

@router.get("/domains/{domain_id}", response_model=StandardResponse[DomainResponse])
async def get_domain(domain_id: str):
    return await _get_item_by_id("domains", domain_id, Domain)

@router.post("/domains", response_model=StandardResponse[DomainResponse])
async def create_domain(domain: Domain):
    return await _create_item("domains", domain, DomainResponse)

@router.put("/domains/{domain_id}", response_model=StandardResponse[DomainResponse])
async def update_domain(domain_id: str, domain: Domain):
    return await _update_item("domains", domain_id, domain, DomainResponse)

@router.delete("/domains/{domain_id}", response_model=StandardResponse[dict])
async def delete_domain(domain_id: str):
    return await _delete_item("domains", domain_id)

# Payments Endpoints
@router.get("/payments", response_model=StandardResponse[List[PaymentResponse]])
async def get_payments(order_id: Optional[str] = Query(None)):
    query = {"order_id": order_id} if order_id else {}
    return await _get_all_items("payments", Payment, query)

@router.get("/payments/{payment_id}", response_model=StandardResponse[PaymentResponse])
async def get_payment(payment_id: str):
    return await _get_item_by_id("payments", payment_id, Payment)

@router.post("/payments", response_model=StandardResponse[PaymentResponse])
async def create_payment(payment: Payment):
    return await _create_item("payments", payment, PaymentResponse)

@router.put("/payments/{payment_id}", response_model=StandardResponse[PaymentResponse])
async def update_payment(payment_id: str, payment: Payment):
    return await _update_item("payments", payment_id, payment, PaymentResponse)

@router.delete("/payments/{payment_id}", response_model=StandardResponse[dict])
async def delete_payment(payment_id: str):
    return await _delete_item("payments", payment_id)

# Payment Methods Endpoints
@router.get("/payment_methods", response_model=StandardResponse[List[PaymentMethodResponse]])
async def get_payment_methods(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("payment_methods", PaymentMethod, query)

@router.get("/payment_methods/{method_id}", response_model=StandardResponse[PaymentMethodResponse])
async def get_payment_method(method_id: str):
    return await _get_item_by_id("payment_methods", method_id, PaymentMethod)

@router.post("/payment_methods", response_model=StandardResponse[PaymentMethodResponse])
async def create_payment_method(method: PaymentMethod):
    return await _create_item("payment_methods", method, PaymentMethodResponse)

@router.put("/payment_methods/{method_id}", response_model=StandardResponse[PaymentMethodResponse])
async def update_payment_method(method_id: str, method: PaymentMethod):
    return await _update_item("payment_methods", method_id, method, PaymentMethodResponse)

@router.delete("/payment_methods/{method_id}", response_model=StandardResponse[dict])
async def delete_payment_method(method_id: str):
    return await _delete_item("payment_methods", method_id)

# Sites Endpoints
@router.get("/sites", response_model=StandardResponse[List[SiteResponse]])
async def get_sites(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("sites", Site, query)

@router.get("/sites/{site_id}", response_model=StandardResponse[SiteResponse])
async def get_site(site_id: str):
    return await _get_item_by_id("sites", site_id, Site)

@router.post("/sites", response_model=StandardResponse[SiteResponse])
async def create_site(site: Site):
    return await _create_item("sites", site, SiteResponse)

@router.put("/sites/{site_id}", response_model=StandardResponse[SiteResponse])
async def update_site(site_id: str, site: Site):
    return await _update_item("sites", site_id, site, SiteResponse)

@router.delete("/sites/{site_id}", response_model=StandardResponse[dict])
async def delete_site(site_id: str):
    return await _delete_item("sites", site_id)

# Taxes Endpoints
@router.get("/taxes", response_model=StandardResponse[List[TaxResponse]])
async def get_taxes(store_id: Optional[str] = Query(None)):
    query = {"store_id": store_id} if store_id else {}
    return await _get_all_items("taxes", Tax, query)

@router.get("/taxes/{tax_id}", response_model=StandardResponse[TaxResponse])
async def get_tax(tax_id: str):
    return await _get_item_by_id("taxes", tax_id, Tax)

@router.post("/taxes", response_model=StandardResponse[TaxResponse])
async def create_tax(tax: Tax):
    return await _create_item("taxes", tax, TaxResponse)

@router.put("/taxes/{tax_id}", response_model=StandardResponse[TaxResponse])
async def update_tax(tax_id: str, tax: Tax):
    return await _update_item("taxes", tax_id, tax, TaxResponse)

@router.delete("/taxes/{tax_id}", response_model=StandardResponse[dict])
async def delete_tax(tax_id: str):
    return await _delete_item("taxes", tax_id)

# Tenants Endpoints
@router.get("/tenants", response_model=StandardResponse[List[TenantResponse]])
async def get_tenants():
    return await _get_all_items("tenants", Tenant)

@router.get("/tenants/{tenant_id}", response_model=StandardResponse[TenantResponse])
async def get_tenant(tenant_id: str):
    return await _get_item_by_id("tenants", tenant_id, Tenant)

@router.post("/tenants", response_model=StandardResponse[TenantResponse])
async def create_tenant(tenant: Tenant):
    return await _create_item("tenants", tenant, TenantResponse)

@router.put("/tenants/{tenant_id}", response_model=StandardResponse[TenantResponse])
async def update_tenant(tenant_id: str, tenant: Tenant):
    return await _update_item("tenants", tenant_id, tenant, TenantResponse)

@router.delete("/tenants/{tenant_id}", response_model=StandardResponse[dict])
async def delete_tenant(tenant_id: str):
    return await _delete_item("tenants", tenant_id)

# ----------------------------------------------------
# --- Utility Endpoints (From Original File) ---
# ----------------------------------------------------

# Low stock items endpoint
@router.get("/inventory/low-stock", response_model=StandardResponse[List[InventoryProductResponse]])
async def get_low_stock_items():
    try:
        products_collection = get_collection("inventory_products")
        low_stock_items = []
        products = await products_collection.find()
        for product in products:
            if product.get("quantity_in_stock", 0) <= product.get("reorder_level", 0):
                low_stock_items.append(InventoryProduct.from_mongo(product))
        return success_response(data=low_stock_items)
    except Exception as e:
        return handle_generic_exception(e)

# Pending purchase orders endpoint
@router.get("/purchase_orders/pending", response_model=StandardResponse[List[PurchaseOrderResponse]])
async def get_pending_purchase_orders():
    try:
        po_collection = get_collection("purchase_orders")
        pending_statuses = ['draft', 'pending-approval', 'approved', 'ordered']
        pending_orders = []
        pos = await po_collection.find({"status": {"$in": pending_statuses}})
        for po in pos:
            pending_orders.append(PurchaseOrder.from_mongo(po))
        return success_response(data=pending_orders)
    except Exception as e:
        return handle_generic_exception(e)

# Order items endpoints (for individual order item operations)
@router.get("/order_items/{order_item_id}", response_model=StandardResponse[dict])
async def get_order_item(order_item_id: str):
    try:
        orders_collection = get_collection("orders")
        orders = await orders_collection.find()
        for order in orders:
            for item in order.get("items", []):
                if str(item.get("id")) == order_item_id:
                    return success_response(data=item)
        return error_response(message="Order item not found", code=404)
    except Exception as e:
        return handle_generic_exception(e)

# Store foods endpoints
@router.get("/store_foods", response_model=StandardResponse[List[dict]])
async def get_store_foods(store_id: Optional[str] = Query(None)):
    try:
        foods_collection = get_collection("foods")
        query = {"store_id": store_id} if store_id else {}
        store_foods = []
        foods = await foods_collection.find(query)
        for food in foods:
            store_foods.append({
                "food_id": str(food["_id"]),
                "store_id": food.get("store_id", ""),
                "is_available": food.get("is_available", True)
            })
        return success_response(data=store_foods)
    except Exception as e:
        return handle_generic_exception(e)

# Recipe items endpoints
@router.get("/recipes", response_model=StandardResponse[List[dict]])
async def get_recipes(food_id: Optional[str] = Query(None)):
    try:
        foods_collection = get_collection("foods")
        recipes = []
        foods = await foods_collection.find()
        for food in foods:
            if food.get("recipes"):
                for recipe in food["recipes"]:
                    if not food_id or str(food["_id"]) == food_id:
                        recipes.append({
                            **recipe,
                            "food_id": str(food["_id"]),
                            "id": recipe.get("id", str(food["_id"]) + "_" + recipe.get("inventory_product_id", ""))
                        })
        return success_response(data=recipes)
    except Exception as e:
        return handle_generic_exception(e)

# Health check endpoint for core module
@router.get("/health")
async def health_check():
    return success_response(data={"status": "healthy", "module": "core"})

# --------------------------
# --- Users Endpoints ---
# --------------------------
@router.get("/users", response_model=StandardResponse[List[UserResponse]])
async def get_users():
    """Retrieve all users (without passwords)."""
    try:
        users_collection = get_collection("users")
        users = []
        user_docs = await users_collection.find()
        for user in user_docs:
            # Convert to User model first
            user_model = User.from_mongo(user)
            user_dict = user_model.to_dict()
            user_dict.pop('password', None)  # Remove password
            
            users.append(user_dict)
        
        return success_response(data=users)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/users/{user_id}", response_model=StandardResponse[UserResponse])
async def get_user(user_id: str):
    """Retrieve a single user by ID (without password)."""
    try:
        users_collection = get_collection("users")
        user = await users_collection.find_one({"_id": ObjectId(user_id)})
        if user:
            # Convert to User model first
            user_model = User.from_mongo(user)
            user_dict = user_model.to_dict()
            user_dict.pop('password', None)  # Remove password
            
            return success_response(data=user_dict)
        return error_response(message="User not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for user", code=400)

@router.post("/users", response_model=StandardResponse[UserResponse])
async def create_user(user: User):
    """Create a new user."""
    try:
        users_collection = get_collection("users")
        user_dict = to_mongo_dict(user)
        
        result = await users_collection.insert_one(user_dict)
        new_user = await users_collection.find_one({"_id": result.inserted_id})
        
        # Remove password from response
        user_data = User.from_mongo(new_user)
        user_dict = user_data.to_dict()
        user_dict.pop("password", None)
        
        return success_response(
            data=user_dict,
            message="User created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/users/{user_id}", response_model=StandardResponse[UserResponse])
async def update_user(user_id: str, user: User):
    """Update an existing user."""
    try:
        users_collection = get_collection("users")
        user_dict = to_mongo_update_dict(user, exclude_unset=True)
        
        result = await users_collection.update_one(
            {"_id": ObjectId(user_id)}, {"$set": user_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="User not found", code=404)
            
        updated_user = await users_collection.find_one({"_id": ObjectId(user_id)})
        
        # Remove password from response
        user_data = User.from_mongo(updated_user)
        user_dict = user_data.to_dict()
        user_dict.pop("password", None)
        
        return success_response(
            data=user_dict,
            message="User updated successfully"
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.delete("/users/{user_id}", response_model=StandardResponse[dict])
async def delete_user(user_id: str):
    """Delete a user."""
    return await _delete_item("users", user_id)

# --------------------------
# --- Reports Endpoints ---
# --------------------------
@router.get("/reports", response_model=StandardResponse[List[ReportResponse]])
async def get_reports():
    return await _get_all_items("reports", Report)

@router.get("/reports/{report_id}", response_model=StandardResponse[ReportResponse])
async def get_report(report_id: str):
    return await _get_item_by_id("reports", report_id, Report)

@router.post("/reports", response_model=StandardResponse[ReportResponse])
async def create_report(report: Report):
    return await _create_item("reports", report, ReportResponse)

@router.delete("/reports/{report_id}", response_model=StandardResponse[dict])
async def delete_report(report_id: str):
    return await _delete_item("reports", report_id)

# --------------------------
# --- Password Resets Endpoints ---
# --------------------------
@router.get("/password_resets", response_model=StandardResponse[List[PasswordResetResponse]])
async def get_password_resets():
    return await _get_all_items("password_resets", PasswordReset)

@router.get("/password_resets/{reset_id}", response_model=StandardResponse[PasswordResetResponse])
async def get_password_reset(reset_id: str):
    return await _get_item_by_id("password_resets", reset_id, PasswordReset)

@router.post("/password_resets", response_model=StandardResponse[PasswordResetResponse])
async def create_password_reset(reset: PasswordReset):
    return await _create_item("password_resets", reset, PasswordResetResponse)

@router.delete("/password_resets/{reset_id}", response_model=StandardResponse[dict])
async def delete_password_reset(reset_id: str):
    return await _delete_item("password_resets", reset_id)

# --------------------------
# --- Jobs Endpoints ---
# --------------------------
@router.get("/jobs", response_model=StandardResponse[List[JobResponse]])
async def get_jobs():
    return await _get_all_items("jobs", Job)

@router.get("/jobs/{job_id}", response_model=StandardResponse[JobResponse])
async def get_job(job_id: str):
    return await _get_item_by_id("jobs", job_id, Job)

@router.post("/jobs", response_model=StandardResponse[JobResponse])
async def create_job(job: Job):
    return await _create_item("jobs", job, JobResponse)

@router.delete("/jobs/{job_id}", response_model=StandardResponse[dict])
async def delete_job(job_id: str):
    return await _delete_item("jobs", job_id)

# --------------------------
# --- Failed Jobs Endpoints ---
# --------------------------
@router.get("/failed_jobs", response_model=StandardResponse[List[FailedJobResponse]])
async def get_failed_jobs():
    return await _get_all_items("failed_jobs", FailedJob)

@router.get("/failed_jobs/{job_id}", response_model=StandardResponse[FailedJobResponse])
async def get_failed_job(job_id: str):
    return await _get_item_by_id("failed_jobs", job_id, FailedJob)

@router.post("/failed_jobs", response_model=StandardResponse[FailedJobResponse])
async def create_failed_job(job: FailedJob):
    return await _create_item("failed_jobs", job, FailedJobResponse)

@router.delete("/failed_jobs/{job_id}", response_model=StandardResponse[dict])
async def delete_failed_job(job_id: str):
    return await _delete_item("failed_jobs", job_id)

=== HR ROUTES ===
# app/routes/hr.py - COMPLETELY UPDATED
from fastapi import APIRouter, HTTPException, Query, status
from typing import List, Optional
from app.database import get_collection
from app.models.hr import Employee, Shift, TimesheetEntry, Payroll, AccessRole, JobTitle, PayrollSettings, Timesheet, Department
from app.models.response import (
    StandardResponse, EmployeeResponse, ShiftResponse, TimesheetEntryResponse, PayrollResponse, 
    AccessRoleResponse, JobTitleResponse, PayrollSettingsResponse, TimesheetResponse,
    DepartmentResponse
)
from app.utils.response_helpers import success_response, error_response, handle_http_exception, handle_generic_exception
from app.utils.mongo_helpers import to_mongo_dict, to_mongo_update_dict
from bson import ObjectId
from datetime import datetime, timedelta
import asyncio

router = APIRouter(prefix="/api", tags=["hr"])

# -----------------
# Department endpoints
# -----------------
@router.get("/departments", response_model=StandardResponse[List[DepartmentResponse]])
async def get_departments(store_id: Optional[str] = Query(None)):
    """Retrieve a list of departments, optionally filtered by store_id."""
    try:
        departments_collection = get_collection("departments")
        query = {"store_id": store_id} if store_id else {}
        departments = []
        # FIXED: Use await and iterate
        dept_docs = await departments_collection.find(query)
        for department in dept_docs:
            departments.append(Department.from_mongo(department))
        return success_response(data=departments)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/departments/{department_id}", response_model=StandardResponse[DepartmentResponse])
async def get_department(department_id: str):
    """Retrieve a single department by ID."""
    try:
        departments_collection = get_collection("departments")
        department = await departments_collection.find_one({"_id": ObjectId(department_id)})
        if department:
            return success_response(data=Department.from_mongo(department))
        return error_response(message="Department not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for department", code=400)

@router.post("/departments", response_model=StandardResponse[DepartmentResponse])
async def create_department(department: Department):
    """Create a new department."""
    try:
        departments_collection = get_collection("departments")
        department_dict = to_mongo_dict(department)
        
        result = await departments_collection.insert_one(department_dict)
        new_department = await departments_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Department.from_mongo(new_department),
            message="Department created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/departments/{department_id}", response_model=StandardResponse[DepartmentResponse])
async def update_department(department_id: str, department: Department):
    """Update an existing department."""
    try:
        departments_collection = get_collection("departments")
        department_dict = to_mongo_update_dict(department, exclude_unset=True)
        
        result = await departments_collection.update_one(
            {"_id": ObjectId(department_id)}, {"$set": department_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Department not found", code=404)
        
        updated_department = await departments_collection.find_one({"_id": ObjectId(department_id)})
        return success_response(
            data=Department.from_mongo(updated_department),
            message="Department updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for department", code=400)

@router.delete("/departments/{department_id}", response_model=StandardResponse[dict])
async def delete_department(department_id: str):
    """Delete a department."""
    try:
        departments_collection = get_collection("departments")
        result = await departments_collection.delete_one({"_id": ObjectId(department_id)})
        if result.deleted_count == 0:
            return error_response(message="Department not found", code=404)
        return success_response(
            data=None,
            message="Department deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for department", code=400)

# -----------------
# Employees endpoints
# -----------------
@router.get("/employees", response_model=StandardResponse[List[EmployeeResponse]])
async def get_employees(store_id: Optional[str] = Query(None)):
    """Retrieve a list of employees, optionally filtered by store_id."""
    try:
        employees_collection = get_collection("employees")
        query = {"store_id": store_id} if store_id else {}
        employees = []
        # FIXED: Use await and iterate
        employee_docs = await employees_collection.find(query)
        for employee in employee_docs:
            employees.append(Employee.from_mongo(employee))
        return success_response(data=employees)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/employees/{employee_id}", response_model=StandardResponse[EmployeeResponse])
async def get_employee(employee_id: str):
    """Retrieve a single employee by ID."""
    try:
        employees_collection = get_collection("employees")
        employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
        if employee:
            return success_response(data=Employee.from_mongo(employee))
        return error_response(message="Employee not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for employee", code=400)

@router.post("/employees", response_model=StandardResponse[EmployeeResponse])
async def create_employee(employee: Employee):
    """Create a new employee record."""
    try:
        employees_collection = get_collection("employees")
        employee_dict = to_mongo_dict(employee)
        
        result = await employees_collection.insert_one(employee_dict)
        new_employee = await employees_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Employee.from_mongo(new_employee),
            message="Employee created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/employees/{employee_id}", response_model=StandardResponse[EmployeeResponse])
async def update_employee(employee_id: str, employee: Employee):
    """Update an existing employee record by ID."""
    try:
        employees_collection = get_collection("employees")
        employee_dict = to_mongo_update_dict(employee, exclude_unset=True)
        
        result = await employees_collection.update_one(
            {"_id": ObjectId(employee_id)}, {"$set": employee_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Employee not found", code=404)
        
        updated_employee = await employees_collection.find_one({"_id": ObjectId(employee_id)})
        return success_response(
            data=Employee.from_mongo(updated_employee),
            message="Employee updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for employee", code=400)

@router.delete("/employees/{employee_id}", response_model=StandardResponse[dict])
async def delete_employee(employee_id: str):
    """Delete an employee record by ID."""
    try:
        employees_collection = get_collection("employees")
        result = await employees_collection.delete_one({"_id": ObjectId(employee_id)})
        if result.deleted_count == 0:
            return error_response(message="Employee not found", code=404)
        return success_response(
            data=None,
            message="Employee deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for employee", code=400)

# -----------------
# Access Roles endpoints
# -----------------
@router.get("/access_roles", response_model=StandardResponse[List[AccessRoleResponse]])
async def get_access_roles():
    """Retrieve all defined access roles."""
    try:
        access_roles_collection = get_collection("access_roles")
        roles = []
        # FIXED: Use await and iterate
        role_docs = await access_roles_collection.find()
        for role in role_docs:
            roles.append(AccessRole.from_mongo(role))
        return success_response(data=roles)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/access_roles/{role_id}", response_model=StandardResponse[AccessRoleResponse])
async def get_access_role(role_id: str):
    """Retrieve a single access role by ID."""
    try:
        access_roles_collection = get_collection("access_roles")
        role = await access_roles_collection.find_one({"_id": ObjectId(role_id)})
        if role:
            return success_response(data=AccessRole.from_mongo(role))
        return error_response(message="Access role not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for access role", code=400)

@router.post("/access_roles", response_model=StandardResponse[AccessRoleResponse])
async def create_access_role(role: AccessRole):
    """Create a new access role."""
    try:
        access_roles_collection = get_collection("access_roles")
        role_dict = to_mongo_dict(role)
        
        result = await access_roles_collection.insert_one(role_dict)
        new_role = await access_roles_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=AccessRole.from_mongo(new_role),
            message="Access role created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/access_roles/{role_id}", response_model=StandardResponse[AccessRoleResponse])
async def update_access_role(role_id: str, role: AccessRole):
    """Update an existing access role by ID."""
    try:
        access_roles_collection = get_collection("access_roles")
        role_dict = to_mongo_update_dict(role, exclude_unset=True)
        
        result = await access_roles_collection.update_one(
            {"_id": ObjectId(role_id)}, {"$set": role_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Access role not found", code=404)
        
        updated_role = await access_roles_collection.find_one({"_id": ObjectId(role_id)})
        return success_response(
            data=AccessRole.from_mongo(updated_role),
            message="Access role updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for access role", code=400)

@router.delete("/access_roles/{role_id}", response_model=StandardResponse[dict])
async def delete_access_role(role_id: str):
    """Delete an access role by ID."""
    try:
        access_roles_collection = get_collection("access_roles")
        result = await access_roles_collection.delete_one({"_id": ObjectId(role_id)})
        if result.deleted_count == 0:
            return error_response(message="Access role not found", code=404)
        return success_response(
            data=None,
            message="Access role deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for access role", code=400)

# -----------------
# Job Titles endpoints
# -----------------
@router.get("/job_titles", response_model=StandardResponse[List[JobTitleResponse]])
async def get_job_titles(store_id: Optional[str] = Query(None)):
    """Retrieve a list of job titles, optionally filtered by store_id."""
    try:
        job_titles_collection = get_collection("job_titles")
        query = {"store_id": store_id} if store_id else {}
        titles = []
        # FIXED: Use await and iterate
        title_docs = await job_titles_collection.find(query)
        for title in title_docs:
            titles.append(JobTitle.from_mongo(title))
        return success_response(data=titles)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/job_titles/{title_id}", response_model=StandardResponse[JobTitleResponse])
async def get_job_title(title_id: str):
    """Retrieve a single job title by ID."""
    try:
        job_titles_collection = get_collection("job_titles")
        title = await job_titles_collection.find_one({"_id": ObjectId(title_id)})
        if title:
            return success_response(data=JobTitle.from_mongo(title))
        return error_response(message="Job title not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for job title", code=400)

@router.post("/job_titles", response_model=StandardResponse[JobTitleResponse])
async def create_job_title(title: JobTitle):
    """Create a new job title."""
    try:
        job_titles_collection = get_collection("job_titles")
        title_dict = to_mongo_dict(title)
        
        result = await job_titles_collection.insert_one(title_dict)
        new_title = await job_titles_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=JobTitle.from_mongo(new_title),
            message="Job title created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/job_titles/{title_id}", response_model=StandardResponse[JobTitleResponse])
async def update_job_title(title_id: str, title: JobTitle):
    """Update an existing job title by ID."""
    try:
        job_titles_collection = get_collection("job_titles")
        title_dict = to_mongo_update_dict(title, exclude_unset=True)
        
        result = await job_titles_collection.update_one(
            {"_id": ObjectId(title_id)}, {"$set": title_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Job title not found", code=404)
        
        updated_title = await job_titles_collection.find_one({"_id": ObjectId(title_id)})
        return success_response(
            data=JobTitle.from_mongo(updated_title),
            message="Job title updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for job title", code=400)

@router.delete("/job_titles/{title_id}", response_model=StandardResponse[dict])
async def delete_job_title(title_id: str):
    """Delete a job title by ID."""
    try:
        job_titles_collection = get_collection("job_titles")
        result = await job_titles_collection.delete_one({"_id": ObjectId(title_id)})
        if result.deleted_count == 0:
            return error_response(message="Job title not found", code=404)
        return success_response(
            data=None,
            message="Job title deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for job title", code=400)

# -----------------
# Shifts endpoints
# -----------------
@router.get("/shifts", response_model=StandardResponse[List[ShiftResponse]])
async def get_shifts(employee_id: Optional[str] = Query(None), active: Optional[bool] = Query(None)):
    """Retrieve a list of shifts, optionally filtered by employee_id or active status."""
    try:
        shifts_collection = get_collection("shifts")
        query = {}
        if employee_id:
            query["employee_id"] = employee_id
        if active is not None:
            query["active"] = active
            
        shifts = []
        # FIXED: Use await and iterate
        shift_docs = await shifts_collection.find(query)
        for shift in shift_docs:
            shifts.append(Shift.from_mongo(shift))
        return success_response(data=shifts)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/shifts/{shift_id}", response_model=StandardResponse[ShiftResponse])
async def get_shift(shift_id: str):
    """Retrieve a single shift by ID."""
    try:
        shifts_collection = get_collection("shifts")
        shift = await shifts_collection.find_one({"_id": ObjectId(shift_id)})
        if shift:
            return success_response(data=Shift.from_mongo(shift))
        return error_response(message="Shift not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for shift", code=400)

@router.post("/shifts", response_model=StandardResponse[ShiftResponse])
async def create_shift(shift: Shift):
    """Create a new shift."""
    try:
        shifts_collection = get_collection("shifts")
        shift_dict = to_mongo_dict(shift)
        
        result = await shifts_collection.insert_one(shift_dict)
        new_shift = await shifts_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Shift.from_mongo(new_shift),
            message="Shift created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/shifts/{shift_id}", response_model=StandardResponse[ShiftResponse])
async def update_shift(shift_id: str, shift: Shift):
    """Update an existing shift by ID."""
    try:
        shifts_collection = get_collection("shifts")
        shift_dict = to_mongo_update_dict(shift, exclude_unset=True)
        
        result = await shifts_collection.update_one(
            {"_id": ObjectId(shift_id)}, {"$set": shift_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Shift not found", code=404)
        
        updated_shift = await shifts_collection.find_one({"_id": ObjectId(shift_id)})
        return success_response(
            data=Shift.from_mongo(updated_shift),
            message="Shift updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for shift", code=400)

@router.put("/shifts/{shift_id}/status", response_model=StandardResponse[ShiftResponse])
async def update_shift_status(shift_id: str, active: bool):
    """Update the active status of a shift by ID."""
    try:
        shifts_collection = get_collection("shifts")
        result = await shifts_collection.update_one(
            {"_id": ObjectId(shift_id)}, 
            {"$set": {"active": active, "updated_at": datetime.utcnow().isoformat()}}
        )
        if result.modified_count == 0:
            return error_response(message="Shift not found", code=404)
        
        updated_shift = await shifts_collection.find_one({"_id": ObjectId(shift_id)})
        return success_response(
            data=Shift.from_mongo(updated_shift),
            message="Shift status updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for shift", code=400)

@router.delete("/shifts/{shift_id}", response_model=StandardResponse[dict])
async def delete_shift(shift_id: str):
    """Delete a shift by ID."""
    try:
        shifts_collection = get_collection("shifts")
        result = await shifts_collection.delete_one({"_id": ObjectId(shift_id)})
        if result.deleted_count == 0:
            return error_response(message="Shift not found", code=404)
        return success_response(
            data=None,
            message="Shift deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for shift", code=400)

# -----------------
# Timesheet Entries endpoints
# -----------------
@router.get("/timesheet_entries", response_model=StandardResponse[List[TimesheetEntryResponse]])
async def get_timesheet_entries(
    employee_id: Optional[str] = Query(None),
    date_from: Optional[str] = Query(None),
    date_to: Optional[str] = Query(None)
):
    """Retrieve timesheet entries, optionally filtered by employee_id or date range."""
    try:
        ts_collection = get_collection("timesheet_entries")
        query = {}
        if employee_id:
            query["employee_id"] = employee_id
        
        if date_from and date_to:
            try:
                start_dt = datetime.fromisoformat(date_from.replace('Z', '+00:00'))
                end_dt = datetime.fromisoformat(date_to.replace('Z', '+00:00'))
                query["clock_in"] = {
                    "$gte": start_dt.isoformat(),
                    "$lte": end_dt.isoformat()
                }
            except ValueError:
                return error_response(message="Invalid date format. Use ISO 8601 format.", code=400)
        
        entries = []
        # FIXED: Use await and iterate
        entry_docs = await ts_collection.find(query)
        for entry in entry_docs:
            entries.append(TimesheetEntry.from_mongo(entry))
        return success_response(data=entries)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/timesheet_entries/{entry_id}", response_model=StandardResponse[TimesheetEntryResponse])
async def get_timesheet_entry(entry_id: str):
    """Retrieve a single timesheet entry by ID."""
    try:
        ts_collection = get_collection("timesheet_entries")
        entry = await ts_collection.find_one({"_id": ObjectId(entry_id)})
        if entry:
            return success_response(data=TimesheetEntry.from_mongo(entry))
        return error_response(message="Timesheet entry not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for timesheet entry", code=400)

@router.post("/timesheet_entries", response_model=StandardResponse[TimesheetEntryResponse])
async def create_timesheet_entry(entry: TimesheetEntry):
    """Create a new timesheet entry."""
    try:
        ts_collection = get_collection("timesheet_entries")
        entry_dict = to_mongo_dict(entry)
        
        result = await ts_collection.insert_one(entry_dict)
        new_entry = await ts_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=TimesheetEntry.from_mongo(new_entry),
            message="Timesheet entry created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/timesheet_entries/{entry_id}", response_model=StandardResponse[TimesheetEntryResponse])
async def update_timesheet_entry(entry_id: str, entry: TimesheetEntry):
    """Update an existing timesheet entry by ID."""
    try:
        ts_collection = get_collection("timesheet_entries")
        entry_dict = to_mongo_update_dict(entry, exclude_unset=True)
        
        # Calculate duration if clock_out is provided
        if entry.clock_out and entry.clock_in:
            try:
                clock_in = datetime.fromisoformat(entry.clock_in.replace('Z', '+00:00'))
                clock_out = datetime.fromisoformat(entry.clock_out.replace('Z', '+00:00'))
                duration = int((clock_out - clock_in).total_seconds() / 60)
                entry_dict["duration_minutes"] = duration
            except (ValueError, TypeError):
                entry_dict["duration_minutes"] = 0
        
        result = await ts_collection.update_one(
            {"_id": ObjectId(entry_id)}, {"$set": entry_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Timesheet entry not found", code=404)
        
        updated_entry = await ts_collection.find_one({"_id": ObjectId(entry_id)})
        return success_response(
            data=TimesheetEntry.from_mongo(updated_entry),
            message="Timesheet entry updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for timesheet entry", code=400)

@router.delete("/timesheet_entries/{entry_id}", response_model=StandardResponse[dict])
async def delete_timesheet_entry(entry_id: str):
    """Delete a timesheet entry by ID."""
    try:
        ts_collection = get_collection("timesheet_entries")
        result = await ts_collection.delete_one({"_id": ObjectId(entry_id)})
        if result.deleted_count == 0:
            return error_response(message="Timesheet entry not found", code=404)
        return success_response(
            data=None,
            message="Timesheet entry deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for timesheet entry", code=400)

# Clock in/out endpoints
@router.post("/timesheet_entries/clock-in", response_model=StandardResponse[TimesheetEntryResponse])
async def clock_in(employee_id: str, store_id: str):
    """Records a clock-in event for an employee."""
    try:
        ts_collection = get_collection("timesheet_entries")
        
        # Check if employee already clocked in
        existing_entry = await ts_collection.find_one({
            "employee_id": employee_id,
            "clock_out": None
        })
        
        if existing_entry:
            return error_response(message="Employee is already clocked in", code=400)
        
        clock_in_time = datetime.utcnow().isoformat()
        entry_dict = {
            "employee_id": employee_id,
            "store_id": store_id,
            "clock_in": clock_in_time,
            "clock_out": None,
            "duration_minutes": 0,
            "created_at": clock_in_time,
            "updated_at": clock_in_time
        }
        
        result = await ts_collection.insert_one(entry_dict)
        new_entry = await ts_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=TimesheetEntry.from_mongo(new_entry),
            message="Clock in successful",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/timesheet_entries/{entry_id}/clock-out", response_model=StandardResponse[TimesheetEntryResponse])
async def clock_out(entry_id: str):
    """Records a clock-out event for an active timesheet entry."""
    try:
        ts_collection = get_collection("timesheet_entries")
        entry = await ts_collection.find_one({"_id": ObjectId(entry_id)})
        
        if not entry:
            return error_response(message="Timesheet entry not found", code=404)
            
        if entry.get("clock_out") is not None:
            return error_response(message="Timesheet entry is already clocked out", code=400)
        
        clock_out_time = datetime.utcnow().isoformat()
        clock_in_time = entry.get("clock_in")
        
        # Calculate duration
        duration = 0
        try:
            if isinstance(clock_in_time, str):
                clock_in_dt = datetime.fromisoformat(clock_in_time.replace('Z', '+00:00'))
            else:
                clock_in_dt = clock_in_time 
                
            clock_out_dt = datetime.utcnow()
            duration = int((clock_out_dt - clock_in_dt).total_seconds() / 60)
        except (ValueError, TypeError):
            duration = 0
    
        update_data = {
            "clock_out": clock_out_time,
            "duration_minutes": duration,
            "updated_at": datetime.utcnow().isoformat()
        }

        result = await ts_collection.update_one(
            {"_id": ObjectId(entry_id)},
            {"$set": update_data}
        )
        
        if result.modified_count == 0:
            return error_response(message="Timesheet entry not found or no changes made", code=404)
        
        updated_entry = await ts_collection.find_one({"_id": ObjectId(entry_id)})
        return success_response(
            data=TimesheetEntry.from_mongo(updated_entry),
            message="Clock out successful"
        )
    except Exception:
        return error_response(message="Invalid ID format for timesheet entry", code=400)

# -----------------
# Payroll endpoints
# -----------------
@router.get("/payroll", response_model=StandardResponse[List[PayrollResponse]])
async def get_payroll_entries(
    employee_id: Optional[str] = Query(None),
    status: Optional[str] = Query(None)
):
    """Retrieve payroll entries, optionally filtered by employee_id or status."""
    try:
        payroll_collection = get_collection("payroll")
        query = {}
        if employee_id:
            query["employee_id"] = employee_id
        if status:
            query["status"] = status
            
        entries = []
        # FIXED: Use await and iterate
        entry_docs = await payroll_collection.find(query)
        for entry in entry_docs:
            entries.append(Payroll.from_mongo(entry))
        return success_response(data=entries)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/payroll/{payroll_id}", response_model=StandardResponse[PayrollResponse])
async def get_payroll_entry(payroll_id: str):
    """Retrieve a single payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        if entry:
            return success_response(data=Payroll.from_mongo(entry))
        return error_response(message="Payroll entry not found", code=404)
    except Exception:
        return error_response(message="Invalid ID format for payroll entry", code=400)

@router.post("/payroll", response_model=StandardResponse[PayrollResponse])
async def create_payroll_entry(entry: Payroll):
    """Create a new payroll entry."""
    try:
        payroll_collection = get_collection("payroll")
        entry_dict = to_mongo_dict(entry)
        
        result = await payroll_collection.insert_one(entry_dict)
        new_entry = await payroll_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Payroll.from_mongo(new_entry),
            message="Payroll entry created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/payroll/{payroll_id}", response_model=StandardResponse[PayrollResponse])
async def update_payroll_entry(payroll_id: str, entry: Payroll):
    """Update an existing payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        entry_dict = to_mongo_update_dict(entry, exclude_unset=True)
        
        result = await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)}, {"$set": entry_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Payroll entry not found", code=404)
        
        updated_entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        return success_response(
            data=Payroll.from_mongo(updated_entry),
            message="Payroll entry updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for payroll entry", code=400)

@router.post("/payroll/{payroll_id}/process", response_model=StandardResponse[PayrollResponse])
async def process_payroll(payroll_id: str):
    """Simulate the processing of a payroll entry."""
    try:
        payroll_collection = get_collection("payroll")
        
        # Update status to processing
        await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)},
            {"$set": {"status": "processing", "updated_at": datetime.utcnow().isoformat()}}
        )
    
        # Simulate processing delay
        await asyncio.sleep(2)
    
        # Update status to paid
        result = await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)},
            {"$set": {"status": "paid", "updated_at": datetime.utcnow().isoformat()}}
        )
        
        if result.modified_count == 0:
            if await payroll_collection.find_one({"_id": ObjectId(payroll_id)}):
                pass
            else:
                return error_response(message="Payroll entry not found", code=404)
        
        updated_entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        return success_response(
            data=Payroll.from_mongo(updated_entry),
            message="Payroll processed successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for payroll entry", code=400)

@router.delete("/payroll/{payroll_id}", response_model=StandardResponse[dict])
async def delete_payroll_entry(payroll_id: str):
    """Delete a payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        result = await payroll_collection.delete_one({"_id": ObjectId(payroll_id)})
        if result.deleted_count == 0:
            return error_response(message="Payroll entry not found", code=404)
        return success_response(
            data=None,
            message="Payroll entry deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for payroll entry", code=400)

# -----------------
# Payroll settings endpoints
# -----------------
@router.get("/payroll_settings", response_model=StandardResponse[PayrollSettingsResponse])
async def get_payroll_settings(store_id: Optional[str] = Query(None)):
    """Retrieve payroll settings for a store or default settings."""
    try:
        settings_collection = get_collection("payroll_settings")
        query = {"store_id": store_id} if store_id else {"store_id": "default"}
        
        settings = await settings_collection.find_one(query)
        if not settings:
            default_settings = PayrollSettings(
                store_id=store_id or "default",
                default_payment_cycle="bi-weekly",
                tax_rate=0.20,
                overtime_multiplier=1.5
            )
            return success_response(data=default_settings)
        return success_response(data=PayrollSettings.from_mongo(settings))
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/payroll_settings", response_model=StandardResponse[PayrollSettingsResponse])
async def create_payroll_settings(settings: PayrollSettings):
    """Create or overwrite payroll settings for a store."""
    try:
        settings_collection = get_collection("payroll_settings")
        settings_dict = to_mongo_dict(settings)
        
        # Delete existing settings for the same store to enforce one-per-store
        await settings_collection.delete_many({"store_id": settings.store_id})
        
        result = await settings_collection.insert_one(settings_dict)
        new_settings = await settings_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=PayrollSettings.from_mongo(new_settings),
            message="Payroll settings created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/payroll_settings/{settings_id}", response_model=StandardResponse[PayrollSettingsResponse])
async def update_payroll_settings(settings_id: str, settings: PayrollSettings):
    """Update existing payroll settings by ID."""
    try:
        settings_collection = get_collection("payroll_settings")
        settings_dict = to_mongo_update_dict(settings, exclude_unset=True)
        
        result = await settings_collection.update_one(
            {"_id": ObjectId(settings_id)}, {"$set": settings_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Payroll settings not found", code=404)
        
        updated_settings = await settings_collection.find_one({"_id": ObjectId(settings_id)})
        return success_response(
            data=PayrollSettings.from_mongo(updated_settings),
            message="Payroll settings updated successfully"
        )
    except Exception:
        return error_response(message="Invalid ID format for payroll settings", code=400)

# -----------------
# Payroll calculation endpoint
# -----------------
@router.post("/payroll/calculate", response_model=StandardResponse[PayrollResponse])
async def calculate_payroll(employee_id: str, period_start: str, period_end: str):
    """Calculates payroll for a specific employee and time period."""
    try:
        # Get employee data
        employees_collection = get_collection("employees")
        employee_doc = await employees_collection.find_one({"_id": ObjectId(employee_id)})
        
        if not employee_doc:
            return error_response(message="Employee not found", code=404)
        
        # Get timesheet entries for the period
        ts_collection = get_collection("timesheet_entries")
        
        # Parse date strings to datetime objects for query
        try:
            start_dt = datetime.fromisoformat(period_start.replace('Z', '+00:00'))
            end_dt = datetime.fromisoformat(period_end.replace('Z', '+00:00'))
            
            query_start = start_dt.isoformat()
            query_end = end_dt.isoformat()
            
        except ValueError:
            return error_response(message="Invalid date format. Use ISO 8601 format.", code=400)
        
        # FIXED: Use await and iterate
        timesheets = await ts_collection.find({
            "employee_id": employee_id,
            "clock_in": {"$gte": query_start, "$lte": query_end},
            "clock_out": {"$ne": None}
        })
        
        # Get payroll settings
        store_id = employee_doc.get("store_id", "default")
        settings_collection = get_collection("payroll_settings")
        settings_data = await settings_collection.find_one({"store_id": store_id})
        
        # Use actual settings or default values
        if settings_data:
            settings = PayrollSettings.from_mongo(settings_data)
        else:
            settings = PayrollSettings(
                store_id=store_id,
                default_payment_cycle="bi-weekly",
                tax_rate=0.20,
                overtime_multiplier=1.5
            )
        
        # Calculate hours
        total_minutes = 0
        
        for ts in timesheets:
            if ts.get("duration_minutes"):
                total_minutes += ts["duration_minutes"]
        
        total_hours = total_minutes / 60
        
        # Simple overtime calculation
        if settings.default_payment_cycle == "monthly":
            OVERTIME_THRESHOLD_HOURS = 160
        elif settings.default_payment_cycle == "bi-weekly":
            OVERTIME_THRESHOLD_HOURS = 80
        else:
            OVERTIME_THRESHOLD_HOURS = 40
        
        overtime_hours = max(0, total_hours - OVERTIME_THRESHOLD_HOURS)
        regular_hours = total_hours - overtime_hours
        
        # Calculate pay
        hourly_rate = employee_doc.get("salary", 0) / 2080  
        
        regular_pay = regular_hours * hourly_rate
        overtime_pay = overtime_hours * hourly_rate * settings.overtime_multiplier
        gross_pay = regular_pay + overtime_pay
        tax_deductions = gross_pay * settings.tax_rate
        net_pay = gross_pay - tax_deductions
        
        payroll_data = Payroll(
            employee_id=employee_id,
            pay_period_start=period_start,
            pay_period_end=period_end,
            payment_cycle=settings.default_payment_cycle,
            gross_pay=round(gross_pay, 2),
            tax_deductions=round(tax_deductions, 2),
            net_pay=round(net_pay, 2),
            hours_worked=round(total_hours, 2),
            overtime_hours=round(overtime_hours, 2),
            overtime_rate=settings.overtime_multiplier,
            status="pending",
            store_id=store_id
        )
        
        return success_response(data=payroll_data)
    except Exception:
        return error_response(message="Invalid ID format for employee", code=400)

# -----------------
# Timesheets management endpoint
# -----------------
@router.get("/timesheets", response_model=StandardResponse[List[TimesheetResponse]])
async def get_timesheets(employee_id: Optional[str] = Query(None)):
    """Placeholder for fetching calculated timesheet summaries."""
    return success_response(data=[])

# -----------------
# Utility endpoints
# -----------------
@router.get("/health")
async def hr_health_check():
    """Health check for the HR module."""
    return success_response(data={"status": "healthy", "module": "hr"})

# Legacy endpoint for timesheet entries
@router.get("/timesheets_legacy", response_model=StandardResponse[List[TimesheetEntryResponse]])
async def get_timesheets_legacy():
    """Legacy endpoint for simple timesheet entries compatibility."""
    return await get_timesheet_entries()

=== INVENTORY ROUTES ===
# app/routes/inventory.py - COMPLETELY UPDATED
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from app.database import get_collection
from app.models.inventory import InventoryProduct, Supplier, Stock, Unit, StockAdjustment, InvCategory
from app.models.core import PurchaseOrder, GoodsReceipt
from app.models.response import (
    StandardResponse, InventoryProductResponse, SupplierResponse, UnitResponse, StockResponse,
    StockAdjustmentResponse, InvCategoryResponse, PurchaseOrderResponse,
    GoodsReceiptResponse
)
from app.utils.response_helpers import success_response, error_response, handle_http_exception, handle_generic_exception
from app.utils.mongo_helpers import to_mongo_dict, to_mongo_update_dict
from bson import ObjectId
from datetime import datetime

router = APIRouter(prefix="/api", tags=["inventory"])

# Inventory products endpoints
@router.get("/inventory_products", response_model=StandardResponse[List[InventoryProductResponse]])
async def get_inventory_products(store_id: Optional[str] = Query(None)):
    try:
        products_collection = get_collection("inventory_products")
        query = {"store_id": store_id} if store_id else {}
        products = []
        # FIXED: Use await and iterate
        product_docs = await products_collection.find(query)
        for product in product_docs:
            products.append(InventoryProduct.from_mongo(product))
        return success_response(data=products)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/inventory_products/{product_id}", response_model=StandardResponse[InventoryProductResponse])
async def get_inventory_product(product_id: str):
    try:
        products_collection = get_collection("inventory_products")
        product = await products_collection.find_one({"_id": ObjectId(product_id)})
        if product:
            return success_response(data=InventoryProduct.from_mongo(product))
        return error_response(message="Inventory product not found", code=404)
    except Exception:
        return error_response(message="Invalid product ID", code=400)

@router.post("/inventory_products", response_model=StandardResponse[InventoryProductResponse])
async def create_inventory_product(product: InventoryProduct):
    try:
        products_collection = get_collection("inventory_products")
        product_dict = to_mongo_dict(product)
        
        result = await products_collection.insert_one(product_dict)
        new_product = await products_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=InventoryProduct.from_mongo(new_product),
            message="Inventory product created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/inventory_products/{product_id}", response_model=StandardResponse[InventoryProductResponse])
async def update_inventory_product(product_id: str, product: InventoryProduct):
    try:
        products_collection = get_collection("inventory_products")
        product_dict = to_mongo_update_dict(product, exclude_unset=True)
        
        result = await products_collection.update_one(
            {"_id": ObjectId(product_id)}, {"$set": product_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Inventory product not found", code=404)
        
        updated_product = await products_collection.find_one({"_id": ObjectId(product_id)})
        return success_response(
            data=InventoryProduct.from_mongo(updated_product),
            message="Inventory product updated successfully"
        )
    except Exception:
        return error_response(message="Invalid product ID", code=400)

@router.delete("/inventory_products/{product_id}", response_model=StandardResponse[dict])
async def delete_inventory_product(product_id: str):
    try:
        products_collection = get_collection("inventory_products")
        result = await products_collection.delete_one({"_id": ObjectId(product_id)})
        if result.deleted_count == 0:
            return error_response(message="Inventory product not found", code=404)
        return success_response(
            data=None,
            message="Inventory product deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid product ID", code=400)

# Suppliers endpoints
@router.get("/suppliers", response_model=StandardResponse[List[SupplierResponse]])
async def get_suppliers():
    try:
        suppliers_collection = get_collection("suppliers")
        suppliers = []
        # FIXED: Use await and iterate
        supplier_docs = await suppliers_collection.find()
        for supplier in supplier_docs:
            suppliers.append(Supplier.from_mongo(supplier))
        return success_response(data=suppliers)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/suppliers/{supplier_id}", response_model=StandardResponse[SupplierResponse])
async def get_supplier(supplier_id: str):
    try:
        suppliers_collection = get_collection("suppliers")
        supplier = await suppliers_collection.find_one({"_id": ObjectId(supplier_id)})
        if supplier:
            return success_response(data=Supplier.from_mongo(supplier))
        return error_response(message="Supplier not found", code=404)
    except Exception:
        return error_response(message="Invalid supplier ID", code=400)

@router.post("/suppliers", response_model=StandardResponse[SupplierResponse])
async def create_supplier(supplier: Supplier):
    try:
        suppliers_collection = get_collection("suppliers")
        supplier_dict = to_mongo_dict(supplier)
        
        result = await suppliers_collection.insert_one(supplier_dict)
        new_supplier = await suppliers_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Supplier.from_mongo(new_supplier),
            message="Supplier created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/suppliers/{supplier_id}", response_model=StandardResponse[SupplierResponse])
async def update_supplier(supplier_id: str, supplier: Supplier):
    try:
        suppliers_collection = get_collection("suppliers")
        supplier_dict = to_mongo_update_dict(supplier, exclude_unset=True)
        
        result = await suppliers_collection.update_one(
            {"_id": ObjectId(supplier_id)}, {"$set": supplier_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Supplier not found", code=404)
        
        updated_supplier = await suppliers_collection.find_one({"_id": ObjectId(supplier_id)})
        return success_response(
            data=Supplier.from_mongo(updated_supplier),
            message="Supplier updated successfully"
        )
    except Exception:
        return error_response(message="Invalid supplier ID", code=400)

@router.delete("/suppliers/{supplier_id}", response_model=StandardResponse[dict])
async def delete_supplier(supplier_id: str):
    try:
        suppliers_collection = get_collection("suppliers")
        result = await suppliers_collection.delete_one({"_id": ObjectId(supplier_id)})
        if result.deleted_count == 0:
            return error_response(message="Supplier not found", code=404)
        return success_response(
            data=None,
            message="Supplier deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid supplier ID", code=400)

# Units endpoints
@router.get("/units", response_model=StandardResponse[List[UnitResponse]])
async def get_units():
    try:
        units_collection = get_collection("units")
        units = []
        # FIXED: Use await and iterate
        unit_docs = await units_collection.find()
        for unit in unit_docs:
            units.append(Unit.from_mongo(unit))
        return success_response(data=units)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/units/{unit_id}", response_model=StandardResponse[UnitResponse])
async def get_unit(unit_id: str):
    try:
        units_collection = get_collection("units")
        unit = await units_collection.find_one({"_id": ObjectId(unit_id)})
        if unit:
            return success_response(data=Unit.from_mongo(unit))
        return error_response(message="Unit not found", code=404)
    except Exception:
        return error_response(message="Invalid unit ID", code=400)

@router.post("/units", response_model=StandardResponse[UnitResponse])
async def create_unit(unit: Unit):
    try:
        units_collection = get_collection("units")
        unit_dict = to_mongo_dict(unit)
        
        result = await units_collection.insert_one(unit_dict)
        new_unit = await units_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Unit.from_mongo(new_unit),
            message="Unit created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/units/{unit_id}", response_model=StandardResponse[UnitResponse])
async def update_unit(unit_id: str, unit: Unit):
    try:
        units_collection = get_collection("units")
        unit_dict = to_mongo_update_dict(unit, exclude_unset=True)
        
        result = await units_collection.update_one(
            {"_id": ObjectId(unit_id)}, {"$set": unit_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Unit not found", code=404)
        
        updated_unit = await units_collection.find_one({"_id": ObjectId(unit_id)})
        return success_response(
            data=Unit.from_mongo(updated_unit),
            message="Unit updated successfully"
        )
    except Exception:
        return error_response(message="Invalid unit ID", code=400)

@router.delete("/units/{unit_id}", response_model=StandardResponse[dict])
async def delete_unit(unit_id: str):
    try:
        units_collection = get_collection("units")
        result = await units_collection.delete_one({"_id": ObjectId(unit_id)})
        if result.deleted_count == 0:
            return error_response(message="Unit not found", code=404)
        return success_response(
            data=None,
            message="Unit deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid unit ID", code=400)

# Stock endpoints
@router.get("/stocks", response_model=StandardResponse[List[StockResponse]])
async def get_stocks(product_id: Optional[str] = Query(None)):
    try:
        stocks_collection = get_collection("stocks")
        query = {"inventory_product_id": product_id} if product_id else {}
        stocks = []
        # FIXED: Use await and iterate
        stock_docs = await stocks_collection.find(query)
        for stock in stock_docs:
            stocks.append(Stock.from_mongo(stock))
        return success_response(data=stocks)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/stocks/{stock_id}", response_model=StandardResponse[StockResponse])
async def get_stock(stock_id: str):
    try:
        stocks_collection = get_collection("stocks")
        stock = await stocks_collection.find_one({"_id": ObjectId(stock_id)})
        if stock:
            return success_response(data=Stock.from_mongo(stock))
        return error_response(message="Stock not found", code=404)
    except Exception:
        return error_response(message="Invalid stock ID", code=400)

@router.post("/stocks", response_model=StandardResponse[StockResponse])
async def create_stock(stock: Stock):
    try:
        stocks_collection = get_collection("stocks")
        stock_dict = to_mongo_dict(stock)
        
        result = await stocks_collection.insert_one(stock_dict)
        new_stock = await stocks_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=Stock.from_mongo(new_stock),
            message="Stock created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/stocks/{stock_id}", response_model=StandardResponse[StockResponse])
async def update_stock(stock_id: str, stock: Stock):
    try:
        stocks_collection = get_collection("stocks")
        stock_dict = to_mongo_update_dict(stock, exclude_unset=True)
        
        result = await stocks_collection.update_one(
            {"_id": ObjectId(stock_id)}, {"$set": stock_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Stock not found", code=404)
        
        updated_stock = await stocks_collection.find_one({"_id": ObjectId(stock_id)})
        return success_response(
            data=Stock.from_mongo(updated_stock),
            message="Stock updated successfully"
        )
    except Exception:
        return error_response(message="Invalid stock ID", code=400)

@router.delete("/stocks/{stock_id}", response_model=StandardResponse[dict])
async def delete_stock(stock_id: str):
    try:
        stocks_collection = get_collection("stocks")
        result = await stocks_collection.delete_one({"_id": ObjectId(stock_id)})
        if result.deleted_count == 0:
            return error_response(message="Stock not found", code=404)
        return success_response(
            data=None,
            message="Stock deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid stock ID", code=400)

# Stock Adjustments endpoints
@router.get("/stock_adjustments", response_model=StandardResponse[List[StockAdjustmentResponse]])
async def get_stock_adjustments(stock_id: Optional[str] = Query(None)):
    try:
        sa_collection = get_collection("stock_adjustments")
        query = {"stock_id": stock_id} if stock_id else {}
        sas = []
        # FIXED: Use await and iterate
        sa_docs = await sa_collection.find(query)
        for sa in sa_docs:
            sas.append(StockAdjustment.from_mongo(sa))
        return success_response(data=sas)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/stock_adjustments/{adjustment_id}", response_model=StandardResponse[StockAdjustmentResponse])
async def get_stock_adjustment(adjustment_id: str):
    try:
        sa_collection = get_collection("stock_adjustments")
        sa = await sa_collection.find_one({"_id": ObjectId(adjustment_id)})
        if sa:
            return success_response(data=StockAdjustment.from_mongo(sa))
        return error_response(message="Stock adjustment not found", code=404)
    except Exception:
        return error_response(message="Invalid adjustment ID", code=400)

@router.post("/stock_adjustments", response_model=StandardResponse[StockAdjustmentResponse])
async def create_stock_adjustment(sa: StockAdjustment):
    try:
        sa_collection = get_collection("stock_adjustments")
        sa_dict = to_mongo_dict(sa)
        
        result = await sa_collection.insert_one(sa_dict)
        new_sa = await sa_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=StockAdjustment.from_mongo(new_sa),
            message="Stock adjustment created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/stock_adjustments/{adjustment_id}", response_model=StandardResponse[StockAdjustmentResponse])
async def update_stock_adjustment(adjustment_id: str, sa: StockAdjustment):
    try:
        sa_collection = get_collection("stock_adjustments")
        sa_dict = to_mongo_update_dict(sa, exclude_unset=True)
        
        result = await sa_collection.update_one(
            {"_id": ObjectId(adjustment_id)}, {"$set": sa_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Stock adjustment not found", code=404)
        
        updated_sa = await sa_collection.find_one({"_id": ObjectId(adjustment_id)})
        return success_response(
            data=StockAdjustment.from_mongo(updated_sa),
            message="Stock adjustment updated successfully"
        )
    except Exception:
        return error_response(message="Invalid adjustment ID", code=400)

@router.delete("/stock_adjustments/{adjustment_id}", response_model=StandardResponse[dict])
async def delete_stock_adjustment(adjustment_id: str):
    try:
        sa_collection = get_collection("stock_adjustments")
        result = await sa_collection.delete_one({"_id": ObjectId(adjustment_id)})
        if result.deleted_count == 0:
            return error_response(message="Stock adjustment not found", code=404)
        return success_response(
            data=None,
            message="Stock adjustment deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid adjustment ID", code=400)

# Inventory Categories endpoints
@router.get("/inv_categories", response_model=StandardResponse[List[InvCategoryResponse]])
async def get_inv_categories(store_id: Optional[str] = Query(None)):
    try:
        categories_collection = get_collection("inv_categories")
        query = {"store_id": store_id} if store_id else {}
        categories = []
        # FIXED: Use await and iterate
        category_docs = await categories_collection.find(query)
        for category in category_docs:
            categories.append(InvCategory.from_mongo(category))
        return success_response(data=categories)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/inv_categories/{category_id}", response_model=StandardResponse[InvCategoryResponse])
async def get_inv_category(category_id: str):
    try:
        categories_collection = get_collection("inv_categories")
        category = await categories_collection.find_one({"_id": ObjectId(category_id)})
        if category:
            return success_response(data=InvCategory.from_mongo(category))
        return error_response(message="Inventory category not found", code=404)
    except Exception:
        return error_response(message="Invalid category ID", code=400)

@router.post("/inv_categories", response_model=StandardResponse[InvCategoryResponse])
async def create_inv_category(category: InvCategory):
    try:
        categories_collection = get_collection("inv_categories")
        category_dict = to_mongo_dict(category)
        
        result = await categories_collection.insert_one(category_dict)
        new_category = await categories_collection.find_one({"_id": result.inserted_id})
        return success_response(
            data=InvCategory.from_mongo(new_category),
            message="Inventory category created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/inv_categories/{category_id}", response_model=StandardResponse[InvCategoryResponse])
async def update_inv_category(category_id: str, category: InvCategory):
    try:
        categories_collection = get_collection("inv_categories")
        category_dict = to_mongo_update_dict(category, exclude_unset=True)
        
        result = await categories_collection.update_one(
            {"_id": ObjectId(category_id)}, {"$set": category_dict}
        )
        if result.modified_count == 0:
            return error_response(message="Inventory category not found", code=404)
        
        updated_category = await categories_collection.find_one({"_id": ObjectId(category_id)})
        return success_response(
            data=InvCategory.from_mongo(updated_category),
            message="Inventory category updated successfully"
        )
    except Exception:
        return error_response(message="Invalid category ID", code=400)

@router.delete("/inv_categories/{category_id}", response_model=StandardResponse[dict])
async def delete_inv_category(category_id: str):
    try:
        categories_collection = get_collection("inv_categories")
        result = await categories_collection.delete_one({"_id": ObjectId(category_id)})
        if result.deleted_count == 0:
            return error_response(message="Inventory category not found", code=404)
        return success_response(
            data=None,
            message="Inventory category deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid category ID", code=400)

# Low stock items endpoint
@router.get("/inventory/low-stock", response_model=StandardResponse[List[InventoryProductResponse]])
async def get_low_stock_items(store_id: Optional[str] = Query(None)):
    try:
        products_collection = get_collection("inventory_products")
        query = {"store_id": store_id} if store_id else {}
        low_stock_items = []
        # FIXED: Use await and iterate
        product_docs = await products_collection.find(query)
        for product in product_docs:
            if product.get("quantity_in_stock", 0) <= product.get("reorder_level", 0):
                low_stock_items.append(InventoryProduct.from_mongo(product))
        return success_response(data=low_stock_items)
    except Exception as e:
        return handle_generic_exception(e)

# Pending purchase orders endpoint
@router.get("/purchase_orders/pending", response_model=StandardResponse[List[PurchaseOrderResponse]])
async def get_pending_purchase_orders():
    try:
        po_collection = get_collection("purchase_orders")
        pending_statuses = ['draft', 'pending-approval', 'approved', 'ordered']
        pending_orders = []
        # FIXED: Use await and iterate
        po_docs = await po_collection.find({"status": {"$in": pending_statuses}})
        for po in po_docs:
            pending_orders.append(PurchaseOrder.from_mongo(po))
        return success_response(data=pending_orders)
    except Exception as e:
        return handle_generic_exception(e)

# Stock level update endpoint
@router.post("/inventory_products/{product_id}/update-stock", response_model=StandardResponse[dict])
async def update_product_stock(product_id: str, quantity_change: float, reason: str = "Manual adjustment"):
    try:
        products_collection = get_collection("inventory_products")
        stock_adjustments_collection = get_collection("stock_adjustments")
        
        product = await products_collection.find_one({"_id": ObjectId(product_id)})
        if not product:
            return error_response(message="Inventory product not found", code=404)
        
        current_stock = product.get("quantity_in_stock", 0)
        new_stock = current_stock + quantity_change
        
        # Update product stock
        await products_collection.update_one(
            {"_id": ObjectId(product_id)},
            {"$set": {
                "quantity_in_stock": max(0, new_stock),
                "updated_at": datetime.utcnow().isoformat()
            }}
        )
        
        # Create stock adjustment record
        adjustment = StockAdjustment(
            stock_id=product_id,
            quantity_change=quantity_change,
            reason=reason,
            adjustment_date=datetime.utcnow().isoformat()
        )
        
        adjustment_dict = to_mongo_dict(adjustment)
        
        await stock_adjustments_collection.insert_one(adjustment_dict)
        
        return success_response(data={
            "message": "Stock updated successfully",
            "product_id": product_id,
            "previous_stock": current_stock,
            "new_stock": new_stock,
            "adjustment": quantity_change
        })
    except Exception:
        return error_response(message="Invalid product ID", code=400)

# Health check endpoint
@router.get("/health")
async def inventory_health_check():
    return success_response(data={"status": "healthy", "module": "inventory"})

=== PAYROLL ROUTES ===
# app/routes/payroll.py - COMPLETE IMPLEMENTATION
from fastapi import APIRouter, HTTPException, Query
from typing import List, Optional
from app.database import get_collection
from app.models.hr import Payroll, PayrollSettings, Employee, PayrollDeduction
from app.models.response import StandardResponse, PayrollResponse, PayrollSettingsResponse
from app.utils.response_helpers import success_response, error_response, handle_generic_exception
from app.utils.mongo_helpers import to_mongo_dict, to_mongo_update_dict
from bson import ObjectId
from datetime import datetime, timedelta
import asyncio

router = APIRouter(prefix="/api", tags=["payroll"])

# Helper function to get or create default payroll settings
async def get_or_create_payroll_settings(store_id: str) -> PayrollSettings:
    """Get payroll settings for a store, create default if not exists."""
    settings_collection = get_collection("payroll_settings")
    settings_data = await settings_collection.find_one({"store_id": store_id})
    
    if not settings_data:
        # Create default settings
        default_settings = PayrollSettings(
            store_id=store_id,
            default_payment_cycle="bi-weekly",
            tax_rate=0.20,
            overtime_multiplier=1.5
        )
        settings_dict = to_mongo_dict(default_settings)
        await settings_collection.insert_one(settings_dict)
        return default_settings
    
    return PayrollSettings.from_mongo(settings_data)

# Payroll endpoints
@router.get("/payroll", response_model=StandardResponse[List[PayrollResponse]])
async def get_payroll_entries(
    store_id: Optional[str] = Query(None),
    employee_id: Optional[str] = Query(None),
    status: Optional[str] = Query(None)
):
    """Retrieve payroll entries with optional filtering."""
    try:
        payroll_collection = get_collection("payroll")
        query = {}
        if store_id:
            query["store_id"] = store_id
        if employee_id:
            query["employee_id"] = employee_id
        if status:
            query["status"] = status
            
        entries = []
        # FIX: Use to_list() for async iteration
        entry_docs = await payroll_collection.find(query).to_list(length=1000)
        
        for entry in entry_docs:
            payroll = Payroll.from_mongo(entry)
            
            # Enrich with employee data
            employees_collection = get_collection("employees")
            employee = await employees_collection.find_one({"_id": ObjectId(payroll.employee_id)})
            if employee:
                payroll.employee_name = f"{employee.get('first_name', '')} {employee.get('last_name', '')}".strip()
            
            entries.append(payroll)
            
        return success_response(data=entries)
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/payroll/{payroll_id}", response_model=StandardResponse[PayrollResponse])
async def get_payroll_entry(payroll_id: str):
    """Retrieve a single payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        if entry:
            payroll = Payroll.from_mongo(entry)
            
            # Enrich with employee data
            employees_collection = get_collection("employees")
            employee = await employees_collection.find_one({"_id": ObjectId(payroll.employee_id)})
            if employee:
                payroll.employee_name = f"{employee.get('first_name', '')} {employee.get('last_name', '')}".strip()
                
            return success_response(data=payroll)
        return error_response(message="Payroll entry not found", code=404)
    except Exception:
        return error_response(message="Invalid payroll ID", code=400)

@router.post("/payroll", response_model=StandardResponse[PayrollResponse])
async def create_payroll_entry(payroll: Payroll):
    """Create a new payroll entry."""
    try:
        payroll_collection = get_collection("payroll")
        
        # Validate employee exists
        employees_collection = get_collection("employees")
        employee = await employees_collection.find_one({"_id": ObjectId(payroll.employee_id)})
        if not employee:
            return error_response(message="Employee not found", code=404)
        
        payroll_dict = to_mongo_dict(payroll)
        payroll_dict["created_at"] = datetime.utcnow().isoformat()
        payroll_dict["updated_at"] = datetime.utcnow().isoformat()
        
        result = await payroll_collection.insert_one(payroll_dict)
        new_entry = await payroll_collection.find_one({"_id": result.inserted_id})
        
        # Enrich with employee data
        payroll_response = Payroll.from_mongo(new_entry)
        payroll_response.employee_name = f"{employee.get('first_name', '')} {employee.get('last_name', '')}".strip()
        
        return success_response(
            data=payroll_response,
            message="Payroll entry created successfully",
            code=201
        )
    except Exception as e:
        return handle_generic_exception(e)

@router.put("/payroll/{payroll_id}", response_model=StandardResponse[PayrollResponse])
async def update_payroll_entry(payroll_id: str, payroll: Payroll):
    """Update an existing payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        payroll_dict = to_mongo_update_dict(payroll, exclude_unset=True)
        payroll_dict["updated_at"] = datetime.utcnow().isoformat()
        
        result = await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)}, {"$set": payroll_dict}
        )
        if result.modified_count == 0 and result.matched_count == 0:
            return error_response(message="Payroll entry not found", code=404)
        
        updated_entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        
        # Enrich with employee data
        employees_collection = get_collection("employees")
        employee = await employees_collection.find_one({"_id": ObjectId(payroll.employee_id)})
        payroll_response = Payroll.from_mongo(updated_entry)
        if employee:
            payroll_response.employee_name = f"{employee.get('first_name', '')} {employee.get('last_name', '')}".strip()
        
        return success_response(
            data=payroll_response,
            message="Payroll entry updated successfully"
        )
    except Exception:
        return error_response(message="Invalid payroll ID", code=400)

@router.post("/payroll/{payroll_id}/process", response_model=StandardResponse[PayrollResponse])
async def process_payroll(payroll_id: str):
    """Process a payroll entry and mark it as paid."""
    try:
        payroll_collection = get_collection("payroll")
        
        # Check if payroll exists
        payroll_entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        if not payroll_entry:
            return error_response(message="Payroll entry not found", code=404)
        
        # Update status to processing
        await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)},
            {"$set": {
                "status": "processing", 
                "updated_at": datetime.utcnow().isoformat()
            }}
        )
        
        # Simulate processing delay (bank transfer, etc.)
        await asyncio.sleep(2)
        
        # Update status to paid
        result = await payroll_collection.update_one(
            {"_id": ObjectId(payroll_id)},
            {"$set": {
                "status": "paid", 
                "updated_at": datetime.utcnow().isoformat()
            }}
        )
        
        if result.modified_count == 0:
            return error_response(message="Payroll entry not found", code=404)
        
        updated_entry = await payroll_collection.find_one({"_id": ObjectId(payroll_id)})
        
        # Enrich with employee data
        employees_collection = get_collection("employees")
        employee = await employees_collection.find_one({"_id": ObjectId(updated_entry["employee_id"])})
        payroll_response = Payroll.from_mongo(updated_entry)
        if employee:
            payroll_response.employee_name = f"{employee.get('first_name', '')} {employee.get('last_name', '')}".strip()
        
        return success_response(
            data=payroll_response,
            message="Payroll processed successfully"
        )
    except Exception:
        return error_response(message="Invalid payroll ID", code=400)

@router.delete("/payroll/{payroll_id}", response_model=StandardResponse[dict])
async def delete_payroll_entry(payroll_id: str):
    """Delete a payroll entry by ID."""
    try:
        payroll_collection = get_collection("payroll")
        result = await payroll_collection.delete_one({"_id": ObjectId(payroll_id)})
        if result.deleted_count == 0:
            return error_response(message="Payroll entry not found", code=404)
        return success_response(
            data=None,
            message="Payroll entry deleted successfully"
        )
    except Exception:
        return error_response(message="Invalid payroll ID", code=400)

@router.post("/payroll/calculate", response_model=StandardResponse[PayrollResponse])
async def calculate_payroll(
    employee_id: str,
    period_start: str,
    period_end: str,
    store_id: Optional[str] = None
):
    """Calculate payroll for a specific employee and time period using payroll settings."""
    try:
        # Get employee data
        employees_collection = get_collection("employees")
        employee_doc = await employees_collection.find_one({"_id": ObjectId(employee_id)})
        
        if not employee_doc:
            return error_response(message="Employee not found", code=404)
        
        # Get or create payroll settings
        store_id = employee_doc.get("store_id", store_id or "default")
        settings = await get_or_create_payroll_settings(store_id)
        
        print(f"Using payroll settings: {settings.model_dump()}")  # Debug log
        
        # Get timesheet entries for the period
        ts_collection = get_collection("timesheet_entries")
        
        # Parse date strings to datetime objects for query
        try:
            start_dt = datetime.fromisoformat(period_start.replace('Z', '+00:00'))
            end_dt = datetime.fromisoformat(period_end.replace('Z', '+00:00'))
            
            query_start = start_dt.isoformat()
            query_end = end_dt.isoformat()
            
        except ValueError:
            return error_response(message="Invalid date format. Use ISO 8601 format.", code=400)
        
        # Get timesheets for the period - FIX: Use to_list()
        timesheet_list = await ts_collection.find({
            "employee_id": employee_id,
            "clock_in": {"$gte": query_start, "$lte": query_end},
            "clock_out": {"$ne": None}
        }).to_list(length=1000)
        
        # Calculate total hours worked
        total_minutes = 0
        
        for ts in timesheet_list:
            if ts.get("duration_minutes"):
                total_minutes += ts["duration_minutes"]
        
        total_hours = total_minutes / 60
        
        # Calculate overtime based on payment cycle using settings
        regular_hours = total_hours
        overtime_hours = 0
        
        if settings.default_payment_cycle == "monthly":
            # Approximately 160 hours per month (4 weeks * 40 hours)
            regular_hours_threshold = 160
        elif settings.default_payment_cycle == "bi-weekly":
            # 80 hours per 2 weeks
            regular_hours_threshold = 80
        else:  # weekly
            # 40 hours per week
            regular_hours_threshold = 40
        
        # Apply overtime
        if total_hours > regular_hours_threshold:
            overtime_hours = total_hours - regular_hours_threshold
            regular_hours = regular_hours_threshold
        
        print(f"Hours calculation - Total: {total_hours}, Regular: {regular_hours}, Overtime: {overtime_hours}")
        
        # Calculate pay rates
        annual_salary = employee_doc.get("salary", 0)
        
        # Calculate hourly rate based on payment cycle
        if settings.default_payment_cycle == "monthly":
            # Assuming 12 months, 160 hours per month
            hourly_rate = annual_salary / (12 * 160) if annual_salary > 0 else 0
        elif settings.default_payment_cycle == "bi-weekly":
            # 26 pay periods per year, 80 hours per period
            hourly_rate = annual_salary / (26 * 80) if annual_salary > 0 else 0
        else:  # weekly
            # 52 weeks per year, 40 hours per week
            hourly_rate = annual_salary / (52 * 40) if annual_salary > 0 else 0
        
        print(f"Hourly rate: {hourly_rate}, Overtime multiplier: {settings.overtime_multiplier}")
        
        # Calculate pay components
        regular_pay = regular_hours * hourly_rate
        overtime_pay = overtime_hours * hourly_rate * settings.overtime_multiplier
        gross_pay = regular_pay + overtime_pay
        
        # Apply tax rate from settings
        tax_deductions = gross_pay * settings.tax_rate
        net_pay = gross_pay - tax_deductions
        
        print(f"Pay calculation - Regular: {regular_pay}, Overtime: {overtime_pay}, Gross: {gross_pay}, Tax: {tax_deductions}, Net: {net_pay}")
        
        # Create payroll data with deductions
        tax_deduction_record = PayrollDeduction(
            payroll_id="temp",  # Will be set when payroll is created
            type="tax",
            description="Income tax deduction",
            amount=round(tax_deductions, 2)
        )
        
        payroll_data = Payroll(
            employee_id=employee_id,
            pay_period_start=period_start,
            pay_period_end=period_end,
            payment_cycle=settings.default_payment_cycle,
            gross_pay=round(gross_pay, 2),
            tax_deductions=round(tax_deductions, 2),
            net_pay=round(net_pay, 2),
            hours_worked=round(total_hours, 2),
            overtime_hours=round(overtime_hours, 2),
            overtime_rate=settings.overtime_multiplier,
            deductions=[tax_deduction_record],
            status="pending",
            store_id=store_id
        )
        
        return success_response(data=payroll_data)
        
    except Exception as e:
        print(f"Error in payroll calculation: {str(e)}")
        return error_response(message=f"Error calculating payroll: {str(e)}", code=400)

# Payroll settings endpoints
@router.get("/payroll_settings", response_model=StandardResponse[PayrollSettingsResponse])
async def get_payroll_settings(store_id: Optional[str] = Query(None)):
    """Retrieve payroll settings for a store."""
    try:
        store_id = store_id or "default"
        settings = await get_or_create_payroll_settings(store_id)
        return success_response(data=settings)
    except Exception as e:
        return handle_generic_exception(e)

@router.post("/payroll_settings", response_model=StandardResponse[PayrollSettingsResponse])
async def create_payroll_settings(settings: PayrollSettings):
    """Create or update payroll settings for a store."""
    try:
        settings_collection = get_collection("payroll_settings")
        settings_dict = to_mongo_dict(settings)
        settings_dict["updated_at"] = datetime.utcnow().isoformat()
        
        # Check if settings already exist for this store
        existing = await settings_collection.find_one({"store_id": settings.store_id})
        
        if existing:
            # Update existing settings
            result = await settings_collection.update_one(
                {"store_id": settings.store_id},
                {"$set": settings_dict}
            )
            if result.modified_count == 0:
                return error_response(message="Failed to update payroll settings", code=400)
                
            updated_settings = await settings_collection.find_one({"store_id": settings.store_id})
            return success_response(
                data=PayrollSettings.from_mongo(updated_settings),
                message="Payroll settings updated successfully"
            )
        else:
            # Create new settings
            settings_dict["created_at"] = datetime.utcnow().isoformat()
            result = await settings_collection.insert_one(settings_dict)
            new_settings = await settings_collection.find_one({"_id": result.inserted_id})
            return success_response(
                data=PayrollSettings.from_mongo(new_settings),
                message="Payroll settings created successfully",
                code=201
            )
    except Exception as e:
        return handle_generic_exception(e)

@router.get("/health")
async def payroll_health_check():
    """Health check for the payroll module."""
    return success_response(data={"status": "healthy", "module": "payroll"})

=== BASE MODELS ===
# app/models/base.py - FIXED VERSION
from typing import Optional, Any
from pydantic import BaseModel, Field, field_validator
from pydantic_core import core_schema
from bson import ObjectId
from datetime import datetime, date
import json

class PyObjectId(str):
    @classmethod
    def __get_pydantic_core_schema__(cls, source_type: Any, handler) -> core_schema.CoreSchema:
        return core_schema.json_or_python_schema(
            json_schema=core_schema.str_schema(),
            python_schema=core_schema.union_schema([
                core_schema.is_instance_schema(ObjectId),
                core_schema.str_schema()
            ]),
            serialization=core_schema.plain_serializer_function_ser_schema(
                lambda x: str(x) if x else None
            ),
        )

    @classmethod
    def validate(cls, v):
        if isinstance(v, ObjectId):
            return str(v)
        if isinstance(v, str) and ObjectId.is_valid(v):
            return v
        raise ValueError("Invalid ObjectId")

    @classmethod
    def __get_validators__(cls):
        yield cls.validate

class MongoModel(BaseModel):
    id: Optional[PyObjectId] = Field(default=None, alias="_id")
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

    class Config:
        populate_by_name = True
        arbitrary_types_allowed = True
        json_encoders = {
            ObjectId: str,
            datetime: lambda v: v.isoformat() if v else None,
            date: lambda v: v.isoformat() if v else None
        }

    def to_dict(self, **kwargs) -> dict:
        """Convert model to dictionary with proper ID handling"""
        exclude_unset = kwargs.pop('exclude_unset', True)
        by_alias = kwargs.pop('by_alias', True)
        
        data = self.model_dump(
            exclude_unset=exclude_unset,
            by_alias=by_alias,
            **kwargs,
        )
        
        # Handle ID fields - ensure we don't have both id and _id
        if '_id' in data and 'id' in data:
            del data['id']
        elif 'id' in data and '_id' not in data:
            data['_id'] = data.pop('id')
            
        return data

    @classmethod
    def from_mongo(cls, data: dict):
        """Convert MongoDB document to model instance"""
        if not data:
            return None
            
        data = data.copy()
        
        # Convert _id to id for response models
        if '_id' in data:
            if isinstance(data['_id'], ObjectId):
                data['id'] = str(data['_id'])
            else:
                data['id'] = data['_id']
            # Remove _id to avoid conflicts
            del data['_id']
        
        # Convert datetime fields to ISO strings
        for field, value in data.items():
            if isinstance(value, (datetime, date)):
                data[field] = value.isoformat()
            elif isinstance(value, ObjectId):
                data[field] = str(value)
        
        return cls(**data)

=== CORE MODELS ===
# app/models/core.py
from typing import Optional, List, Dict, Any
from pydantic import Field, EmailStr
from datetime import datetime, date
import math
from .base import MongoModel, PyObjectId

# Recipe model for embedded recipes
class RecipeItem(MongoModel):
    id: Optional[str] = None
    food_id: str
    inventory_product_id: str
    quantity_used: float
    unit_of_measure: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    
    def to_response_dict(self) -> dict:
        """Convert RecipeItem to dictionary for response"""
        return {
            "id": self.id,
            "food_id": self.food_id,
            "inventory_product_id": self.inventory_product_id,
            "quantity_used": self.quantity_used,
            "unit_of_measure": self.unit_of_measure,
            "created_at": self.created_at,
            "updated_at": self.updated_at
        }

class Food(MongoModel):
    name: str
    description: str
    price: float
    category_id: str
    image_url: Optional[str] = None
    preparation_time: Optional[int] = None
    allergens: Optional[List[str]] = []
    tenant_id: str
    recipes: Optional[List[RecipeItem]] = []
    store_id: Optional[str] = None
    is_available: Optional[bool] = True
    
    def to_response_dict(self) -> dict:
        """Convert Food to dictionary for response with proper recipe handling"""
        data = self.model_dump()
        
        # Convert RecipeItem objects to dictionaries
        if self.recipes:
            data['recipes'] = [recipe.to_response_dict() if hasattr(recipe, 'to_response_dict') 
                             else recipe for recipe in self.recipes]
        
        return data

class StoreFood(MongoModel):
    food_id: str
    store_id: str
    is_available: bool = True

class OrderItem(MongoModel):
    id: Optional[str] = None
    order_id: str
    food_id: str
    quantity: int
    price: float
    sub_total: float
    notes: Optional[str] = None
    name: str
    price_at_sale: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Order(MongoModel):
    store_id: Optional[str] = None
    table_id: Optional[str] = None
    customer_id: Optional[str] = None
    total_amount: float
    status: str
    notes: str
    items: List[OrderItem] = []
    subtotal_amount: float
    tax_amount: float
    discount_amount: float
    employee_id: Optional[str] = None
    order_type: Optional[str] = None  # "dine-in" | "takeaway"
    payment_status: Optional[str] = None
    payment_method: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Category(MongoModel):
    name: str
    description: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class InvCategory(MongoModel):
    name: str
    description: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Customer(MongoModel):
    first_name: str
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    loyalty_points: Optional[int] = 0
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Table(MongoModel):
    name: str
    capacity: int
    location: str
    status: str
    current_order_id: Optional[str] = None
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Store(MongoModel):
    name: str
    address: str
    phone: str
    email: str
    tenant_id: str
    location: Optional[str] = None
    manager_id: Optional[str] = None
    kiosk_user_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PurchaseOrderItem(MongoModel):
    inventory_product_id: str
    quantity: float
    unit_of_measure: str
    unit_cost: float
    total_cost: float
    notes: Optional[str] = None

class PurchaseOrder(MongoModel):
    po_number: str
    supplier_id: str
    site_id: str
    status: str
    order_date: str
    expected_delivery_date: str
    total_amount: float
    ordered_by: str
    notes: Optional[str] = None
    items: List[PurchaseOrderItem] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class GoodsReceiptItem(MongoModel):
    inventory_product_id: str
    purchase_order_id: str
    received_quantity: float
    unit_of_measure: str
    condition: str
    notes: Optional[str] = None

class GoodsReceipt(MongoModel):
    receipt_number: str
    purchase_order_id: str
    store_id: str
    receipt_date: str
    received_by: str
    items: List[GoodsReceiptItem] = []
    receiving_bin_id: Optional[str] = None
    status: Optional[str] = None
    received_items: Optional[List[Dict]] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class User(MongoModel):
    # name: Optional[str] = None
    email: EmailStr
    username: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    password: Optional[str] = None  # Make password optional
    email_verified_at: Optional[datetime] = None
    remember_token: Optional[str] = None
    cashAccounts: Optional[List[Any]] = []
    cardAccounts: Optional[List[Any]] = []
    onlineAccounts: Optional[List[Any]] = []
    gpayAccounts: Optional[List[Any]] = []
    phonepeAccounts: Optional[List[Any]] = []
    amazonpayAccounts: Optional[List[Any]] = []
    locations: Optional[List[Any]] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

    def to_dict(self, **kwargs) -> dict:
        """Convert model to dictionary with proper handling for all fields"""
        data = super().to_dict(**kwargs)
        # Ensure all optional lists are included
        for field in ['cashAccounts', 'cardAccounts', 'onlineAccounts', 'gpayAccounts', 'phonepeAccounts', 'amazonpayAccounts', 'locations']:
            if field not in data or data[field] is None:
                data[field] = []
        return data

class Payment(MongoModel):
    order_id: str
    payment_method_id: str
    amount: float
    payment_date: str
    transaction_id: Optional[str] = None
    status: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Tax(MongoModel):
    name: str
    percentage: float
    is_active: bool = True
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PaymentMethod(MongoModel):
    name: str
    description: str
    is_active: bool = True
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Brand(MongoModel):
    name: str
    description: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class ContactMessage(MongoModel):
    name: str
    email: str
    subject: str
    message: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Report(MongoModel):
    user_id: str
    user_name: str
    user_role: str
    attempted_path: str
    attempts: int
    last_attempt_at: str
    created_at: Optional[str] = None

class Reservation(MongoModel):
    customer_id: str
    table_id: Optional[str] = None
    date_time: str
    number_of_guests: int
    status: str
    notes: Optional[str] = None
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Domain(MongoModel):
    tenant_id: str
    domain: str
    is_primary: bool = False
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Job(MongoModel):
    queue: str
    payload: str
    attempts: int
    reserved_at: Optional[int] = None
    available_at: int
    created_at: int

class FailedJob(MongoModel):
    uuid: str
    connection: str
    queue: str
    payload: str
    exception: str
    failed_at: str

class PasswordReset(MongoModel):
    email: str
    token: str
    created_at: str

class Tenant(MongoModel):
    name: str
    email: str
    password: str
    remember_token: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Site(MongoModel):
    name: str
    address: str
    type: str
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Stock(MongoModel):
    food_id: str
    quantity: int
    unit_id: str
    supplier_id: str
    last_restock_date: str
    expiration_date: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class StockAdjustment(MongoModel):
    stock_id: str
    quantity_change: int
    reason: str
    adjustment_date: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

=== HR MODELS ===
# app/models/hr.py
from typing import Optional, List, Dict, Any
from pydantic import Field, EmailStr
from datetime import datetime, timedelta, date
import asyncio
from .base import MongoModel

class Department(MongoModel):
    name: str
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PersonalDetails(MongoModel):
    citizenship: str
    gender: str
    birth_date: str
    age: str
    
    def to_response_dict(self) -> dict:
        """Convert PersonalDetails to dictionary for response"""
        return {
            "citizenship": self.citizenship,
            "gender": self.gender,
            "birth_date": self.birth_date,
            "age": self.age
        }

class ContactDetails(MongoModel):
    cell_phone: str
    whatsapp_number: str
    email: str
    address: str
    
    def to_response_dict(self) -> dict:
        """Convert ContactDetails to dictionary for response"""
        return {
            "cell_phone": self.cell_phone,
            "whatsapp_number": self.whatsapp_number,
            "email": self.email,
            "address": self.address
        }

class EmploymentDetails(MongoModel):
    job_title: str
    team: str
    employment_type: str
    location: str
    
    def to_response_dict(self) -> dict:
        """Convert EmploymentDetails to dictionary for response"""
        return {
            "job_title": self.job_title,
            "team": self.team,
            "employment_type": self.employment_type,
            "location": self.location
        }

class EmployeeStatus(MongoModel):
    current_status: str
    on_leave_since: Optional[str] = None
    termination_date: Optional[str] = None
    termination_reason: Optional[str] = None
    
    def to_response_dict(self) -> dict:
        """Convert EmployeeStatus to dictionary for response"""
        return {
            "current_status": self.current_status,
            "on_leave_since": self.on_leave_since,
            "termination_date": self.termination_date,
            "termination_reason": self.termination_reason
        }

class Employee(MongoModel):
    user_id: str
    job_title_id: str
    access_role_ids: List[str]
    tenant_id: str
    store_id: str
    main_access_role_id: str
    hire_date: str
    salary: float
    first_name: str
    last_name: Optional[str] = None
    avatar_url: Optional[str] = None
    
    # Frontend-specific fields
    employee_id: Optional[str] = None
    full_name: Optional[str] = None
    middle_name: Optional[str] = None
    suffix: Optional[str] = None
    profile_photo_url: Optional[str] = None
    
    personal_details: Optional[PersonalDetails] = None
    contact_details: Optional[ContactDetails] = None
    employment_details: Optional[EmploymentDetails] = None
    status: Optional[EmployeeStatus] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    
    def to_response_dict(self) -> dict:
        """Convert Employee to dictionary for response with proper nested object handling"""
        data = self.model_dump()
        
        # Convert nested objects to dictionaries
        if self.personal_details:
            data['personal_details'] = self.personal_details.to_response_dict() if hasattr(self.personal_details, 'to_response_dict') else self.personal_details
            
        if self.contact_details:
            data['contact_details'] = self.contact_details.to_response_dict() if hasattr(self.contact_details, 'to_response_dict') else self.contact_details
            
        if self.employment_details:
            data['employment_details'] = self.employment_details.to_response_dict() if hasattr(self.employment_details, 'to_response_dict') else self.employment_details
            
        if self.status:
            data['status'] = self.status.to_response_dict() if hasattr(self.status, 'to_response_dict') else self.status
            
        return data

class AccessRole(MongoModel):
    name: str
    description: str
    permissions: List[str]
    landing_page: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class JobTitle(MongoModel):
    title: str
    description: Optional[str] = None
    department: str
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Shift(MongoModel):
    employee_id: str
    start: str
    end: str
    title: Optional[str] = None
    employee_name: Optional[str] = None
    color: Optional[str] = None
    active: Optional[bool] = True
    recurring: Optional[bool] = False
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class TimesheetEntry(MongoModel):
    employee_id: str
    clock_in: str
    clock_out: Optional[str] = None
    duration_minutes: Optional[int] = 0
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PayrollDeduction(MongoModel):
    id: Optional[str] = None
    payroll_id: str
    type: str  # "tax" | "insurance" | "retirement" | "other"
    description: str
    amount: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    
    def to_response_dict(self) -> dict:
        """Convert PayrollDeduction to dictionary for response"""
        return {
            "id": self.id,
            "payroll_id": self.payroll_id,
            "type": self.type,
            "description": self.description,
            "amount": self.amount,
            "created_at": self.created_at,
            "updated_at": self.updated_at
        }

class PayrollSettings(MongoModel):
    store_id: str
    default_payment_cycle: str  # "weekly" | "bi-weekly" | "monthly"
    tax_rate: float
    overtime_multiplier: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Payroll(MongoModel):
    employee_id: str
    pay_period_start: str
    pay_period_end: str
    payment_cycle: str  # "weekly" | "bi-weekly" | "monthly"
    gross_pay: float
    tax_deductions: float
    net_pay: float
    status: str  # "pending" | "processing" | "paid" | "failed"
    hours_worked: float
    overtime_hours: float
    overtime_rate: float
    deductions: Optional[List[PayrollDeduction]] = []
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    
    def to_response_dict(self) -> dict:
        """Convert Payroll to dictionary for response with proper nested handling"""
        data = self.model_dump()
        
        # Convert deductions to dictionaries
        if self.deductions:
            data['deductions'] = [
                deduction.to_response_dict() if hasattr(deduction, 'to_response_dict') 
                else deduction for deduction in self.deductions
            ]
        
        return data

class Company(MongoModel):
    company_id: str
    name: str
    country: str
    tax_details: Dict[str, Any]
    metrics: Dict[str, Any]

class Timesheet(MongoModel):
    timesheet_id: str
    employee_id: str
    start_date: str
    end_date: str
    daily_hours: Dict[str, str]
    total_weekly_hours: str

class TaxDetails(MongoModel):
    tax_year: str
    efiling_admin: str
    related_docs: str

class CompanyMetrics(MongoModel):
    total_employees: int
    active_employees: int
    employees_on_leave: int
    terminated_employees: int
    full_time_employees: int
    part_time_employees: int
    contract_employees: int
    employee_invites: Dict[str, int]

class EmployeeInvites(MongoModel):
    sent: int
    active: int
    require_attention: int

=== INVENTORY MODELS ===
# app/models/inventory.py
from typing import Optional
from pydantic import Field
from datetime import datetime
from .base import MongoModel

class InventoryProduct(MongoModel):
    name: str
    description: Optional[str] = None
    sku: str
    unit_of_measure: str
    tenant_id: str
    unit_cost: float
    quantity_in_stock: float
    reorder_level: float
    supplier_id: Optional[str] = None
    inv_category_id: Optional[str] = None
    location_in_warehouse: Optional[str] = None
    last_restocked_at: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Supplier(MongoModel):
    name: str
    contact_person: str
    phone: str
    email: str
    address: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Unit(MongoModel):
    name: str
    symbol: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class Stock(MongoModel):
    inventory_product_id: str
    quantity: float
    unit_id: str
    supplier_id: str
    last_restock_date: str
    expiration_date: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class StockAdjustment(MongoModel):
    stock_id: str
    quantity_change: float
    reason: str
    adjustment_date: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class InvCategory(MongoModel):
    name: str
    description: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

=== RESPONSE MODELS ===
# app/models/response.py - COMPLETE FIXED VERSION
from typing import List, Optional, Any, Dict, Union, Generic, TypeVar
from pydantic import BaseModel, EmailStr, ConfigDict
from datetime import datetime, date
from bson import ObjectId

# Generic type variable for the data payload
T = TypeVar('T')

class StandardResponse(BaseModel, Generic[T]):
    """Standard response format for all API endpoints"""
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    code: int = 200
    message: str = "success"
    data: Optional[T] = None

class PaginatedResponse(BaseModel, Generic[T]):
    """Standard response for paginated data"""
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    code: int = 200
    message: str = "success"
    data: Optional[T] = None
    pagination: Optional[Dict[str, Any]] = None

class ErrorResponse(BaseModel):
    """Standard error response format"""
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    code: int
    message: str
    details: Optional[Dict[str, Any]] = None

# Recipe Item Response
class RecipeItemResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    food_id: str
    inventory_product_id: str
    quantity_used: float
    unit_of_measure: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

# Core POS Entities
class FoodResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: str
    price: float
    category_id: str
    image_url: Optional[str] = None
    preparation_time: Optional[int] = None
    allergens: Optional[List[str]] = []
    tenant_id: str
    # CHANGED: Use RecipeItemResponse instead of List[Dict]
    recipes: Optional[List[RecipeItemResponse]] = []
    store_id: Optional[str] = None
    is_available: Optional[bool] = True
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class StoreFoodResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    food_id: str
    store_id: str
    is_available: bool = True

class OrderItemResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    order_id: str
    food_id: str
    quantity: int
    price: float
    sub_total: float
    notes: Optional[str] = None
    name: str
    price_at_sale: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class OrderResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    store_id: Optional[str] = None
    table_id: Optional[str] = None
    customer_id: Optional[str] = None
    total_amount: float
    status: str
    notes: str
    items: List[OrderItemResponse] = []
    subtotal_amount: float
    tax_amount: float
    discount_amount: float
    employee_id: Optional[str] = None
    order_type: Optional[str] = None
    payment_status: Optional[str] = None
    payment_method: Optional[str] = None
    stock_warnings: Optional[List[str]] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class CategoryResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class InvCategoryResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: Optional[str] = None
    store_id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class CustomerResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    first_name: str
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None
    phone_number: Optional[str] = None
    loyalty_points: Optional[int] = 0
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class TableResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    capacity: int
    location: str
    status: str
    current_order_id: Optional[str] = None
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class AccessRoleResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: str
    permissions: List[str]
    landing_page: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

# HR Entities - Add response models for nested objects
class PersonalDetailsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    citizenship: str
    gender: str
    birth_date: str
    age: str

class ContactDetailsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    cell_phone: str
    whatsapp_number: str
    email: str
    address: str

class EmploymentDetailsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    job_title: str
    team: str
    employment_type: str
    location: str

class EmployeeStatusResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    current_status: str
    on_leave_since: Optional[str] = None
    termination_date: Optional[str] = None
    termination_reason: Optional[str] = None

class DepartmentResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class EmployeeResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    user_id: str
    job_title_id: str
    access_role_ids: List[str]
    tenant_id: str
    store_id: str
    main_access_role_id: str
    hire_date: str
    salary: float
    first_name: str
    last_name: Optional[str] = None
    avatar_url: Optional[str] = None
    employee_id: Optional[str] = None
    full_name: Optional[str] = None
    middle_name: Optional[str] = None
    suffix: Optional[str] = None
    profile_photo_url: Optional[str] = None
    # CHANGED: Use response models for nested objects
    personal_details: Optional[PersonalDetailsResponse] = None
    contact_details: Optional[ContactDetailsResponse] = None
    employment_details: Optional[EmploymentDetailsResponse] = None
    status: Optional[EmployeeStatusResponse] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class ReservationResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    customer_id: str
    table_id: Optional[str] = None
    date_time: str
    number_of_guests: int
    status: str
    notes: Optional[str] = None
    store_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class ShiftResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    employee_id: str
    start: str
    end: str
    title: Optional[str] = None
    employee_name: Optional[str] = None
    color: Optional[str] = None
    active: Optional[bool] = True
    recurring: Optional[bool] = False
    updated_at: Optional[str] = None
    created_at: Optional[str] = None

class TimesheetResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    timesheet_id: str
    employee_id: str
    start_date: str
    end_date: str
    daily_hours: Dict[str, str]
    total_weekly_hours: str

class TimesheetEntryResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    employee_id: str
    clock_in: str
    clock_out: Optional[str] = None
    duration_minutes: Optional[int] = 0
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class TaxDetailsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    tax_year: str
    efiling_admin: str
    related_docs: str

class CompanyMetricsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    total_employees: int
    active_employees: int
    employees_on_leave: int
    terminated_employees: int
    full_time_employees: int
    part_time_employees: int
    contract_employees: int
    employee_invites: Dict[str, int]

class EmployeeInvitesResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    sent: int
    active: int
    require_attention: int

class CompanyResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    company_id: str
    name: str
    country: str
    tax_details: TaxDetailsResponse
    metrics: CompanyMetricsResponse

class StoreResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    address: str
    phone: str
    email: str
    tenant_id: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    location: Optional[str] = None
    manager_id: Optional[str] = None
    kiosk_user_id: Optional[str] = None

# Payroll Deduction Response
class PayrollDeductionResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    payroll_id: str
    type: str
    description: str
    amount: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PayrollResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    employee_id: str
    pay_period_start: str
    pay_period_end: str
    payment_cycle: str
    gross_pay: float
    tax_deductions: float
    net_pay: float
    status: str
    hours_worked: float
    overtime_hours: float
    overtime_rate: float
    # CHANGED: Use PayrollDeductionResponse for nested objects
    deductions: Optional[List[PayrollDeductionResponse]] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    store_id: str




# Other Entities
class TenantResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    email: str
    password: Optional[str] = None
    remember_token: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class DomainResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    tenant_id: str
    domain: str
    is_primary: bool = False
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class JobResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    queue: str
    payload: str
    attempts: int
    reserved_at: Optional[int] = None
    available_at: int
    created_at: int

class FailedJobResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    uuid: str
    connection: str
    queue: str
    payload: str
    exception: str
    failed_at: str

class PasswordResetResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    email: str
    token: str
    created_at: str

class UserResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    email: str
    username: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email_verified_at: Optional[str] = None
    remember_token: Optional[str] = None
    cashAccounts: Optional[List[Any]] = []
    cardAccounts: Optional[List[Any]] = []
    onlineAccounts: Optional[List[Any]] = []
    gpayAccounts: Optional[List[Any]] = []
    phonepeAccounts: Optional[List[Any]] = []
    amazonpayAccounts: Optional[List[Any]] = []
    locations: Optional[List[Any]] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PaymentResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    order_id: str
    payment_method_id: str
    amount: float
    payment_date: str
    transaction_id: Optional[str] = None
    status: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class StockResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    food_id: str
    quantity: int
    unit_id: str
    supplier_id: str
    last_restock_date: str
    expiration_date: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class StockAdjustmentResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    stock_id: str
    quantity_change: int
    reason: str
    adjustment_date: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class TaxResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    percentage: float
    is_active: bool = True
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class JobTitleResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    title: str
    description: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PaymentMethodResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: str
    is_active: bool = True
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class BrandResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class UnitResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    symbol: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class SupplierResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    contact_person: str
    phone: str
    email: str
    address: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class ContactMessageResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    email: str
    subject: str
    message: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class InventoryProductResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    description: Optional[str] = None
    sku: str
    unit_of_measure: str
    tenant_id: str
    unit_cost: float
    quantity_in_stock: float
    reorder_level: float
    supplier_id: Optional[str] = None
    inv_category_id: Optional[str] = None
    location_in_warehouse: Optional[str] = None
    last_restocked_at: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

# Payroll Entities
class PayrollDeductionResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    payroll_id: str
    type: str
    description: str
    amount: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class PayrollResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    employee_id: str
    pay_period_start: str
    pay_period_end: str
    payment_cycle: str
    gross_pay: float
    tax_deductions: float
    net_pay: float
    status: str
    hours_worked: float
    overtime_hours: float
    overtime_rate: float
    deductions: Optional[List[PayrollDeductionResponse]] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    store_id: str

class PayrollSettingsResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    store_id: str
    default_payment_cycle: str
    tax_rate: float
    overtime_multiplier: float
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

# Purchase Order and Goods Receipt
class PurchaseOrderItemResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    inventory_product_id: str
    quantity: float
    unit_of_measure: str
    unit_cost: float
    total_cost: float
    notes: Optional[str] = None

class PurchaseOrderResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    po_number: str
    supplier_id: str
    site_id: str
    status: str
    order_date: str
    expected_delivery_date: str
    total_amount: float
    ordered_by: str
    notes: Optional[str] = None
    items: List[PurchaseOrderItemResponse] = []
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class GoodsReceiptItemResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    inventory_product_id: str
    purchase_order_id: str
    received_quantity: float
    unit_of_measure: str
    condition: str
    notes: Optional[str] = None

class GoodsReceiptResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    receipt_number: str
    purchase_order_id: str
    store_id: str
    receipt_date: str
    received_by: str
    items: List[GoodsReceiptItemResponse] = []
    receiving_bin_id: Optional[str] = None
    status: Optional[str] = None
    received_items: Optional[List[Dict]] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class SiteResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    name: str
    address: str
    type: str
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

# Generic response for success messages
class SuccessResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    message: str

# Health check response
class HealthResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    status: str
    database: str

# Login response
class LoginResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    access_token: str
    token_type: str
    employee: EmployeeResponse

class ReportResponse(BaseModel):
    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )
    
    id: str
    user_id: str
    user_name: str
    user_role: str
    attempted_path: str
    attempts: int
    last_attempt_at: str
    created_at: Optional[str] = None

=== LOGGING MIDDLEWARE ===
# app/middleware/logging_middleware.py
import time
import json
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
from app.logging_config import get_logger
import uuid

logger = get_logger("api.middleware")

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Generate request ID
        request_id = str(uuid.uuid4())[:8]
        
        # Log request
        start_time = time.time()
        
        # Get client info
        client_host = request.client.host if request.client else "unknown"
        user_agent = request.headers.get("user-agent", "unknown")
        
        # Log request details
        logger.info(
            f"REQUEST [{request_id}] | {request.method} {request.url.path} | "
            f"Client: {client_host} | User-Agent: {user_agent}",
            extra={
                "request_id": request_id,
                "method": request.method,
                "path": request.url.path,
                "client_host": client_host,
                "user_agent": user_agent,
                "query_params": dict(request.query_params),
                "headers": dict(request.headers)
            }
        )
        
        # Process request
        try:
            response = await call_next(request)
            process_time = time.time() - start_time
            
            # Log response
            logger.info(
                f"RESPONSE [{request_id}] | Status: {response.status_code} | "
                f"Time: {process_time:.3f}s",
                extra={
                    "request_id": request_id,
                    "status_code": response.status_code,
                    "process_time": process_time,
                    "response_headers": dict(response.headers)
                }
            )
            
            return response
            
        except Exception as e:
            process_time = time.time() - start_time
            logger.error(
                f"ERROR [{request_id}] | Exception: {str(e)} | Time: {process_time:.3f}s",
                extra={
                    "request_id": request_id,
                    "error": str(e),
                    "process_time": process_time,
                    "exception_type": type(e).__name__
                },
                exc_info=True
            )
            raise

=== UTILS - DB LOGGER ===
# app/utils/db_logger.py
from app.logging_config import get_logger
from bson import ObjectId
import json
from datetime import datetime

logger = get_logger("api.database")

class DBLogger:
    @staticmethod
    def log_operation(operation: str, collection: str, query: dict = None, 
                     data: dict = None, result: any = None, error: str = None):
        """Log database operations"""
        
        log_data = {
            "db_operation": operation,  # Changed from "operation"
            "db_collection": collection,  # Changed from "collection"
            "db_query": DBLogger._sanitize_query(query) if query else None,
            "data_count": len(data) if isinstance(data, (list, dict)) else 1 if data else 0,
            "result_count": DBLogger._get_result_count(result),
            "db_error": error  # Changed from "error"
        }
        
        if error:
            logger.error(f"DB {operation.upper()} FAILED | Collection: {collection}", extra=log_data)
        else:
            logger.info(f"DB {operation.upper()} | Collection: {collection}", extra=log_data)
    
    @staticmethod
    def _sanitize_query(query: dict) -> dict:
        """Sanitize query for logging (remove sensitive data)"""
        if not query:
            return {}
        
        sanitized = {}
        for key, value in query.items():
            if isinstance(value, dict):
                sanitized[key] = DBLogger._sanitize_query(value)
            elif isinstance(value, ObjectId):
                sanitized[key] = f"ObjectId({str(value)})"
            elif key.lower() in ['password', 'token', 'secret', 'authorization']:
                sanitized[key] = "***REDACTED***"
            else:
                sanitized[key] = value
        return sanitized
    
    @staticmethod
    def _get_result_count(result: any) -> int:
        """Get count of results for logging"""
        if result is None:
            return 0
        elif isinstance(result, list):
            return len(result)
        elif hasattr(result, 'inserted_id'):  # Insert result
            return 1
        elif hasattr(result, 'modified_count'):  # Update result
            return getattr(result, 'modified_count', 0)
        elif hasattr(result, 'deleted_count'):  # Delete result
            return getattr(result, 'deleted_count', 0)
        elif isinstance(result, dict):
            return 1
        return 0

# Convenience functions
def log_find(collection: str, query: dict = None, result_count: int = 0):
    DBLogger.log_operation("find", collection, query, result=result_count)

def log_insert(collection: str, data: dict = None, result: any = None):
    DBLogger.log_operation("insert", collection, data=data, result=result)

def log_update(collection: str, query: dict = None, data: dict = None, result: any = None):
    DBLogger.log_operation("update", collection, query, data, result)

def log_delete(collection: str, query: dict = None, result: any = None):
    DBLogger.log_operation("delete", collection, query, result=result)

def log_error(collection: str, operation: str, error: str, query: dict = None):
    DBLogger.log_operation(operation, collection, query, error=error)

=== UTILS - LOG VIEWER ===
# app/utils/log_viewer.py
import os
from datetime import datetime, timedelta
from fastapi import APIRouter, Query
from app.models.response import StandardResponse
from app.utils.response_helpers import success_response
from app.logging_config import get_logger

logger = get_logger("api.log_viewer")

router = APIRouter(prefix="/api/logs", tags=["logs"])

@router.get("/", response_model=StandardResponse[dict])
async def get_logs(
    lines: int = Query(100, description="Number of lines to return"),
    level: str = Query(None, description="Filter by log level"),
    search: str = Query(None, description="Search term")
):
    """Get recent logs from the API log file"""
    try:
        log_file = "logs/api.log"
        if not os.path.exists(log_file):
            return success_response(data={"logs": [], "total": 0})
        
        with open(log_file, 'r') as f:
            all_lines = f.readlines()
        
        # Filter logs
        filtered_lines = []
        for line in all_lines[-lines:]:  # Get last N lines
            line = line.strip()
            if not line:
                continue
                
            # Apply filters
            if level and level.upper() not in line:
                continue
                
            if search and search.lower() not in line.lower():
                continue
                
            filtered_lines.append(line)
        
        # Return in chronological order (newest first)
        filtered_lines.reverse()
        
        return success_response(data={
            "logs": filtered_lines,
            "total": len(filtered_lines),
            "file": log_file
        })
        
    except Exception as e:
        logger.error(f"Error reading logs: {e}")
        return success_response(data={"logs": [], "total": 0, "error": str(e)})

@router.get("/stats", response_model=StandardResponse[dict])
async def get_log_stats():
    """Get log statistics"""
    try:
        log_file = "logs/api.log"
        if not os.path.exists(log_file):
            return success_response(data={"total_lines": 0, "file_size": 0})
        
        with open(log_file, 'r') as f:
            lines = f.readlines()
        
        # Count by level
        level_counts = {"INFO": 0, "WARNING": 0, "ERROR": 0, "DEBUG": 0}
        for line in lines:
            for level in level_counts.keys():
                if f"| {level} " in line:
                    level_counts[level] += 1
                    break
        
        return success_response(data={
            "total_lines": len(lines),
            "file_size": os.path.getsize(log_file),
            "level_counts": level_counts,
            "last_modified": datetime.fromtimestamp(os.path.getmtime(log_file)).isoformat()
        })
        
    except Exception as e:
        logger.error(f"Error getting log stats: {e}")
        return success_response(data={"error": str(e)})

=== UTILS - MONGO HELPERS ===
# app/utils/mongo_helpers.py
from typing import Any, Dict, List, Optional
from bson import ObjectId
from datetime import datetime, date  # FIXED: Added date import
from app.models.base import MongoModel

def transform_mongo_response(data: Any) -> Any:
    """
    Transform MongoDB response to match Pydantic models by converting _id to id.
    Handles nested documents and lists.
    """
    if isinstance(data, dict):
        data = data.copy()
        if '_id' in data:
            if isinstance(data['_id'], ObjectId):
                data['id'] = str(data['_id'])
            else:
                data['id'] = data['_id']
            del data['_id']
        # Recursively transform nested dictionaries and lists
        for key, value in data.items():
            data[key] = transform_mongo_response(value)
        return data
    elif isinstance(data, list):
        return [transform_mongo_response(item) for item in data]
    elif isinstance(data, ObjectId):
        return str(data)
    elif isinstance(data, (datetime, date)):  # FIXED: Now date is defined
        return data.isoformat()
    return data

def to_mongo_dict(model_instance: MongoModel, exclude_unset: bool = False) -> Dict[str, Any]:
    """
    Convert a model instance to a MongoDB dictionary, setting timestamps and removing immutable fields.
    """
    data = model_instance.to_dict(exclude_unset=exclude_unset)
    now_iso = datetime.utcnow().isoformat()
    
    # Remove immutable fields that shouldn't be included in MongoDB operations
    immutable_fields = ['_id', 'id']
    for field in immutable_fields:
        data.pop(field, None)
    
    if not exclude_unset:
        data["created_at"] = now_iso
    data["updated_at"] = now_iso
    return data

def to_mongo_update_dict(model_instance: MongoModel, exclude_unset: bool = True) -> Dict[str, Any]:
    """
    Convert a model instance to a MongoDB dictionary for updates, excluding immutable fields.
    """
    data = model_instance.to_dict(exclude_unset=exclude_unset)
    now_iso = datetime.utcnow().isoformat()
    
    # Remove immutable fields that shouldn't be updated
    immutable_fields = ['_id', 'id', 'created_at']
    for field in immutable_fields:
        data.pop(field, None)
    
    data["updated_at"] = now_iso
    return data

def prepare_response_data(data: Any) -> Any:
    """
    Prepare data for API response by transforming MongoDB format to API format.
    """
    return transform_mongo_response(data)

=== UTILS - RESPONSE HELPERS ===
# app/utils/response_helpers.py - UPDATED WITH LOGGING
from typing import Any, List, Dict, Optional
from fastapi import HTTPException
from app.utils.mongo_helpers import prepare_response_data
from app.logging_config import get_logger

logger = get_logger("api.response")

def success_response(
    data: Any = None, 
    message: str = "success", 
    code: int = 200
) -> Dict[str, Any]:
    """Helper function to create success responses with MongoDB data transformation"""
    transformed_data = prepare_response_data(data)
    
    # Log successful response
    logger.info(
        f"SUCCESS RESPONSE | Code: {code} | Message: {message}",
        extra={
            "response_code": code,
            "response_message": message,  # Changed from "message" to "response_message"
            "data_type": type(data).__name__,
            "data_count": len(transformed_data) if isinstance(transformed_data, list) else 1 if transformed_data else 0
        }
    )
    
    return {
        "code": code,
        "message": message,
        "data": transformed_data
    }

def paginated_response(
    data: Any,
    total: int,
    page: int,
    limit: int,
    message: str = "success",
    code: int = 200
) -> Dict[str, Any]:
    """Helper function for paginated responses with MongoDB data transformation"""
    transformed_data = prepare_response_data(data)
    total_pages = (total + limit - 1) // limit if limit > 0 else 1
    
    # Log paginated response
    logger.info(
        f"PAGINATED RESPONSE | Code: {code} | Total: {total} | Page: {page}/{total_pages}",
        extra={
            "response_code": code,
            "total_items": total,
            "page": page,
            "limit": limit,
            "total_pages": total_pages,
            "current_page_count": len(transformed_data)
        }
    )
    
    return {
        "code": code,
        "message": message,
        "data": transformed_data,
        "pagination": {
            "total": total,
            "page": page,
            "limit": limit,
            "total_pages": total_pages,
            "has_next": page < total_pages,
            "has_prev": page > 1
        }
    }

def error_response(
    message: str = "error",
    code: int = 400,
    details: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Helper function to create error responses"""
    
    # Log error response
    logger.warning(
        f"ERROR RESPONSE | Code: {code} | Message: {message}",
        extra={
            "error_code": code,
            "error_message": message,  # Changed from "message" to "error_message"
            "error_details": details
        }
    )
    
    return {
        "code": code,
        "message": message,
        "details": details
    }

def handle_http_exception(e: HTTPException) -> Dict[str, Any]:
    """Convert HTTPException to standard error response"""
    logger.warning(
        f"HTTP EXCEPTION | Status: {e.status_code} | Detail: {e.detail}",
        extra={
            "status_code": e.status_code,
            "detail": str(e.detail)
        }
    )
    return error_response(
        message=str(e.detail),
        code=e.status_code
    )

def handle_generic_exception(e: Exception) -> Dict[str, Any]:
    """Convert generic exception to standard error response"""
    logger.error(
        f"GENERIC EXCEPTION | Type: {type(e).__name__} | Message: {str(e)}",
        extra={
            "exception_type": type(e).__name__,
            "exception_message": str(e)
        },
        exc_info=True
    )
    return error_response(
        message=str(e),
        code=500
    )

=== REQUIREMENTS ===
annotated-types==0.7.0
anyio==4.10.0
bcrypt==4.3.0
click==8.3.0
dnspython==2.8.0
ecdsa==0.19.1
email-validator==2.3.0
fastapi==0.117.1
h11==0.16.0
httptools==0.6.4
idna==3.10
motor==3.7.1
passlib==1.7.4
pyasn1==0.6.1
pydantic==2.11.9
pydantic_core==2.33.2
PyJWT==2.10.1
pymongo==4.15.1
python-dotenv==1.1.1
python-jose==3.5.0
python-multipart==0.0.20
PyYAML==6.0.2
rsa==4.9.1
six==1.17.0
sniffio==1.3.1
starlette==0.48.0
typing-inspection==0.4.1
typing_extensions==4.15.0
uvicorn==0.36.0
uvloop==0.21.0
watchfiles==1.1.0
websockets==15.0.1
wheel==0.45.1


=== RUN SCRIPT ===
# run.py
import sys
import os

# Add the current directory to Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.main import app
import uvicorn

if __name__ == "__main__":
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)

