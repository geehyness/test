// src/app/pos/management/[entityName]/ShiftManagement.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Box,
  Center,
  Flex,
  Heading,
  Spinner,
  useToast,
  useDisclosure,
  Text,
  Alert,
  AlertIcon,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Button,
  HStack,
  Menu,
  MenuButton,
  MenuList,
  MenuItem,
  Badge,
} from "@chakra-ui/react";
import ShiftCalendar from "./ShiftManagementComponents/ShiftCalendar";
import EmployeeList from "./ShiftManagementComponents/EmployeeList";
import ShiftModal from "./ShiftManagementComponents/ShiftModal";
import ShiftUpdateModal from "./ShiftManagementComponents/ShiftUpdateModal";
import {
  getShifts,
  getEmployees,
  createShift,
  updateShift,
  deleteShift,
  getJobTitles,
} from "@/lib/api";
import { usePOSStore } from "@/lib/usePOSStore";
import moment from "moment";
import {
  Employee as EmployeeDetails,
  Shift as ShiftDetails,
} from "@/lib/config/entities";
import { logger } from "@/lib/logger";
import {
  FaSync,
  FaExclamationTriangle,
  FaCalendarCheck,
  FaUndo,
} from "react-icons/fa";

export interface Employee extends EmployeeDetails {
  name?: string;
  role: string; // Make required to match store interface
  color?: string;
  last_name: string; // Make required to match store interface
}

export interface Shift extends ShiftDetails {
  id: string;
  employee_id: string;
  start: Date;
  end: Date;
  employee_name?: string;
  color?: string;
  active?: boolean;
  recurring?: boolean;
  recurring_day?: number;
  recurrence_end_date?: Date;
  title?: string;
  created_at?: string;
  updated_at?: string;
  isDraft?: boolean; // New field for draft shifts
}

// New interfaces for enhanced draft management
interface DraftShift extends Omit<Shift, "id"> {
  id: string; // Can be draft IDs
  isDraft: boolean;
  published?: boolean;
  original_shift_id?: string; // For tracking which published shift this draft modifies
  marked_for_deletion?: boolean; // For tracking shifts to delete
  store_id?: string;
}

interface LocalStorageShifts {
  draftShifts: DraftShift[];
  lastSaved: string;
  version: string;
}

// Local storage keys - will be made store-specific in component
const DRAFT_SHIFTS_KEY = "draft_shifts";
const PUBLISHED_SHIFTS_KEY = "published_shifts";
const LAST_SYNC_KEY = "last_sync_timestamp";

type ScheduleMode = "published" | "draft";

export default function ShiftsPage() {
  const {
    shifts,
    setShifts,
    addShift,
    updateShift: updateStoreShift,
    deleteShift: deleteStoreShift,
    employees: storeEmployees,
    setEmployees,
  } = usePOSStore();

  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee | null>(
    null
  );
  const [selectedShift, setSelectedShift] = useState<Shift | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [scheduleMode, setScheduleMode] = useState<ScheduleMode>("published");
  const [draftShifts, setDraftShifts] = useState<DraftShift[]>([]);
  const [publishedShifts, setPublishedShifts] = useState<Shift[]>([]);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [mappedEmployees, setMappedEmployees] = useState<Employee[]>([]);
  const toast = useToast();
  const { isOpen, onOpen, onClose } = useDisclosure();

  // Store-specific local storage keys
  const getCurrentSessionContext = () => {
    // This should return the current store context
    // For now, using a default store ID
    return { store_id: "default-store" };
  };

  const DRAFT_SHIFTS_KEY_STORE = `${DRAFT_SHIFTS_KEY}_${
    getCurrentSessionContext().store_id
  }`;
  const PUBLISHED_SHIFTS_KEY_STORE = `${PUBLISHED_SHIFTS_KEY}_${
    getCurrentSessionContext().store_id
  }`;
  const SCHEDULE_MODE_KEY_STORE = `schedule_mode_${
    getCurrentSessionContext().store_id
  }`;

  // Load data from localStorage on component mount
  useEffect(() => {
    loadLocalShifts();
  }, []);

  // Save schedule mode to localStorage whenever it changes
  useEffect(() => {
    saveScheduleMode(scheduleMode);
  }, [scheduleMode]);

  // Load shifts from localStorage
  const loadLocalShifts = () => {
    try {
      // Load draft shifts
      let parsedDrafts: DraftShift[] = [];
      const storedDrafts = localStorage.getItem(DRAFT_SHIFTS_KEY_STORE);
      if (storedDrafts) {
        const draftsData: LocalStorageShifts = JSON.parse(storedDrafts);
        parsedDrafts = draftsData.draftShifts.map((draft) => ({
          ...draft,
          start: new Date(draft.start),
          end: new Date(draft.end),
          recurrence_end_date: draft.recurrence_end_date
            ? new Date(draft.recurrence_end_date)
            : undefined,
        }));
        setDraftShifts(parsedDrafts);
      }

      // Load published shifts
      const storedPublished = localStorage.getItem(PUBLISHED_SHIFTS_KEY_STORE);
      if (storedPublished) {
        const publishedData: LocalStorageShifts = JSON.parse(storedPublished);
        const parsedPublished = publishedData.draftShifts.map((shift) => ({
          ...shift,
          start: new Date(shift.start),
          end: new Date(shift.end),
          recurrence_end_date: shift.recurrence_end_date
            ? new Date(shift.recurrence_end_date)
            : undefined,
        }));
        console.log(
          "Loaded published shifts from localStorage:",
          parsedPublished.length
        );
        setPublishedShifts(parsedPublished);
      } else {
        console.log("No published shifts found in localStorage");
      }

      // Load schedule mode
      const storedMode = localStorage.getItem(SCHEDULE_MODE_KEY_STORE);
      if (
        storedMode &&
        (storedMode === "published" || storedMode === "draft")
      ) {
        setScheduleMode(storedMode as ScheduleMode);
        console.log("Loaded schedule mode from localStorage:", storedMode);
      }

      // If we have draft shifts but mode is published, switch to draft mode
      if (
        parsedDrafts.length > 0 &&
        (!storedMode || storedMode === "published")
      ) {
        // Use setTimeout to ensure state is updated
        setTimeout(() => {
          setScheduleMode("draft");
          console.log("Auto-switching to draft mode due to existing drafts");
        }, 0);
      }

      // If no localStorage data exists, publishedShifts will be empty and will be populated from API data
    } catch (error) {
      console.error("Error loading local shifts:", error);
      toast({
        title: "Error loading saved shifts",
        description: "Could not load shifts from local storage",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // Save draft shifts to localStorage
  const saveDraftShifts = (shifts: DraftShift[]) => {
    try {
      const storageData: LocalStorageShifts = {
        draftShifts: shifts,
        lastSaved: new Date().toISOString(),
        version: "1.0",
      };
      localStorage.setItem(DRAFT_SHIFTS_KEY_STORE, JSON.stringify(storageData));
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error("Error saving draft shifts:", error);
      toast({
        title: "Error saving draft",
        description: "Could not save changes to local storage",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // Save published shifts to localStorage
  const savePublishedShifts = (shifts: Shift[]) => {
    try {
      const storageData: LocalStorageShifts = {
        draftShifts: shifts.map((shift) => ({
          ...shift,
          isDraft: false,
          published: true,
        })),
        lastSaved: new Date().toISOString(),
        version: "1.0",
      };
      localStorage.setItem(
        PUBLISHED_SHIFTS_KEY_STORE,
        JSON.stringify(storageData)
      );
    } catch (error) {
      console.error("Error saving published shifts:", error);
    }
  };

  // Save schedule mode to localStorage
  const saveScheduleMode = (mode: ScheduleMode) => {
    try {
      localStorage.setItem(SCHEDULE_MODE_KEY_STORE, mode);
    } catch (error) {
      console.error("Error saving schedule mode:", error);
    }
  };

  // Get current shifts based on mode
  const getCurrentShifts = (): Shift[] => {
    if (scheduleMode === "draft") {
      // In draft mode, show both published shifts and draft shifts
      const allPublishedShifts =
        publishedShifts.length > 0
          ? publishedShifts
          : shifts.filter((s) => s.active);
      console.log(
        "Draft mode - Published shifts:",
        allPublishedShifts.length,
        "Draft shifts:",
        draftShifts.length
      );
      return [...allPublishedShifts, ...draftShifts];
    }
    // In published mode, show published shifts from localStorage or fall back to API data
    const currentShifts =
      publishedShifts.length > 0
        ? publishedShifts
        : shifts.filter((s) => s.active);
    console.log("Published mode - Current shifts:", currentShifts.length);
    return currentShifts;
  };

  useEffect(() => {
    logger.info("ShiftManagement: useEffect triggered. Starting data load.");
    const loadData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [fetchedShifts, fetchedEmployees, jobTitles] = await Promise.all([
          getShifts(),
          getEmployees(),
          getJobTitles(),
        ]);

        logger.info("ShiftManagement: Raw data from API received.");

        // Create a job title lookup map
        const jobTitleMap = new Map();
        jobTitles.forEach((job) => {
          jobTitleMap.set(job.id, job.title);
        });

        // Map employees with proper job title names
        const mappedEmployees: Employee[] = fetchedEmployees.map((emp) => ({
          ...emp,
          name: `${emp.first_name} ${emp.last_name}`,
          role:
            jobTitleMap.get(emp.job_title_id) || emp.job_title_id || "Unknown",
          color: emp.color || "#3182CE",
        }));

        // Process shifts with proper date handling and employee enrichment
        const shiftsWithNamesAndDates: Shift[] = fetchedShifts
          .map((shift: any) => {
            try {
              const employee = mappedEmployees.find(
                (e) => e.id === shift.employee_id
              );

              // Handle date conversion safely
              let startDate: Date;
              let endDate: Date;
              let recurrenceEndDate: Date | undefined;

              try {
                // Handle both string dates and Date objects
                startDate =
                  shift.start instanceof Date
                    ? shift.start
                    : new Date(shift.start);
                endDate =
                  shift.end instanceof Date ? shift.end : new Date(shift.end);

                if (shift.recurrence_end_date) {
                  recurrenceEndDate =
                    shift.recurrence_end_date instanceof Date
                      ? shift.recurrence_end_date
                      : new Date(shift.recurrence_end_date);
                }

                // Validate dates
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                  throw new Error("Invalid date");
                }
              } catch (dateError) {
                logger.error(
                  "Invalid date format, using current date as fallback",
                  shift
                );
                startDate = new Date();
                endDate = new Date();
                startDate.setHours(9, 0, 0, 0);
                endDate.setHours(17, 0, 0, 0);
              }

              // Calculate recurring day from start date
              const recurringDay = shift.recurring
                ? startDate.getDay()
                : undefined;

              return {
                ...shift,
                id: shift.id,
                employee_id: shift.employee_id,
                start: startDate,
                end: endDate,
                recurrence_end_date: recurrenceEndDate,
                employee_name: employee ? employee.name : "Unknown",
                employee_role: employee?.role,
                color: employee?.color || "#3182CE",
                recurring: shift.recurring || false,
                recurring_day: recurringDay,
                active: shift.active !== false,
                title: shift.title || `Shift - ${employee?.name || "Unknown"}`,
                created_at: shift.created_at,
                updated_at: shift.updated_at,
                isDraft: false,
              };
            } catch (error) {
              logger.error(
                "ShiftManagement: Error processing shift, skipping.",
                shift,
                error
              );
              return null;
            }
          })
          .filter(Boolean) as Shift[];

        setShifts(shiftsWithNamesAndDates);
        setEmployees(mappedEmployees);
        setMappedEmployees(mappedEmployees);

        // Only initialize published shifts with API data if no localStorage data exists
        const activeShifts = shiftsWithNamesAndDates.filter((s) => s.active);
        console.log("API shifts loaded:", activeShifts.length, "shifts");

        // Check if we already have published shifts from localStorage
        if (publishedShifts.length === 0) {
          console.log("No localStorage published shifts found, using API data");
          setPublishedShifts(activeShifts);
          savePublishedShifts(activeShifts);
        } else {
          console.log(
            "Using existing localStorage published shifts:",
            publishedShifts.length
          );
        }

        // Save sync timestamp
        localStorage.setItem(LAST_SYNC_KEY, Date.now().toString());

        logger.info("ShiftManagement: Data successfully set in Zustand store.");
      } catch (error: any) {
        logger.error("ShiftManagement: Failed to load data", error);
        setError(error.message || "Failed to load shift data.");
        toast({
          title: "Failed to load data.",
          description:
            error.message ||
            "Could not fetch shifts or employees. Please try again.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [setShifts, setEmployees, toast]);

  // Enhanced update shift function
  const handleUpdateShift = async (
    shiftId: string,
    updates: Partial<Shift>
  ): Promise<{ success: boolean; error?: string }> => {
    try {
      setIsProcessing(true);

      // Check if it's a draft shift
      const draftIndex = draftShifts.findIndex((s) => s.id === shiftId);
      if (draftIndex !== -1) {
        // Update draft shift
        const updatedDrafts = draftShifts.map((s) =>
          s.id === shiftId
            ? { ...s, ...updates, updated_at: new Date().toISOString() }
            : s
        );
        setDraftShifts(updatedDrafts);
        saveDraftShifts(updatedDrafts);
        setHasUnsavedChanges(true);
        setScheduleMode("draft"); // Auto-switch to draft mode

        toast({
          title: "Draft shift updated.",
          description: "Changes are saved locally.",
          status: "success",
          duration: 3000,
          isClosable: true,
        });
        onClose();
        return { success: true };
      }

      // For published shifts, handle recurring shift logic
      const publishedShift = publishedShifts.find((s) => s.id === shiftId);
      if (publishedShift) {
        const isRecurringShift = publishedShift.recurring;
        const isChangingRecurring =
          updates.recurring !== undefined &&
          updates.recurring !== publishedShift.recurring;
        const isChangingDates = updates.start || updates.end;

        if (
          (isRecurringShift && (isChangingRecurring || isChangingDates)) ||
          (!isRecurringShift && updates.recurring === true)
        ) {
          // Handle recurring shift modification
          // For recurring shifts, always create a new shift starting from the edited date
          const editDate = updates.start
            ? new Date(updates.start)
            : new Date(publishedShift.start);
          const newShiftData = {
            ...publishedShift,
            ...updates,
            start: editDate, // Ensure the new shift starts from the edited date
            end: updates.end
              ? new Date(updates.end)
              : new Date(
                  editDate.getTime() +
                    (publishedShift.end.getTime() -
                      publishedShift.start.getTime())
                ),
            id: `draft-${Date.now()}-${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            original_shift_id: shiftId,
            isDraft: true,
            published: false,
            updated_at: new Date().toISOString(),
          };

          // Create draft for the new shift
          const updatedDrafts = [...draftShifts, newShiftData];
          setDraftShifts(updatedDrafts);
          saveDraftShifts(updatedDrafts);
          setHasUnsavedChanges(true);

          // Only create end recurring draft if the original shift was recurring
          if (isRecurringShift) {
            // Create draft to end the original recurring series
            const endDate = new Date(editDate);
            endDate.setDate(endDate.getDate() - 1); // End the day before the new shift starts

            const endRecurringDraft: DraftShift = {
              ...publishedShift,
              id: `end-recurring-${Date.now()}-${Math.random()
                .toString(36)
                .substr(2, 9)}`,
              original_shift_id: shiftId,
              isDraft: true,
              published: false,
              recurrence_end_date: endDate,
              updated_at: new Date().toISOString(),
            };

            const finalDrafts = [...updatedDrafts, endRecurringDraft];
            setDraftShifts(finalDrafts);
            saveDraftShifts(finalDrafts);
          }

          setScheduleMode("draft"); // Auto-switch to draft mode

          const message = isRecurringShift
            ? "New shift created from edited date forward. Original series will end before the edited date."
            : "New recurring shift created starting from the edited date.";

          toast({
            title: "Recurring shift updated.",
            description: message,
            status: "success",
            duration: 5000,
            isClosable: true,
          });
        } else {
          // Regular update for non-recurring shifts or non-date changes
          const draftCopy: DraftShift = {
            ...publishedShift,
            ...updates,
            id: `draft-${Date.now()}-${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            original_shift_id: shiftId,
            isDraft: true,
            published: false,
            updated_at: new Date().toISOString(),
          };

          const updatedDrafts = [...draftShifts, draftCopy];
          setDraftShifts(updatedDrafts);
          saveDraftShifts(updatedDrafts);
          setHasUnsavedChanges(true);
          setScheduleMode("draft"); // Auto-switch to draft mode

          toast({
            title: "Shift updated as draft.",
            description:
              "Changes are saved locally. Click Publish to apply online.",
            status: "success",
            duration: 5000,
            isClosable: true,
          });
        }
        onClose();
        return { success: true };
      }

      return { success: false, error: "Shift not found" };
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to update shift", error);
      toast({
        title: "Failed to update shift.",
        description:
          error.message || "An error occurred while updating the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      return { success: false, error: error.message };
    } finally {
      setIsProcessing(false);
    }
  };

  // Publish all draft shifts to the backend
  const publishSchedule = async () => {
    if (draftShifts.length === 0) {
      toast({
        title: "No changes to publish",
        description: "There are no draft shifts to publish.",
        status: "info",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    setIsProcessing(true);
    try {
      const shiftsToCreate: DraftShift[] = [];
      const shiftsToUpdate: DraftShift[] = [];
      const shiftsToDelete: DraftShift[] = [];

      // Categorize draft shifts
      draftShifts.forEach((draft) => {
        if (draft.marked_for_deletion) {
          shiftsToDelete.push(draft);
        } else if (draft.original_shift_id) {
          if (draft.recurrence_end_date) {
            // This is an end recurring series operation
            shiftsToUpdate.push(draft);
          } else {
            // This is a regular update
            shiftsToUpdate.push(draft);
          }
        } else {
          shiftsToCreate.push(draft);
        }
      });

      // Process deletions first
      for (const draft of shiftsToDelete) {
        if (draft.original_shift_id) {
          await deleteShift("shifts", draft.original_shift_id);
        }
      }

      // Process updates
      for (const draft of shiftsToUpdate) {
        if (draft.original_shift_id) {
          const {
            isDraft,
            published,
            original_shift_id,
            marked_for_deletion,
            ...updateData
          } = draft;
          await updateShift(draft.original_shift_id, updateData);
        }
      }

      // Process creations
      const createPromises = shiftsToCreate.map(async (draft) => {
        const {
          isDraft,
          published,
          original_shift_id,
          marked_for_deletion,
          ...shiftData
        } = draft;
        return await createShift(shiftData);
      });

      await Promise.all(createPromises);

      // Update local state
      const newlyPublishedShifts = [...publishedShifts];

      // Remove deleted shifts
      shiftsToDelete.forEach((draft) => {
        if (draft.original_shift_id) {
          const index = newlyPublishedShifts.findIndex(
            (s) => s.id === draft.original_shift_id
          );
          if (index !== -1) {
            newlyPublishedShifts.splice(index, 1);
          }
        }
      });

      // Update existing shifts
      shiftsToUpdate.forEach((draft) => {
        if (draft.original_shift_id) {
          const index = newlyPublishedShifts.findIndex(
            (s) => s.id === draft.original_shift_id
          );
          if (index !== -1) {
            newlyPublishedShifts[index] = {
              ...draft,
              id: draft.original_shift_id,
              isDraft: false,
            };
          }
        }
      });

      // Add new shifts
      newlyPublishedShifts.push(
        ...shiftsToCreate.map((draft) => ({ ...draft, isDraft: false }))
      );

      // Clear drafts and update published shifts
      setDraftShifts([]);
      setPublishedShifts(newlyPublishedShifts);
      saveDraftShifts([]);
      savePublishedShifts(newlyPublishedShifts);
      setHasUnsavedChanges(false);
      setScheduleMode("published");
      saveScheduleMode("published");

      toast({
        title: "Schedule published successfully!",
        description: `${draftShifts.length} changes have been published online.`,
        status: "success",
        duration: 5000,
        isClosable: true,
      });
    } catch (error: any) {
      logger.error("Failed to publish schedule:", error);
      toast({
        title: "Failed to publish schedule",
        description:
          error.message || "An error occurred while publishing shifts.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  // Reset to published schedule
  const resetToPublished = () => {
    setDraftShifts([]);
    saveDraftShifts([]);
    setHasUnsavedChanges(false);
    setScheduleMode("published");
    saveScheduleMode("published");

    toast({
      title: "Reset to published schedule",
      description: "All draft changes have been discarded.",
      status: "info",
      duration: 3000,
      isClosable: true,
    });
  };

  // Enhanced add shift function - always save to local storage first
  const handleAddShift = async (newShiftData: {
    employeeId: string;
    start: Date;
    end: Date;
    recurs: boolean;
  }) => {
    if (!selectedEmployee) return;

    try {
      setIsProcessing(true);
      const { employeeId, start, end, recurs } = newShiftData;

      // Always add as draft in local storage
      const newDraftShift: DraftShift = {
        id: `draft-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        employee_id: employeeId,
        start: start,
        end: end,
        recurring: recurs,
        recurring_day: recurs ? start.getDay() : undefined,
        active: true,
        title: `Shift - ${selectedEmployee.name}`,
        employee_name: selectedEmployee.name,
        color: selectedEmployee.color || "#3182CE",
        store_id: selectedEmployee.store_id || "default-store",
        isDraft: true,
        published: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      const updatedDrafts = [...draftShifts, newDraftShift];
      setDraftShifts(updatedDrafts);
      saveDraftShifts(updatedDrafts);
      setHasUnsavedChanges(true);
      setScheduleMode("draft"); // Auto-switch to draft mode

      toast({
        title: "Shift added as draft.",
        description: "Changes are saved locally. Click Publish to save online.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });

      onClose();
    } catch (error: any) {
      console.error("‚ùå Failed to add shift:", error);
      toast({
        title: "Failed to add shift.",
        description:
          error.message || "An error occurred while saving the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  // Enhanced delete function
  const handleDeleteShift = async (
    shiftId: string
  ): Promise<{ success: boolean; error?: string }> => {
    try {
      setIsProcessing(true);

      // Check if it's a draft shift
      const draftIndex = draftShifts.findIndex((s) => s.id === shiftId);
      if (draftIndex !== -1) {
        // Remove from drafts
        const updatedDrafts = draftShifts.filter((s) => s.id !== shiftId);
        setDraftShifts(updatedDrafts);
        saveDraftShifts(updatedDrafts);
        setHasUnsavedChanges(true);

        toast({
          title: "Draft shift deleted.",
          status: "success",
          duration: 5000,
          isClosable: true,
        });
        onClose();
        return { success: true };
      }

      // For published shifts, handle recurring shift deletion
      const publishedShift = publishedShifts.find((s) => s.id === shiftId);
      if (publishedShift) {
        if (publishedShift.recurring) {
          // For recurring shifts, end the series before the selected date
          const endDate = new Date(publishedShift.start);
          endDate.setDate(endDate.getDate() - 1); // End the day before the selected shift

          const endRecurringDraft: DraftShift = {
            ...publishedShift,
            id: `end-recurring-${Date.now()}-${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            original_shift_id: shiftId,
            isDraft: true,
            published: false,
            recurrence_end_date: endDate,
            updated_at: new Date().toISOString(),
          };

          const updatedDrafts = [...draftShifts, endRecurringDraft];
          setDraftShifts(updatedDrafts);
          saveDraftShifts(updatedDrafts);
          setHasUnsavedChanges(true);
          setScheduleMode("draft"); // Auto-switch to draft mode

          toast({
            title: "Recurring shift series ended.",
            description:
              "Future occurrences will be cancelled. Past shifts remain.",
            status: "success",
            duration: 5000,
            isClosable: true,
          });
        } else {
          // For non-recurring shifts, mark for deletion
          const deleteDraft: DraftShift = {
            ...publishedShift,
            id: `delete-${Date.now()}-${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            original_shift_id: shiftId,
            isDraft: true,
            marked_for_deletion: true,
            published: false,
            updated_at: new Date().toISOString(),
          };

          const updatedDrafts = [...draftShifts, deleteDraft];
          setDraftShifts(updatedDrafts);
          saveDraftShifts(updatedDrafts);
          setHasUnsavedChanges(true);
          setScheduleMode("draft"); // Auto-switch to draft mode

          toast({
            title: "Shift marked for deletion.",
            description: "Click Publish to confirm deletion online.",
            status: "success",
            duration: 5000,
            isClosable: true,
          });
        }
        onClose();
        return { success: true };
      }

      return { success: false, error: "Shift not found" };
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to delete shift", error);
      toast({
        title: "Failed to delete shift.",
        description:
          error.message || "An error occurred while deleting the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      return { success: false, error: error.message };
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSelectEmployee = (employee: Employee) => {
    setSelectedEmployee(employee);
    setSelectedShift(null);
    onOpen();
  };

  const handleEditShift = (shift: Shift) => {
    setSelectedShift(shift);
    const employee = storeEmployees.find((emp) => emp.id === shift.employee_id);
    if (employee) {
      // Convert store employee to local Employee type
      const localEmployee: Employee = {
        id: employee.id,
        first_name: employee.first_name,
        last_name: employee.last_name,
        name: `${employee.first_name} ${employee.last_name}`,
        role: employee.role || "Unknown",
        color: employee.color || "#3182CE",
        user_id: "",
        job_title_id: "",
        access_role_ids: [],
        tenant_id: "",
        store_id: "",
        main_access_role_id: "",
        hire_date: "",
        salary: 0,
      };
      setSelectedEmployee(localEmployee);
    } else {
      setSelectedEmployee(null);
    }
    onOpen();
  };

  const handleModalClose = () => {
    setSelectedEmployee(null);
    setSelectedShift(null);
    onClose();
  };

  const refreshData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [fetchedShifts, fetchedEmployees, jobTitles] = await Promise.all([
        getShifts(),
        getEmployees(),
        getJobTitles(),
      ]);

      // Process data same as in useEffect...
      // ... (same data processing logic as in useEffect)

      // Save sync timestamp
      localStorage.setItem(LAST_SYNC_KEY, Date.now().toString());

      toast({
        title: "Data refreshed",
        status: "success",
        duration: 3000,
        isClosable: true,
      });
    } catch (error: any) {
      setError(error.message || "Failed to refresh data.");
      toast({
        title: "Refresh failed",
        description: error.message || "Failed to refresh data.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Calculate statistics
  const currentShifts = getCurrentShifts();
  const activeShifts = currentShifts.filter((s) => s.active);
  const todayShifts = activeShifts.filter((shift) =>
    moment(shift.start).isSame(moment(), "day")
  );
  const upcomingShifts = activeShifts.filter((shift) =>
    moment(shift.start).isAfter(moment())
  );
  const recurringShifts = activeShifts.filter((shift) => shift.recurring);
  const draftShiftCount = draftShifts.length;

  if (isLoading) {
    return (
      <Center minH="400px">
        <Spinner size="xl" />
        <Text ml={4}>Loading shift data...</Text>
      </Center>
    );
  }

  return (
    <Box bg="gray.50" minH="100vh" display="flex" flexDirection="column">
      <Flex
        as="header"
        position="sticky"
        top="0"
        bg="white"
        p={5}
        borderBottom="1px"
        borderColor="gray.200"
        justifyContent="space-between"
        alignItems="center"
        boxShadow="sm"
        zIndex={1000}
      >
        <HStack spacing={4}>
          <Heading as="h1" size="xl">
            Shift Management
          </Heading>
          <Badge
            colorScheme={scheduleMode === "draft" ? "orange" : "green"}
            fontSize="lg"
            px={3}
            py={1}
          >
            {scheduleMode === "draft" ? "DRAFT MODE" : "PUBLISHED"}
          </Badge>
          {hasUnsavedChanges && (
            <Badge colorScheme="red" fontSize="lg" px={3} py={1}>
              UNSAVED CHANGES
            </Badge>
          )}
        </HStack>

        <HStack spacing={4}>
          {/* Schedule Mode Toggle */}
          <Menu>
            <MenuButton as={Button} variant="outline">
              {scheduleMode === "draft" ? "Draft Mode" : "Published Mode"}
            </MenuButton>
            <MenuList>
              <MenuItem
                onClick={() => setScheduleMode("published")}
                isDisabled={scheduleMode === "published"}
              >
                Published Schedule
              </MenuItem>
              <MenuItem
                onClick={() => setScheduleMode("draft")}
                isDisabled={scheduleMode === "draft"}
              >
                Draft Schedule
              </MenuItem>
            </MenuList>
          </Menu>

          <Button
            leftIcon={<FaSync />}
            onClick={refreshData}
            isLoading={isProcessing}
            colorScheme="blue"
            variant="outline"
          >
            Refresh
          </Button>
        </HStack>
      </Flex>

      {error && (
        <Alert status="error" mx={5} mt={5} borderRadius="md">
          <AlertIcon />
          {error}
        </Alert>
      )}

      {/* Statistics Overview */}
      <Box p={5} flex="0 0 auto">
        <SimpleGrid columns={5} spacing={4}>
          <Stat bg="white" p={4} borderRadius="md" shadow="sm">
            <StatLabel>Total Shifts</StatLabel>
            <StatNumber>{activeShifts.length}</StatNumber>
            <StatHelpText>
              {scheduleMode === "draft"
                ? `${draftShiftCount} drafts`
                : "Published"}
            </StatHelpText>
          </Stat>

          <Stat bg="white" p={4} borderRadius="md" shadow="sm">
            <StatLabel>Today's Shifts</StatLabel>
            <StatNumber color="blue.500">{todayShifts.length}</StatNumber>
            <StatHelpText>Scheduled for today</StatHelpText>
          </Stat>

          <Stat bg="white" p={4} borderRadius="md" shadow="sm">
            <StatLabel>Upcoming Shifts</StatLabel>
            <StatNumber color="green.500">{upcomingShifts.length}</StatNumber>
            <StatHelpText>Future shifts</StatHelpText>
          </Stat>

          <Stat bg="white" p={4} borderRadius="md" shadow="sm">
            <StatLabel>Recurring</StatLabel>
            <StatNumber color="purple.500">{recurringShifts.length}</StatNumber>
            <StatHelpText>Weekly recurring</StatHelpText>
          </Stat>

          <Stat bg="white" p={4} borderRadius="md" shadow="sm">
            <StatLabel>Draft Shifts</StatLabel>
            <StatNumber color="orange.500">{draftShiftCount}</StatNumber>
            <StatHelpText>Unsaved changes</StatHelpText>
          </Stat>
        </SimpleGrid>
      </Box>

      {/* Main content area */}
      <Box
        p={5}
        flex="1"
        display="flex"
        flexDirection="column"
        minHeight="0"
        height="100vh" // Changed to 100vh
        overflow="hidden" // Added to prevent overall scrolling
      >
        <Flex
          direction={{ base: "column", md: "row" }}
          gap={6}
          flex="1"
          minHeight="0"
          height="100%" // Changed to 100%
        >
          {/* Employee List - Fixed width with scroll */}
          <Box
            flex="0 0 280px" // Slightly increased width for better readability
            bg="white"
            p={6}
            rounded="md"
            shadow="sm"
            display="flex"
            flexDirection="column"
            height="100%"
            minHeight="0"
            overflow="hidden" // Added to contain scrolling
          >
            <EmployeeList
              employees={mappedEmployees || []}
              onEmployeeClick={handleSelectEmployee}
            />
          </Box>

          {/* Calendar - Takes remaining space */}
          <Box
            flex="1"
            bg="white"
            p={6}
            rounded="md"
            shadow="sm"
            minWidth="0"
            display="flex"
            flexDirection="column"
            height="100%"
            minHeight="0"
            overflow="hidden" // Added to contain scrolling
          >
            <Heading as="h2" size="lg" mb={4}>
              Shift Calendar {scheduleMode === "draft" && "(Draft)"}
            </Heading>
            {activeShifts.length === 0 ? (
              <Center h="100%" flexDirection="column">
                {" "}
                // Changed to 100%
                <FaExclamationTriangle size={48} color="#CBD5E0" />
                <Text color="gray.500" mt={4}>
                  No shifts scheduled. Click on an employee to create a shift.
                </Text>
                <Button
                  mt={4}
                  colorScheme="blue"
                  onClick={() =>
                    mappedEmployees.length > 0 &&
                    handleSelectEmployee(mappedEmployees[0])
                  }
                  isDisabled={mappedEmployees.length === 0}
                >
                  Create Your First Shift
                </Button>
              </Center>
            ) : (
              <Box flex="1" minHeight="0" height="100%">
                {" "}
                <ShiftCalendar
                  shifts={currentShifts}
                  employees={mappedEmployees || []}
                  onUpdateShift={handleUpdateShift}
                  onDeleteShift={handleDeleteShift}
                  onSelectShift={handleEditShift}
                  scheduleMode={scheduleMode}
                  draftShifts={draftShifts}
                  onPublishSchedule={publishSchedule}
                  onResetToPublished={resetToPublished}
                  hasUnsavedChanges={hasUnsavedChanges}
                />
              </Box>
            )}
          </Box>
        </Flex>
      </Box>

      {/* Modals */}
      {selectedShift ? (
        <ShiftUpdateModal
          isOpen={isOpen}
          onClose={handleModalClose}
          selectedShift={selectedShift}
          employee={selectedEmployee}
          onUpdateShift={async (shiftId: string, updates: Partial<Shift>) => {
            await handleUpdateShift(shiftId, updates);
          }}
          onDeleteShift={async (shiftId: string) => {
            const result = await handleDeleteShift(shiftId);
            return result;
          }}
          isLoading={isProcessing}
          scheduleMode={scheduleMode}
        />
      ) : (
        <ShiftModal
          isOpen={isOpen}
          onClose={handleModalClose}
          employee={selectedEmployee}
          existingShifts={currentShifts.filter(
            (s) => s.employee_id === selectedEmployee?.id && s.active
          )}
          onAddShift={handleAddShift}
          scheduleMode={scheduleMode}
        />
      )}
    </Box>
  );
}
// Shared role color utilities for consistent coloring across components

export interface Employee {
  id: string;
  name?: string;
  role: string;
  color?: string;
  first_name: string;
  last_name: string;
}

// Generate consistent colors based on role names
export const generateRoleColors = (employees: Employee[]): Record<string, string> => {
  const roleColors: Record<string, string> = {
    default: "#718096", // Gray for unknown roles
  };

  // Get all unique roles from employees
  const uniqueRoles = Array.from(
    new Set(employees.map((emp) => emp.role).filter(Boolean))
  );

  // Predefined color palette for common roles
  const colorPalette = [
    "#3182CE", // Blue
    "#38A169", // Green
    "#E53E3E", // Red
    "#D69E2E", // Yellow
    "#805AD5", // Purple
    "#DD6B20", // Orange
    "#319795", // Teal
    "#D53F8C", // Pink
    "#4A5568", // Gray blue
    "#0BC5EA", // Cyan
  ];

  // Assign colors to roles
  uniqueRoles.forEach((role, index) => {
    if (role) {
      // Use predefined color if available, otherwise generate from palette
      roleColors[role] = colorPalette[index % colorPalette.length];
    }
  });

  return roleColors;
};

// Get color based on employee role
export const getRoleColor = (
  roleColors: Record<string, string>,
  role?: string
): string => {
  if (!role) return roleColors.default;
  return roleColors[role] || roleColors.default;
};

// Convert hex color to Chakra UI color scheme
export const getChakraColorScheme = (hexColor: string): string => {
  const colorMap: Record<string, string> = {
    "#3182CE": "blue",
    "#38A169": "green", 
    "#E53E3E": "red",
    "#D69E2E": "yellow",
    "#805AD5": "purple",
    "#DD6B20": "orange",
    "#319795": "teal",
    "#D53F8C": "pink",
    "#4A5568": "gray",
    "#0BC5EA": "cyan",
    "#718096": "gray",
  };
  
  return colorMap[hexColor] || "gray";
};
// src/app/pos/management/[entityName]/components/ShiftCalendar.tsx

"use client";

import React, { useEffect, useMemo, useState } from "react";
import moment from "moment";
import {
  Box,
  HStack,
  IconButton,
  Text,
  useToast,
  Badge,
  VStack,
  Button,
  Flex,
} from "@chakra-ui/react";
import { CloseIcon, ChevronLeftIcon, ChevronRightIcon } from "@chakra-ui/icons";
import { Employee, Shift } from "../ShiftManagement";
import dynamic from "next/dynamic";
import { momentLocalizer, Views, View } from "react-big-calendar";
import withDragAndDrop, {
  EventInteractionArgs,
} from "react-big-calendar/lib/addons/dragAndDrop";
import "react-big-calendar/lib/css/react-big-calendar.css";
import "react-big-calendar/lib/addons/dragAndDrop/styles.css";
import { logger } from "@/lib/logger";
import { FaCalendarCheck, FaUndo } from "react-icons/fa";
import { generateRoleColors, getRoleColor } from "./roleColors";

// Update the CalendarEvent interface
interface CalendarEvent extends Omit<Shift, "start" | "end"> {
  start: Date;
  end: Date;
  originalShiftId: string;
  employeeRole?: string;
  isDraft?: boolean;
}

// Dynamically import the Calendar component and wrap it
const Calendar = dynamic(
  async () => {
    const { Calendar: RbcCalendar } = await import("react-big-calendar");
    momentLocalizer(moment);
    const DndCalendar = withDragAndDrop<CalendarEvent, object>(RbcCalendar);
    return DndCalendar;
  },
  { ssr: false, loading: () => <Text>Loading calendar...</Text> }
);

interface ShiftCalendarProps {
  shifts: Shift[];
  employees: Employee[];
  onUpdateShift: (
    shiftId: string,
    updates: Partial<Shift>
  ) => Promise<{ success: boolean; error?: string }>;
  onDeleteShift: (
    shiftId: string
  ) => Promise<{ success: boolean; error?: string }>;
  onSelectShift: (shift: Shift) => void;
  scheduleMode: "published" | "draft";
  draftShifts: any[];
  onPublishSchedule: () => void;
  onResetToPublished: () => void;
  hasUnsavedChanges: boolean;
}

// Legend for role colors
const RoleLegend = ({ employees }: { employees: Employee[] }) => {
  const dynamicRoleColors = generateRoleColors(employees);
  const uniqueRoles = Array.from(
    new Set(employees.map((emp) => emp.role).filter(Boolean))
  );

  return (
    <Box mt={4} p={3} bg="gray.50" borderRadius="md">
      <Text fontWeight="bold" mb={2} fontSize="sm">
        Role Legend:
      </Text>
      <HStack spacing={3} flexWrap="wrap">
        {uniqueRoles.map((role) => (
          <HStack key={role} spacing={1}>
            <Box w={3} h={3} bg={dynamicRoleColors[role]} borderRadius="sm" />
            <Text fontSize="xs">{role}</Text>
          </HStack>
        ))}
        {uniqueRoles.length === 0 && (
          <Text fontSize="xs" color="gray.500">
            No roles assigned
          </Text>
        )}
      </HStack>
    </Box>
  );
};

// Custom Toolbar Component with Navigation Controls
const CustomToolbar = ({
  onNavigate,
  label,
  onView,
  scheduleMode,
  draftShifts,
  onPublishSchedule,
  onResetToPublished,
  hasUnsavedChanges,
}: {
  onNavigate: (action: "PREV" | "NEXT" | "TODAY") => void;
  label: string;
  onView: (view: View) => void;
  scheduleMode: "published" | "draft";
  draftShifts: any[];
  onPublishSchedule: () => void;
  onResetToPublished: () => void;
  hasUnsavedChanges: boolean;
}) => {
  return (
    <Flex
      justify="space-between"
      align="center"
      mb={2}
      p={2}
      bg="gray.50"
      borderRadius="md"
      flexWrap="wrap"
      gap={2}
      height="60px"
    >
      <HStack spacing={1}>
        <Button
          size="xs"
          onClick={() => onNavigate("TODAY")}
          colorScheme="blue"
          variant="outline"
        >
          Today
        </Button>
        <HStack spacing={0}>
          <IconButton
            aria-label="Previous"
            icon={<ChevronLeftIcon />}
            size="xs"
            onClick={() => onNavigate("PREV")}
          />
          <IconButton
            aria-label="Next"
            icon={<ChevronRightIcon />}
            size="xs"
            onClick={() => onNavigate("NEXT")}
          />
        </HStack>
      </HStack>

      <Text fontWeight="bold" fontSize="md">
        {label}
      </Text>

      <HStack spacing={1}>
        {/* View buttons */}
        <Button
          size="xs"
          onClick={() => onView(Views.MONTH)}
          colorScheme="blue"
          variant="outline"
        >
          Month
        </Button>
        <Button
          size="xs"
          onClick={() => onView(Views.WEEK)}
          colorScheme="blue"
          variant="outline"
        >
          Week
        </Button>
        <Button
          size="xs"
          onClick={() => onView(Views.DAY)}
          colorScheme="blue"
          variant="outline"
        >
          Day
        </Button>

        {/* Publish buttons - only show in draft mode */}
        {scheduleMode === "draft" && (
          <>
            <Button
              leftIcon={<FaCalendarCheck />}
              onClick={onPublishSchedule}
              colorScheme="green"
              size="xs"
              isDisabled={draftShifts.length === 0}
            >
              Publish ({draftShifts.length})
            </Button>
            <Button
              leftIcon={<FaUndo />}
              onClick={onResetToPublished}
              variant="outline"
              size="xs"
              isDisabled={!hasUnsavedChanges}
            >
              Reset
            </Button>
          </>
        )}
      </HStack>
    </Flex>
  );
};

export default function ShiftCalendar({
  shifts,
  employees,
  onUpdateShift,
  onDeleteShift,
  onSelectShift,
  scheduleMode,
  draftShifts,
  onPublishSchedule,
  onResetToPublished,
  hasUnsavedChanges,
}: ShiftCalendarProps) {
  const toast = useToast();
  const [date, setDate] = useState<Date>(moment().startOf("month").toDate());
  const [view, setView] = useState<View>(Views.MONTH);
  const [currentView, setCurrentView] = useState<View>(Views.MONTH);

  // In ShiftCalendar.tsx - Update the event generation for recurrence
  const events = useMemo(() => {
    console.log("ShiftCalendar: Reformatting shifts for calendar...");
    const calendarEvents: CalendarEvent[] = [];

    // Generate dynamic role colors based on current employees
    const dynamicRoleColors = generateRoleColors(employees);

    const now = moment();
    const futureDate = moment().add(1, "year");

    shifts.forEach((shift) => {
      const employee = employees.find((emp) => emp.id === shift.employee_id);
      const employeeRole = employee?.role;
      const eventColor = getRoleColor(dynamicRoleColors, employeeRole);

      if (shift.recurring && shift.active) {
        // Handle recurring shifts with proper end date
        const recurrenceEnd = shift.recurrence_end_date
          ? moment(shift.recurrence_end_date)
          : futureDate;

        let current = moment(shift.start);

        // Generate occurrences until recurrence end date or future date
        while (
          current.isBefore(recurrenceEnd) &&
          current.isBefore(futureDate)
        ) {
          const startDateTime = current.clone().set({
            hour: moment(shift.start).hour(),
            minute: moment(shift.start).minute(),
          });
          const endDateTime = current.clone().set({
            hour: moment(shift.end).hour(),
            minute: moment(shift.end).minute(),
          });

          // Only add if this occurrence is before the recurrence end date
          if (startDateTime.isBefore(recurrenceEnd)) {
            calendarEvents.push({
              ...shift,
              id: `${shift.id}-${current.format("YYYYMMDD")}`,
              originalShiftId: shift.id,
              start: startDateTime.toDate(),
              end: endDateTime.toDate(),
              title: `${shift.employee_name} (Recurring)`,
              color: eventColor,
              employeeRole,
            });
          }

          current.add(1, "week");
        }
      } else if (shift.active) {
        // Non-recurring shifts
        calendarEvents.push({
          ...shift,
          originalShiftId: shift.id,
          start: new Date(shift.start),
          end: new Date(shift.end),
          color: eventColor,
          employeeRole,
        });
      }
    });

    console.log("ShiftCalendar: Generated events:", calendarEvents);
    return calendarEvents;
  }, [shifts, employees]);

  const handleEventDrop = async (data: EventInteractionArgs<CalendarEvent>) => {
    const { event, start, end } = data;
    if (!event.originalShiftId) {
      toast({
        title: "Error",
        description: "Cannot update a shift without a valid ID.",
        status: "error",
        duration: 4000,
        isClosable: true,
      });
      return;
    }

    const updates: Partial<Shift> = {
      start: start instanceof Date ? start : new Date(start as string),
      end: end instanceof Date ? end : new Date(end as string),
      employee_id: event.employee_id,
    };

    await onUpdateShift(event.originalShiftId, updates);
  };

  const handleSelectEvent = (event: CalendarEvent) => {
    const originalShift = shifts.find((s) => s.id === event.originalShiftId);
    if (originalShift) {
      const clickedShift: Shift = {
        ...originalShift,
        start: event.start,
        end: event.end,
      };
      onSelectShift(clickedShift);
    }
  };

  // Navigation handlers
  const handleNavigate = (action: "PREV" | "NEXT" | "TODAY") => {
    let newDate = moment(date);

    switch (action) {
      case "PREV":
        if (currentView === Views.MONTH) {
          newDate = newDate.subtract(1, "month");
        } else if (currentView === Views.WEEK) {
          newDate = newDate.subtract(1, "week");
        } else {
          newDate = newDate.subtract(1, "day");
        }
        break;
      case "NEXT":
        if (currentView === Views.MONTH) {
          newDate = newDate.add(1, "month");
        } else if (currentView === Views.WEEK) {
          newDate = newDate.add(1, "week");
        } else {
          newDate = newDate.add(1, "day");
        }
        break;
      case "TODAY":
        newDate = moment();
        break;
    }

    setDate(newDate.toDate());
  };

  // Enhanced event style getter for proper week/day view positioning
  const eventStyleGetter = (event: CalendarEvent) => {
    const isMonthView = currentView === Views.MONTH;

    if (isMonthView) {
      return {
        style: {
          backgroundColor: event.color || "#718096",
          borderRadius: "4px",
          opacity: event.isDraft ? 0.7 : 1,
          fontWeight: "bold",
          border: event.isDraft
            ? "2px dashed #000"
            : "1px solid rgba(0,0,0,0.2)",
          borderColor: event.isDraft ? "#000" : "rgba(0,0,0,0.2)",
          height: "auto",
          fontSize: "12px",
        },
      };
    }

    // For week/day views, use the default calendar positioning
    return {
      style: {
        backgroundColor: event.color || "#718096",
        borderRadius: "4px",
        opacity: event.isDraft ? 0.7 : 1,
        fontWeight: "bold",
        border: event.isDraft ? "2px dashed #000" : "1px solid rgba(0,0,0,0.2)",
        borderColor: event.isDraft ? "#000" : "rgba(0,0,0,0.2)",
        fontSize: "12px",
      },
    };
  };

  // Custom Event component with swapped text orientation
  const CustomEvent = ({ event }: { event: CalendarEvent }) => {
    const isMonthView = currentView === Views.MONTH;
    const isWeekView = currentView === Views.WEEK;
    const isDayView = currentView === Views.DAY;
    const isTimeBasedView = isWeekView || isDayView;
    const isDraft = event.isDraft;

    // Calculate event duration in hours for time-based views
    const durationHours =
      moment(event.end).diff(moment(event.start), "minutes") / 60;
    const isVeryShortEvent = durationHours < 1;
    const isShortEvent = durationHours < 2;
    const hasSpaceForDetails = durationHours >= 1.5;

    if (isMonthView) {
      // MONTH VIEW: Display like week/day view (horizontal text)
      return (
        <Box
          width="100%"
          height="100%"
          bg={event.color}
          borderRadius="4px"
          _hover={{ bg: `${event.color}DD` }}
          border={isDraft ? "2px dashed" : "1px solid"}
          borderColor={isDraft ? "black" : "rgba(0,0,0,0.2)"}
          p={1}
          display="flex"
          flexDirection="column"
          justifyContent="center"
          overflow="hidden"
        >
          {/* Employee name - always show */}
          <Text
            fontSize="11px"
            fontWeight="bold"
            color="#333"
            noOfLines={1}
            lineHeight="1.2"
            textAlign="center"
          >
            {event.employee_name || "Unknown"}
          </Text>

          {/* Time range - show if there's space */}
          {hasSpaceForDetails && (
            <Text
              fontSize="9px"
              color="#333"
              noOfLines={1}
              lineHeight="1.1"
              opacity={0.9}
              textAlign="center"
            >
              {moment(event.start).format("HH:mm")}
            </Text>
          )}

          {/* Role badge - show if there's space */}
          {hasSpaceForDetails && event.employeeRole && (
            <Badge
              fontSize="8px"
              colorScheme="gray"
              variant="solid"
              opacity={0.8}
              mt={0.5}
              color="#333"
              bg="rgba(255, 255, 255, 0.7)"
              lineHeight="1"
              height="10px"
              noOfLines={1}
            >
              {event.employeeRole}
            </Badge>
          )}
        </Box>
      );
    }

    // WEEK/DAY VIEW: Display like month view (rotated text)
    return (
      <Box
        p={0}
        height="100%"
        bg={event.color}
        borderRadius="4px"
        _hover={{ bg: `${event.color}CC` }}
        overflow="hidden"
        display="flex"
        alignItems="center"
        justifyContent="center"
        border={isDraft ? "2px dashed" : "1px solid"}
        borderColor={isDraft ? "black" : "rgba(0,0,0,0.2)"}
      >
        <VStack
          spacing={0}
          align="center"
          justify="center"
          width="100%"
          height="100%"
          transform="rotate(-90deg)"
          transformOrigin="center"
        >
          <Text
            fontSize="12px"
            fontWeight="bold"
            color="#333"
            textAlign="center"
            noOfLines={1}
            title={event.employee_name}
            lineHeight="1.2"
          >
            {event.employee_name || "Unknown"}
          </Text>

          {!isVeryShortEvent && (
            <Text
              fontSize="10px"
              color="#333"
              textAlign="center"
              noOfLines={1}
              lineHeight="1.1"
              opacity={0.9}
            >
              {moment(event.start).format("HH:mm")} -{" "}
              {moment(event.end).format("HH:mm")}
            </Text>
          )}

          {event.employeeRole && !isVeryShortEvent && (
            <Badge
              fontSize="9px"
              colorScheme="gray"
              variant="solid"
              opacity={0.8}
              mt={0.5}
              color="#333"
              bg="rgba(255, 255, 255, 0.7)"
              lineHeight="1"
              height="12px"
            >
              {event.employeeRole}
            </Badge>
          )}

          {event.recurring && !isVeryShortEvent && (
            <Badge
              fontSize="8px"
              colorScheme="green"
              variant="solid"
              opacity={0.9}
              mt={0.5}
              color="#333"
              bg="rgba(255, 255, 255, 0.7)"
              lineHeight="1"
              height="10px"
            >
              Recurring
            </Badge>
          )}

          {isDraft && !isVeryShortEvent && (
            <Badge
              fontSize="8px"
              colorScheme="orange"
              variant="solid"
              opacity={0.9}
              mt={0.5}
              lineHeight="1"
              height="10px"
            >
              Draft
            </Badge>
          )}
        </VStack>
      </Box>
    );
  };

  // Custom Month View Day Component to add "View Day" link
  const CustomMonthViewDay = ({ date }: { date: Date }) => {
    const dayEvents = events.filter((event) =>
      moment(event.start).isSame(date, "day")
    );

    if (dayEvents.length === 0) return null;

    return (
      <Box position="absolute" bottom="2px" right="2px" zIndex={2}>
        <Button
          size="xs"
          variant="ghost"
          colorScheme="blue"
          fontSize="10px"
          height="16px"
          minH="16px"
          p={1}
          onClick={(e) => {
            e.stopPropagation();
            setDate(date);
            setView(Views.DAY);
            setCurrentView(Views.DAY);
          }}
          _hover={{ bg: "blue.50" }}
        >
          View Day
        </Button>
      </Box>
    );
  };

  const handleViewChange = (newView: View) => {
    setCurrentView(newView);
    setView(newView);
  };

  // Function to calculate scroll position based on first shift
  const getScrollToTime = (
    currentDate: Date,
    currentView: View,
    calendarEvents: CalendarEvent[]
  ): Date => {
    if (currentView === Views.MONTH) {
      return new Date();
    }

    let viewEvents: CalendarEvent[] = [];

    if (currentView === Views.DAY) {
      viewEvents = calendarEvents.filter((event) =>
        moment(event.start).isSame(currentDate, "day")
      );
    } else if (currentView === Views.WEEK) {
      const weekStart = moment(currentDate).startOf("week");
      const weekEnd = moment(currentDate).endOf("week");
      viewEvents = calendarEvents.filter((event) =>
        moment(event.start).isBetween(weekStart, weekEnd, undefined, "[]")
      );
    }

    if (viewEvents.length > 0) {
      const earliestEvent = viewEvents.reduce((earliest, event) =>
        event.start < earliest.start ? event : earliest
      );

      const scrollTime = moment(earliestEvent.start).subtract(30, "minutes");
      return scrollTime.toDate();
    }

    return moment(currentDate).set({ hour: 8, minute: 0 }).toDate();
  };

  // Function to manually scroll to first shift
  const scrollToFirstShift = (
    currentDate: Date,
    currentView: View,
    calendarEvents: CalendarEvent[]
  ) => {
    if (currentView === Views.MONTH) return;

    setTimeout(() => {
      const scrollTime = getScrollToTime(
        currentDate,
        currentView,
        calendarEvents
      );
      const timeContent = document.querySelector(".rbc-time-content");
      if (timeContent) {
        const targetHour = moment(scrollTime).hour();
        const targetMinute = moment(scrollTime).minute();
        const slotHeight = 30;
        const totalMinutes = targetHour * 60 + targetMinute;
        const scrollPosition = (totalMinutes / 30) * slotHeight;
        timeContent.scrollTop = Math.max(0, scrollPosition - 100);
      }
    }, 150);
  };

  // Auto-scroll when component mounts or when date/view changes
  useEffect(() => {
    if (view !== Views.MONTH) {
      scrollToFirstShift(date, view, events);
    }
  }, [date, view, events]);

  // Format label based on current view and date
  const getLabel = () => {
    const currentMoment = moment(date);

    switch (currentView) {
      case Views.MONTH:
        return currentMoment.format("MMMM YYYY");
      case Views.WEEK:
        const weekStart = currentMoment.startOf("week");
        const weekEnd = currentMoment.endOf("week");
        return `${weekStart.format("MMM D")} - ${weekEnd.format(
          "MMM D, YYYY"
        )}`;
      case Views.DAY:
        return currentMoment.format("dddd, MMMM D, YYYY");
      default:
        return currentMoment.format("MMMM YYYY");
    }
  };

  return (
    <Box height="100vh" display="flex" flexDirection="column" overflow="hidden">
      {/* Custom Toolbar with publish buttons */}
      <CustomToolbar
        onNavigate={handleNavigate}
        label={getLabel()}
        onView={handleViewChange}
        scheduleMode={scheduleMode}
        draftShifts={draftShifts}
        onPublishSchedule={onPublishSchedule}
        onResetToPublished={onResetToPublished}
        hasUnsavedChanges={hasUnsavedChanges}
      />

      <Box
        borderWidth="1px"
        borderRadius="md"
        p={4}
        bg="white"
        flex="1"
        minHeight="0"
        height="calc(100vh - 140px)"
        overflow="hidden"
        sx={{
          // Target the calendar's toolbar and headers to make them sticky
          ".rbc-toolbar": {
            display: "none",
          },
          ".rbc-time-header": {
            position: "sticky",
            top: "0",
            zIndex: 9,
            bg: "white",
          },
          ".rbc-time-content": {
            overflow: "auto !important",
          },
          // CRITICAL: Remove the "more" button and show all events
          ".rbc-show-more": {
            display: "none !important",
          },

          // MONTH VIEW SPECIFIC STYLES (horizontal text - like week/day view)
          ".rbc-month-view": {
            ".rbc-row-bg": {
              overflow: "visible !important",
            },
            ".rbc-day-slot": {
              overflow: "visible !important",
              position: "relative", // For positioning the "View Day" button
            },
            ".rbc-month-row": {
              overflow: "visible !important",
              minHeight: "120px !important", // Increased height for better readability
            },
            ".rbc-row-content": {
              overflow: "visible !important",
            },
            ".rbc-date-cell": {
              overflow: "visible !important",
              fontSize: "14px !important", // Larger date text
              fontWeight: "bold",
              padding: "4px 6px",
            },
            // Events with horizontal text
            ".rbc-event": {
              overflow: "hidden !important",
              fontSize: "12px !important", // Larger text
              minHeight: "24px !important", // More height for readability
              margin: "2px !important",
              padding: "2px 4px !important",
              lineHeight: "1.3 !important",
              border: "1px solid rgba(0,0,0,0.2) !important",
              borderRadius: "4px !important",
            },
            // Make month view cells taller to fit more events
            ".rbc-day-bg": {
              minHeight: "120px",
            },
            // Compact month view - make rows taller
            ".rbc-row": {
              minHeight: "120px",
              maxHeight: "none !important",
            },
            // Make event labels more readable
            ".rbc-event-label": {
              fontSize: "11px !important",
              display: "none !important",
            },
            ".rbc-event-content": {
              fontSize: "12px !important",
              lineHeight: "1.3 !important",
              padding: "0 !important",
            },
          },

          // WEEK/DAY VIEW SPECIFIC STYLES - IMPROVED FOR TIME-BASED POSITIONING
          ".rbc-time-view, .rbc-agenda-view": {
            // Ensure proper scrolling and layout
            ".rbc-time-header": {
              position: "sticky",
              top: "0",
              zIndex: 10,
              bg: "white",
            },
            ".rbc-time-content": {
              overflow: "auto !important",
              position: "relative",
            },
            // Ensure day columns have proper width and can expand
            ".rbc-day-slot": {
              position: "relative",
              minHeight: "1200px", // Ensure day has enough height for all time slots
              minWidth: "150px", // Minimum width for day columns
            },
            ".rbc-time-slot": {
              minHeight: "40px", // Consistent time slot height
              borderTop: "1px solid #e6e6e6 !important",
              fontSize: "12px", // Larger time labels
            },
            // Events with proper time-based positioning
            ".rbc-event": {
              position: "absolute !important",
              // Let calendar calculate height based on start/end times
              height: "auto !important",
              minHeight: "25px !important", // Minimum height for visibility
              fontSize: "12px !important",
              padding: "2px 4px !important",
              margin: "0 !important",
              border: "1px solid rgba(0,0,0,0.2) !important",
              borderRadius: "4px !important",
              lineHeight: "1.2 !important",
              overflow: "hidden !important",
              // Calendar handles top and bottom positioning based on time
              top: "0 !important",
              bottom: "0 !important",
              zIndex: 5,
            },
            // Proper event content styling for week/day views
            ".rbc-event-content": {
              fontSize: "12px !important",
              lineHeight: "1.2 !important",
              padding: "0 !important",
              whiteSpace: "normal !important",
              overflow: "hidden",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              height: "100%",
            },
            ".rbc-event-label": {
              fontSize: "11px !important",
              display: "block !important",
            },
            // Ensure events are properly positioned and can be side by side
            ".rbc-day-slot .rbc-events-container": {
              margin: "0 !important",
              height: "100% !important",
              position: "relative",
            },
            ".rbc-timeslot-group": {
              minHeight: "40px",
              borderBottom: "none !important",
            },
            // Allow events to be positioned side by side with proper overlap handling
            ".rbc-day-slot .rbc-event": {
              position: "absolute !important",
              // Calendar sets top and height based on start/end times
              // Width and left positioning handled by overlap algorithm
            },
            // Enhanced overlap handling for multiple events
            ".rbc-event[data-overlap-index='0']": {
              width: "95% !important",
              left: "2.5% !important",
              zIndex: 5,
            },
            ".rbc-event[data-overlap-index='1']": {
              width: "90% !important",
              left: "5% !important",
              zIndex: 4,
            },
            ".rbc-event[data-overlap-index='2']": {
              width: "85% !important",
              left: "7.5% !important",
              zIndex: 3,
            },
            ".rbc-event[data-overlap-index='3']": {
              width: "80% !important",
              left: "10% !important",
              zIndex: 2,
            },
            ".rbc-event[data-overlap-index='4']": {
              width: "75% !important",
              left: "12.5% !important",
              zIndex: 1,
            },
            // For many overlapping events, enable horizontal scrolling
            ".rbc-time-header-content": {
              minWidth: "800px", // Allow horizontal expansion
            },
            ".rbc-time-content": {
              minWidth: "800px", // Allow horizontal expansion
            },
            ".rbc-time-view": {
              overflowX: "auto !important",
            },
          },

          // Make resize handles more visible
          ".rbc-addons-dnd-resize-ns-anchor": {
            height: "10px",
            "&:first-of-type": {
              top: "-5px",
            },
            "&:last-of-type": {
              bottom: "-5px",
            },
          },
          ".rbc-addons-dnd-resize-ew-anchor": {
            width: "10px",
            "&:first-of-type": {
              left: "-5px",
            },
            "&:last-of-type": {
              right: "-5px",
            },
          },

          // Ensure calendar takes full height
          ".rbc-calendar": {
            height: "100% !important",
            minHeight: "100% !important",
          },
          ".rbc-month-view": {
            height: "100% !important",
            minHeight: "100% !important",
          },
          ".rbc-time-view": {
            height: "100% !important",
            minHeight: "100% !important",
            overflow: "auto !important",
          },
          // Remove any limits on event display
          ".rbc-month-view .rbc-row": {
            flexWrap: "wrap !important",
          },
          ".rbc-allday-cell": {
            display: "none !important",
          },

          // Custom scrollbars for better UX
          "::-webkit-scrollbar": {
            width: "8px",
            height: "8px",
          },
          "::-webkit-scrollbar-track": {
            background: "#f1f1f1",
            borderRadius: "4px",
          },
          "::-webkit-scrollbar-thumb": {
            background: "#c1c1c1",
            borderRadius: "4px",
          },
          "::-webkit-scrollbar-thumb:hover": {
            background: "#a8a8a8",
          },
        }}
      >
        <Calendar
          localizer={momentLocalizer(moment)}
          events={events.map((event, index) => ({
            ...event,
            // Add data attribute for overlapping positioning
            "data-overlap-index": index % 5, // Simple modulo for positioning
          }))}
          date={date}
          view={view}
          onNavigate={(newDate) => {
            setDate(newDate);
            setTimeout(() => {
              scrollToFirstShift(newDate, view, events);
            }, 100);
          }}
          onView={(newView) => {
            handleViewChange(newView);
            setTimeout(() => {
              scrollToFirstShift(date, newView, events);
            }, 100);
          }}
          views={[Views.MONTH, Views.WEEK, Views.DAY]}
          selectable
          onEventDrop={handleEventDrop}
          onEventResize={handleEventDrop}
          onSelectEvent={handleSelectEvent}
          resizable
          step={30} // 30-minute intervals for better time precision
          timeslots={2}
          showMultiDayTimes
          draggableAccessor={() => true}
          eventPropGetter={eventStyleGetter}
          components={{
            event: CustomEvent,
            month: {
              dateHeader: ({ date, label }) => (
                <Box position="relative">
                  <Text fontSize="14px" fontWeight="bold">
                    {label}
                  </Text>
                  <CustomMonthViewDay date={date} />
                </Box>
              ),
            },
          }}
          dayLayoutAlgorithm="overlap" // Use overlap algorithm for side-by-side display
          popup
          scrollToTime={getScrollToTime(date, view, events)}
          min={moment().set({ hour: 6, minute: 0 }).toDate()} // Start at 6 AM
          max={moment().set({ hour: 22, minute: 0 }).toDate()} // End at 10 PM
        />
      </Box>

      {/* Dynamic Legend for role colors */}
      <RoleLegend employees={employees} />
    </Box>
  );
}
// Create a new component ShiftForm.tsx
"use client";

import React, { useState } from 'react';
import {
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalFooter,
    ModalBody,
    ModalCloseButton,
    Button,
    FormControl,
    FormLabel,
    Input,
    Select,
    VStack,
} from '@chakra-ui/react';
import { Employee } from './ShiftManagement';

interface ShiftFormProps {
    isOpen: boolean;
    onClose: () => void;
    employees: Employee[];
    onSubmit: (shiftData: { employeeId: string; start: string; end: string }) => void;
}

const ShiftForm: React.FC<ShiftFormProps> = ({ isOpen, onClose, employees, onSubmit }) => {
    const [employeeId, setEmployeeId] = useState('');
    const [start, setStart] = useState('');
    const [end, setEnd] = useState('');

    const handleSubmit = () => {
        onSubmit({ employeeId, start, end });
        onClose();
        // Reset form
        setEmployeeId('');
        setStart('');
        setEnd('');
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <ModalOverlay />
            <ModalContent>
                <ModalHeader>Add New Shift</ModalHeader>
                <ModalCloseButton />
                <ModalBody>
                    <VStack spacing={4}>
                        <FormControl isRequired>
                            <FormLabel>Employee</FormLabel>
                            <Select
                                placeholder="Select employee"
                                value={employeeId}
                                onChange={(e) => setEmployeeId(e.target.value)}
                            >
                                {employees.map(emp => (
                                    <option key={emp.id} value={emp.id}>
                                        {emp.name} - {emp.role}
                                    </option>
                                ))}
                            </Select>
                        </FormControl>
                        <FormControl isRequired>
                            <FormLabel>Start Time</FormLabel>
                            <Input
                                type="datetime-local"
                                value={start}
                                onChange={(e) => setStart(e.target.value)}
                            />
                        </FormControl>
                        <FormControl isRequired>
                            <FormLabel>End Time</FormLabel>
                            <Input
                                type="datetime-local"
                                value={end}
                                onChange={(e) => setEnd(e.target.value)}
                            />
                        </FormControl>
                    </VStack>
                </ModalBody>
                <ModalFooter>
                    <Button variant="ghost" mr={3} onClick={onClose}>
                        Cancel
                    </Button>
                    <Button colorScheme="blue" onClick={handleSubmit}>
                        Save Shift
                    </Button>
                </ModalFooter>
            </ModalContent>
        </Modal>
    );
};

export default ShiftForm;// src/app/pos/management/[entityName]/components/ShiftUpdateModal.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  FormControl,
  FormLabel,
  Input,
  VStack,
  HStack,
  useToast,
  Checkbox,
  Box,
  Text,
} from "@chakra-ui/react";
import {
  Employee as EmployeeDetails,
  Shift as ShiftDetails,
} from "../ShiftManagement";
import moment from "moment";
import { logger } from "@/lib/logger";

// Update the modal props interfaces
interface ShiftUpdateModalProps {
  isOpen: boolean;
  onClose: () => void;
  onUpdateShift: (shiftId: string, updates: Partial<Shift>) => Promise<void>;
  onDeleteShift: (
    shiftId: string
  ) => Promise<{ success: boolean; error?: string }>;
  selectedShift: Shift | null;
  employee: Employee | null;
  isLoading: boolean;
  scheduleMode: ScheduleMode;
}

const ShiftUpdateModal: React.FC<ShiftUpdateModalProps> = ({
  isOpen,
  onClose,
  onUpdateShift,
  onDeleteShift,
  selectedShift,
  employee,
}) => {
  const [startDate, setStartDate] = useState("");
  const [startTime, setStartTime] = useState("09:00");
  const [endTime, setEndTime] = useState("17:00");
  const [recurs, setRecurs] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const toast = useToast();

  // Use useEffect to update state when a new shift is selected
  useEffect(() => {
    if (selectedShift) {
      // Split the datetime into date and time components
      const startMoment = moment(selectedShift.start);
      setStartDate(startMoment.format("YYYY-MM-DD"));
      setStartTime(startMoment.format("HH:mm"));

      const endMoment = moment(selectedShift.end);
      setEndTime(endMoment.format("HH:mm"));

      setRecurs(selectedShift.recurring || false);
    }
  }, [selectedShift]);

  const handleUpdate = async () => {
    if (!selectedShift) return;

    // Combine date and time
    const newStartTime = moment(`${startDate}T${startTime}`);
    const newEndTime = moment(`${startDate}T${endTime}`);

    if (
      !newStartTime.isValid() ||
      !newEndTime.isValid() ||
      newEndTime.isSameOrBefore(newStartTime)
    ) {
      toast({
        title: "Invalid shift times.",
        description: "End time must be after start time.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    setIsSaving(true);
    try {
      await onUpdateShift(selectedShift.id, {
        start: newStartTime.toDate(),
        end: newEndTime.toDate(),
        recurring: recurs,
        recurring_day: recurs ? newStartTime.day() : undefined,
      });

      toast({
        title: "Shift Updated",
        description: `Successfully updated the shift for ${employee?.name}.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });

      onClose();
    } catch (error) {
      logger.error("ShiftUpdateModal", "Update failed:", error);
      toast({
        title: "Error Updating Shift",
        description: "Failed to update shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!selectedShift) return;
    setIsSaving(true);
    try {
      const result = await onDeleteShift(selectedShift.id);
      if (result.success) {
        toast({
          title: "Shift deleted.",
          description: "Shift has been set as inactive.",
          status: "success",
          duration: 5000,
          isClosable: true,
        });
        onClose();
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      logger.error("ShiftUpdateModal", "Delete failed:", error);
      toast({
        title: "Error Deleting Shift",
        description: "Failed to delete shift.",
        status: "error",
        duration: 4000,
        isClosable: true,
      });
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="lg">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Edit Shift for {employee?.name}</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4} align="stretch">
            <FormControl>
              <FormLabel>Shift Date</FormLabel>
              <Input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
              />
            </FormControl>

            <HStack>
              <FormControl>
                <FormLabel>Start Time</FormLabel>
                <Input
                  type="time"
                  value={startTime}
                  onChange={(e) => setStartTime(e.target.value)}
                />
              </FormControl>
              <FormControl>
                <FormLabel>End Time</FormLabel>
                <Input
                  type="time"
                  value={endTime}
                  onChange={(e) => setEndTime(e.target.value)}
                />
              </FormControl>
            </HStack>

            <FormControl>
              <Checkbox
                isChecked={recurs}
                onChange={(e) => setRecurs(e.target.checked)}
                colorScheme="green"
              >
                Recur weekly{" "}
                {selectedShift?.recurring && (
                  <Text as="span" color="green.500">
                    (Currently recurring)
                  </Text>
                )}
              </Checkbox>
            </FormControl>

            {selectedShift && (
              <Box mt={4} p={3} bg="gray.50" borderRadius="md">
                <Text fontWeight="bold" mb={2}>
                  Current Shift Details:
                </Text>
                <Text fontSize="sm">
                  {moment(selectedShift.start).format("MMM Do, YYYY")} -{" "}
                  {moment(selectedShift.start).format("HH:mm")} to{" "}
                  {moment(selectedShift.end).format("HH:mm")}
                  {selectedShift.recurring && (
                    <Text as="span" ml={2} color="green.500">
                      (Recurring)
                    </Text>
                  )}
                </Text>
                {selectedShift.recurring && (
                  <Box mt={2} p={2} bg="blue.50" borderRadius="md">
                    <Text fontSize="xs" color="blue.700">
                      <strong>Note:</strong> This is a recurring shift. Any
                      changes will create a new shift from the edited date
                      forward, and the original series will end before the
                      edited date.
                    </Text>
                  </Box>
                )}
                {!selectedShift.recurring && recurs && (
                  <Box mt={2} p={2} bg="green.50" borderRadius="md">
                    <Text fontSize="xs" color="green.700">
                      <strong>Note:</strong> Turning on recurring will create a
                      new recurring shift starting from the edited date,
                      repeating weekly until deleted or edited.
                    </Text>
                  </Box>
                )}
              </Box>
            )}
          </VStack>
        </ModalBody>
        <ModalFooter>
          <Button variant="ghost" mr={3} onClick={onClose}>
            Cancel
          </Button>
          <Button
            colorScheme="red"
            onClick={handleDelete}
            isLoading={isSaving}
            mr={3}
          >
            Delete Shift
          </Button>
          <Button
            colorScheme="blue"
            onClick={handleUpdate}
            isLoading={isSaving}
          >
            Save Changes
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default ShiftUpdateModal;
"use client";

import React, { useState } from "react";
import {
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  Button,
  FormControl,
  FormLabel,
  Input,
  Select,
  VStack,
  HStack,
  Text,
  useToast,
  Box,
  IconButton,
  Checkbox,
} from "@chakra-ui/react";
import { DeleteIcon } from "@chakra-ui/icons";
import { Employee, Shift } from "../ShiftManagement";
import moment from "moment";
import { logger } from "@/lib/logger";

interface ShiftModalProps {
  isOpen: boolean;
  onClose: () => void;
  employee: Employee | null;
  existingShifts: Shift[];
  onAddShift: (newShift: {
    employeeId: string;
    start: Date;
    end: Date;
    recurs: boolean;
  }) => Promise<any>;
  scheduleMode: ScheduleMode;
}

interface ShiftDay {
  date: Date;
  startTime: string;
  endTime: string;
  recurs: boolean;
}

const ShiftModal: React.FC<ShiftModalProps> = ({
  isOpen,
  onClose,
  employee,
  existingShifts,
  onAddShift,
}) => {
  const [shiftDays, setShiftDays] = useState<ShiftDay[]>([]);
  const [selectedDate, setSelectedDate] = useState("");
  const [startTime, setStartTime] = useState("09:00");
  const [endTime, setEndTime] = useState("17:00");
  const [isSaving, setIsSaving] = useState(false);
  const [recurs, setRecurs] = useState(false);
  const toast = useToast();

  const getNextWeekDays = () => {
    const days = [];
    const today = moment().startOf("day");
    for (let i = 0; i < 7; i++) {
      const date = today.clone().add(i, "days").toDate();
      days.push(date);
    }
    return days;
  };

  const getAvailableDays = () => {
    if (!employee) return [];

    const scheduledDates = existingShifts.map((shift) =>
      moment(shift.start).format("YYYY-MM-DD")
    );

    return getNextWeekDays().filter(
      (day) => !scheduledDates.includes(moment(day).format("YYYY-MM-DD"))
    );
  };

  const addShiftDay = () => {
    if (!selectedDate) {
      toast({
        title: "Please select a date",
        status: "warning",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    if (startTime >= endTime) {
      toast({
        title: "End time must be after start time",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    const newShiftDay: ShiftDay = {
      date: new Date(selectedDate),
      startTime,
      endTime,
      recurs,
    };

    setShiftDays((prev) => [...prev, newShiftDay]);
    setSelectedDate("");
    setStartTime("09:00");
    setEndTime("17:00");
    setRecurs(false);
  };

  const removeShiftDay = (index: number) => {
    setShiftDays((prev) => prev.filter((_, i) => i !== index));
  };

  const saveAllShifts = async () => {
    if (!employee || shiftDays.length === 0) return;

    setIsSaving(true);
    try {
      // Corrected logic: Iterate and add each single shift record.
      const shiftPromises = shiftDays.map(async (shiftDay) => {
        const start = moment(shiftDay.date)
          .set({
            hour: parseInt(shiftDay.startTime.split(":")[0]),
            minute: parseInt(shiftDay.startTime.split(":")[1]),
          })
          .toDate();
        const end = moment(shiftDay.date)
          .set({
            hour: parseInt(shiftDay.endTime.split(":")[0]),
            minute: parseInt(shiftDay.endTime.split(":")[1]),
          })
          .toDate();

        // Call onAddShift once per record, with the recurs flag
        return onAddShift({
          employeeId: employee.id,
          start,
          end,
          recurs: shiftDay.recurs,
        });
      });

      await Promise.all(shiftPromises);

      setShiftDays([]);
      onClose();

      toast({
        title: "Shifts Added",
        description: `Successfully added the selected shifts for ${employee.name}.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      logger.error("ShiftModal: Failed to add shifts:", error);
      toast({
        title: "Error Adding Shifts",
        description: "Failed to add one or more shifts.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsSaving(false);
    }
  };

  const availableDays = getAvailableDays();

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="lg">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Add Shifts for {employee?.name}</ModalHeader>
        <ModalCloseButton />
        <ModalBody>
          <VStack spacing={4} align="stretch">
            <FormControl>
              <FormLabel>Available Days</FormLabel>
              <Select
                value={selectedDate}
                onChange={(e) => setSelectedDate(e.target.value)}
                placeholder="Select a day"
              >
                {availableDays.map((day) => (
                  <option key={day.toISOString()} value={day.toISOString()}>
                    {day.toLocaleDateString("en-US", {
                      weekday: "long",
                      month: "short",
                      day: "numeric",
                    })}
                  </option>
                ))}
              </Select>
            </FormControl>

            <HStack>
              <FormControl>
                <FormLabel>Start Time</FormLabel>
                <Input
                  type="time"
                  value={startTime}
                  onChange={(e) => setStartTime(e.target.value)}
                />
              </FormControl>
              <FormControl>
                <FormLabel>End Time</FormLabel>
                <Input
                  type="time"
                  value={endTime}
                  onChange={(e) => setEndTime(e.target.value)}
                />
              </FormControl>
            </HStack>

            <FormControl>
              <Checkbox
                isChecked={recurs}
                onChange={(e) => setRecurs(e.target.checked)}
              >
                Recur weekly for 1 year
              </Checkbox>
            </FormControl>

            <Button onClick={addShiftDay} colorScheme="blue">
              Add This Shift
            </Button>

            {shiftDays.length > 0 && (
              <Box mt={4}>
                <Text fontWeight="bold" mb={2}>
                  Shifts to Add:
                </Text>
                <VStack spacing={2} align="stretch">
                  {shiftDays.map((shiftDay, index) => (
                    <HStack
                      key={index}
                      justify="space-between"
                      p={2}
                      bg="gray.50"
                      borderRadius="md"
                    >
                      <Text fontSize="sm">
                        {shiftDay.date.toLocaleDateString()} -{" "}
                        {shiftDay.startTime} to {shiftDay.endTime}
                        {shiftDay.recurs && (
                          <Text as="span" ml={2} color="green.500">
                            (Recurring)
                          </Text>
                        )}
                      </Text>
                      <IconButton
                        icon={<DeleteIcon />}
                        aria-label={`Remove shift on ${shiftDay.date.toLocaleDateString()}`}
                        size="sm"
                        onClick={() => removeShiftDay(index)}
                        variant="ghost"
                      />
                    </HStack>
                  ))}
                </VStack>
              </Box>
            )}
          </VStack>
        </ModalBody>
        <ModalFooter>
          <Button variant="ghost" mr={3} onClick={onClose}>
            Cancel
          </Button>
          <Button
            colorScheme="blue"
            onClick={saveAllShifts}
            isDisabled={shiftDays.length === 0 || isSaving}
            isLoading={isSaving}
          >
            Save All Shifts ({shiftDays.length})
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
};

export default ShiftModal;
// src/app/pos/management/[entityName]/ShiftManagementComponents/EmployeeList.tsx

"use client";

import React, { useState, useMemo } from "react";
import {
  Box,
  Heading,
  VStack,
  Text,
  Badge,
  Input,
  InputGroup,
  InputLeftElement,
  Collapse,
  IconButton,
  HStack,
} from "@chakra-ui/react";
import {
  SearchIcon,
  ChevronDownIcon,
  ChevronRightIcon,
} from "@chakra-ui/icons";
import { Employee } from "../ShiftManagement";
import { generateRoleColors, getChakraColorScheme } from "./roleColors";

interface EmployeeListProps {
  employees: Employee[];
  onEmployeeClick: (employee: Employee) => void;
}

const EmployeeListItem: React.FC<{
  employee: Employee;
  onClick: (employee: Employee) => void;
  roleColors: Record<string, string>;
}> = ({ employee, onClick, roleColors }) => {
  const roleColor = roleColors[employee.role] || roleColors.default;
  const colorScheme = getChakraColorScheme(roleColor);

  return (
    <Box
      p={2}
      borderWidth="1px"
      borderRadius="lg"
      cursor="pointer"
      bg="white"
      mb={2}
      boxShadow="sm"
      _hover={{ bg: "gray.50" }}
      onClick={() => onClick(employee)}
    >
      <Text fontWeight="bold" fontSize="sm">
        {employee.name}
      </Text>
      <Badge colorScheme={colorScheme} fontSize="xs">
        {employee.role || "No Role"}
      </Badge>
      <Text fontSize="xs" color="gray.500" mt={1}>
        ID: {employee.id}
      </Text>
    </Box>
  );
};

const EmployeeList: React.FC<EmployeeListProps> = ({
  employees,
  onEmployeeClick,
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [collapsedRoles, setCollapsedRoles] = useState<Record<string, boolean>>(
    {}
  );

  // Generate consistent role colors
  const roleColors = useMemo(() => generateRoleColors(employees), [employees]);

  // Add null/undefined check
  if (!employees || !Array.isArray(employees)) {
    return (
      <Box width="240px" display="flex" flexDirection="column" minHeight="0">
        <Heading size="sm" mb={3}>
          Employees
        </Heading>
        <Text fontSize="sm">No employees available</Text>
      </Box>
    );
  }

  // Filter employees based on search term
  const filteredEmployees = useMemo(() => {
    if (!searchTerm.trim()) return employees;

    return employees.filter(
      (emp) =>
        emp.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        emp.role?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        emp.first_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        emp.last_name?.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [employees, searchTerm]);

  // Group filtered employees by role
  const groups = useMemo(() => {
    return filteredEmployees.reduce<Record<string, Employee[]>>((acc, e) => {
      const role = e.role || "Other";
      if (!acc[role]) acc[role] = [];
      acc[role].push(e);
      return acc;
    }, {});
  }, [filteredEmployees]);

  // Toggle role collapse state
  const toggleRoleCollapse = (role: string) => {
    setCollapsedRoles((prev) => ({
      ...prev,
      [role]: !prev[role],
    }));
  };

  return (
    <Box
      width="100%" // Changed to 100%
      minWidth="240px"
      display="flex"
      flexDirection="column"
      height="100%" // Added to use full height
      minHeight="0"
      overflow="hidden" // Added to contain scrolling
    >
      <Heading size="sm" mb={3}>
        Employees ({filteredEmployees.length})
      </Heading>

      {/* Search Input */}
      <InputGroup mb={4} size="sm">
        <InputLeftElement pointerEvents="none">
          <SearchIcon color="gray.300" />
        </InputLeftElement>
        <Input
          placeholder="Search employees..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          bg="white"
        />
      </InputGroup>

      <VStack
        align="stretch"
        spacing={2}
        flex="1"
        overflowY="auto"
        minHeight="0"
        height="calc(100% - 80px)" // Added to account for heading and search
        css={{
          "&::-webkit-scrollbar": {
            width: "6px",
          },
          "&::-webkit-scrollbar-track": {
            background: "#f1f1f1",
            borderRadius: "3px",
          },
          "&::-webkit-scrollbar-thumb": {
            background: "#c1c1c1",
            borderRadius: "3px",
          },
          "&::-webkit-scrollbar-thumb:hover": {
            background: "#a8a8a8",
          },
        }}
      >
        {Object.keys(groups).map((role) => {
          const isCollapsed = collapsedRoles[role];
          const roleColor = roleColors[role] || roleColors.default;
          const colorScheme = getChakraColorScheme(roleColor);

          return (
            <Box key={role}>
              <HStack
                spacing={2}
                cursor="pointer"
                onClick={() => toggleRoleCollapse(role)}
                _hover={{ bg: "gray.50" }}
                p={1}
                borderRadius="md"
              >
                <IconButton
                  aria-label={isCollapsed ? "Expand" : "Collapse"}
                  icon={
                    isCollapsed ? <ChevronRightIcon /> : <ChevronDownIcon />
                  }
                  size="xs"
                  variant="ghost"
                />
                <Badge colorScheme={colorScheme} fontSize="xs" flex="1">
                  {role} ({groups[role].length})
                </Badge>
              </HStack>

              <Collapse in={!isCollapsed} animateOpacity>
                <Box ml={6} mt={1}>
                  {groups[role].map((emp) => (
                    <EmployeeListItem
                      key={emp.id}
                      employee={emp}
                      onClick={onEmployeeClick}
                      roleColors={roleColors}
                    />
                  ))}
                </Box>
              </Collapse>
            </Box>
          );
        })}

        {Object.keys(groups).length === 0 && searchTerm && (
          <Text fontSize="sm" color="gray.500" textAlign="center" py={4}>
            No employees found matching "{searchTerm}"
          </Text>
        )}
      </VStack>
    </Box>
  );
};

export default EmployeeList;
