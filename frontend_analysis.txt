=== API FILE (src/lib/api.ts) ===
import useSWR from "swr";
import { useToast } from "@chakra-ui/react";
import {
  Order,
  Food,
  Category,
  Customer,
  Table,
  OrderItem,
  InventoryProduct,
  JobTitle,
  Employee,
  AccessRole,
  User,
  Store,
  RecipeItem,
  Shift,
  TimesheetEntry,
  Payroll,
  PayrollSettings,
} from "./config/entities";

const BASE_URL = "http://127.0.0.1:8000/api";

// Interface for the new standard response format
interface StandardResponse<T = any> {
  code: number;
  message: string;
  data?: T;
}

// Generic fetcher function for useSWR with auth headers - UPDATED
const fetcher = async (url: string) => {
  const headers: HeadersInit = {
    "Content-Type": "application/json",
  };

  const token =
    typeof window !== "undefined" ? localStorage.getItem("access_token") : null;
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }

  console.log(`[API] üîÑ Fetching: ${url}`);
  const response = await fetch(url, { headers });

  if (!response.ok) {
    throw new Error(`API error: ${response.statusText}`);
  }

  const responseData: StandardResponse = await response.json();
  console.log(`[API] üîÑ Fetcher received:`, responseData);

  // Check if the response has an error code but successful HTTP status
  if (responseData.code >= 400) {
    throw new Error(responseData.message || `API error: ${responseData.code}`);
  }

  // Extract data from StandardResponse
  return responseData.data;
};

export async function fetchData(
  resource: string,
  id?: string,
  data?: Record<string, any>,
  method: "GET" | "POST" | "PUT" | "DELETE" = "GET"
): Promise<any | null> {
  // 1. Build the URL
  let cleanResource = resource.replace(/^\/|\/$/g, "").replace(/^api\//i, "");
  const url = id
    ? `${BASE_URL}/${cleanResource}/${id}`
    : `${BASE_URL}/${cleanResource}`;

  console.log(`[API] üöÄ Starting ${method} request to: ${url}`);
  if (data) {
    console.log(`[API] üì¶ Payload for ${method}:`, data);
  }

  // 2. Prepare Headers and Authorization
  const headers: HeadersInit = {
    "Content-Type": "application/json",
  };

  const token =
    typeof window !== "undefined" ? localStorage.getItem("access_token") : null;
  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
    console.log(`[API] üîë Authorization token added.`);
  }

  const options: RequestInit = {
    method,
    headers,
  };

  // 3. Add Body for POST/PUT methods
  if ((method === "POST" || method === "PUT") && data) {
    options.body = JSON.stringify(data);
  }

  // 4. Execute the Fetch Request
  const response = await fetch(url, options);

  // 5. Handle Errors - UPDATED for new error format
  if (!response.ok) {
    let errorMessage = `API error: ${response.status} ${response.statusText}`;
    let responseText = "";

    console.error(
      `[API] ‚ùå Request failed with status: ${response.status} (${response.statusText})`
    );

    try {
      responseText = await response.text();
      const errorJson: StandardResponse = responseText
        ? JSON.parse(responseText)
        : null;

      console.error(`[API] üìÑ Raw error response body:`, responseText);

      // Check for the new standard error structure
      if (errorJson && errorJson.message) {
        errorMessage = errorJson.message;
        // Include details if available
        if (errorJson.hasOwnProperty("details") && errorJson.details) {
          errorMessage += ` - ${JSON.stringify(errorJson.details)}`;
        }
      } else if (responseText) {
        errorMessage = responseText;
      }
    } catch (e) {
      console.error(`[API] ‚ö†Ô∏è Failed to parse error response:`, e);
      errorMessage = responseText || errorMessage;
    }

    console.error(`[API] üõë Throwing formatted error: ${errorMessage}`);
    throw new Error(errorMessage);
  }

  // 6. Return Data on Success - UPDATED to extract data from standard response

  // Handle 204 No Content
  if (response.status === 204) {
    console.log(`[API] ‚úÖ Request successful (204 No Content).`);
    return null;
  }

  // Return parsed JSON for 200, 201, 202, etc.
  const finalResponse: StandardResponse = await response.json();
  console.log(
    `[API] ‚úÖ Request successful (${response.status}). Full response:`,
    finalResponse
  );

  // Return the data part of the standard response
  return finalResponse.data;
}

// Authentication - UPDATED for new response format
export async function loginEmployee(
  email: string,
  password: string
): Promise<Employee & { store_id: string }> {
  const url = `${BASE_URL}/login`;
  console.log("loginEmployee: Starting login process...");

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: new URLSearchParams({
      username: email,
      password: password,
    }),
  });

  if (!response.ok) {
    const responseText = await response.text();
    let errorMessage = "Invalid email or password.";

    try {
      const errorData: StandardResponse = JSON.parse(responseText);
      errorMessage = errorData.message || errorMessage;
      console.error("Login API error:", errorData);
    } catch (e) {
      errorMessage = responseText || `Login failed: ${response.statusText}`;
      console.error("Login API error:", errorMessage);
    }

    throw new Error(errorMessage);
  }

  const loginResponse: StandardResponse<{
    access_token: string;
    employee: Employee;
  }> = await response.json();
  console.log("Login response:", loginResponse);

  const { access_token, employee } = loginResponse.data!;

  if (!employee) {
    throw new Error("Employee data not found in login response.");
  }

  localStorage.setItem("access_token", access_token);

  return {
    ...employee,
    store_id: employee.store_id,
  };
}

// Core POS functions - THESE SHOULD NOW WORK CORRECTLY
export const useFoods = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/foods`,
    fetcher
  );
  return {
    menuItems: data, // This now contains the actual array of foods
    isLoading,
    isError: error,
    refreshMenuItems: mutate,
  };
};

export const useCategories = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/categories`,
    fetcher
  );
  return {
    categories: data, // This now contains the actual array of categories
    isLoading,
    isError: error,
    refreshCategories: mutate,
  };
};

export const useTables = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/tables`,
    fetcher
  );
  return {
    tables: data, // This now contains the actual array of tables
    isLoading,
    isError: error,
    refreshTables: mutate,
  };
};

export const useCreateOrder = () => {
  const toast = useToast();

  const createOrder = async (order: any) => {
    try {
      const newOrder = await fetchData("orders", undefined, order, "POST");

      toast({
        title: "Order created.",
        description: "Your order has been successfully placed.",
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      return newOrder;
    } catch (error: any) {
      toast({
        title: "Order creation failed.",
        description: error.message || "There was an error placing your order.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      throw error;
    }
  };
  return { createOrder };
};

export const useOrders = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/orders`,
    fetcher
  );
  return {
    orders: data, // This now contains the actual array of orders
    isLoading,
    isError: error,
    refreshOrders: mutate,
  };
};

export const useUpdateOrder = () => {
  const toast = useToast();

  const updateOrder = async (orderId: string, updatedOrder: any) => {
    try {
      const result = await fetchData("orders", orderId, updatedOrder, "PUT");

      toast({
        title: "Order Updated.",
        description: "Order status has been successfully updated.",
        status: "success",
        duration: 2000,
        isClosable: true,
      });
      return result;
    } catch (error: any) {
      toast({
        title: "Order Update Failed.",
        description: error.message || "There was an error updating the order.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      throw error;
    }
  };
  return { updateOrder };
};

export const useInventoryProducts = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/inventory_products`,
    fetcher
  );
  return {
    inventoryProducts: data, // This now contains the actual array of inventory products
    isLoading,
    isError: error,
    refreshInventoryProducts: mutate,
  };
};

// HR functions - UPDATED to handle new response format
export async function getEmployees(): Promise<any[]> {
  const response = await fetchData("employees");
  return response; // This is now the actual array
}

export async function getShifts(): Promise<any[]> {
  const response = await fetchData("shifts");
  return response; // This is now the actual array
}

export async function createShift(newShift: any): Promise<any> {
  const response = await fetchData("shifts", undefined, newShift, "POST");
  return response; // This is now the created shift object
}

export async function updateShift(shiftId: string, updates: any): Promise<any> {
  const response = await fetchData("shifts", shiftId, updates, "PUT");
  return response; // This is now the updated shift object
}

export async function updateShiftStatus(
  shiftId: string,
  status: boolean
): Promise<any> {
  const response = await fetchData(
    `shifts/${shiftId}/status`,
    undefined,
    { active: status },
    "PUT"
  );
  return response; // This is now the updated shift object
}

export async function getTimesheets(): Promise<any[]> {
  const response = await fetchData("timesheet_entries");
  return response; // This is now the actual array
}

export async function clockIn(
  employeeId: string,
  storeId: string
): Promise<any> {
  const response = await fetchData(
    "timesheet_entries/clock-in",
    undefined,
    {
      employee_id: employeeId,
      store_id: storeId,
    },
    "POST"
  );
  return response; // This is now the created timesheet entry
}

export async function clockOut(timesheetId: string): Promise<any> {
  const response = await fetchData(
    `timesheet_entries/${timesheetId}/clock-out`,
    undefined,
    {},
    "POST"
  );
  return response; // This is now the updated timesheet entry
}

// Inventory functions
export async function getPurchaseOrders(): Promise<any[]> {
  const response = await fetchData("purchase_orders");
  return response; // This is now the actual array
}

export async function createPurchaseOrder(orderData: any): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
    undefined,
    orderData,
    "POST"
  );
  return response; // This is now the created purchase order
}

export async function updatePurchaseOrder(
  orderId: string,
  orderData: any
): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
    orderId,
    orderData,
    "PUT"
  );
  return response; // This is now the updated purchase order
}

export async function getGoodsReceipts(): Promise<any[]> {
  const response = await fetchData("goods_receipts");
  return response; // This is now the actual array
}

export async function createGoodsReceipt(receiptData: any): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
    undefined,
    receiptData,
    "POST"
  );
  return response; // This is now the created goods receipt
}

export async function getSuppliers(): Promise<any[]> {
  const response = await fetchData("suppliers");
  return response; // This is now the actual array
}

// Additional functions (payroll, low stock, etc.)
export async function getPayrolls(): Promise<any[]> {
  const response = await fetchData("payroll");
  return response; // This is now the actual array
}

export async function getLowStockItems(): Promise<any[]> {
  const response = await fetchData("inventory/low-stock");
  return response; // This is now the actual array of low stock items
}

export async function deleteItem(
  resource: string,
  id: string
): Promise<{ message: string }> {
  await fetchData(resource, id, undefined, "DELETE");
  return { message: "Item deleted successfully" };
}

// Other previously missing functions
export const useFood = (foodId: string | undefined) => {
  const { data, error, isLoading, mutate } = useSWR<Food>(
    foodId ? `${BASE_URL}/foods/${foodId}` : null,
    fetcher
  );
  return {
    food: data, // This now contains the actual food object
    isLoading,
    isError: error,
    refreshFood: mutate,
  };
};

export const useCreateFood = () => {
  const toast = useToast();
  const createFood = async (food: Food) => {
    try {
      const newFood = await fetchData("foods", undefined, food, "POST");
      toast({
        title: "Food created.",
        description: `Food ${newFood.name} has been successfully added.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      return newFood;
    } catch (error: any) {
      toast({
        title: "Food creation failed.",
        description: error.message || "There was an error adding the food.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      throw error;
    }
  };
  return createFood;
};

export const useUpdateFood = () => {
  const toast = useToast();
  const updateFood = async (foodId: string, food: Partial<Food>) => {
    try {
      const updatedFood = await fetchData("foods", foodId, food, "PUT");
      toast({
        title: "Food updated.",
        description: `Food ${updatedFood.name} has been successfully updated.`,
        status: "success",
        duration: 3000,
        isClosable: true,
      });
      return updatedFood;
    } catch (error: any) {
      toast({
        title: "Food update failed.",
        description: error.message || "There was an error updating the food.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      throw error;
    }
  };
  return updateFood;
};

export const useDeleteFood = () => {
  const toast = useToast();
  const deleteFood = async (foodId: string) => {
    try {
      await fetchData("foods", foodId, undefined, "DELETE");
      toast({
        title: "Food deleted.",
        description: "The food item has been successfully removed.",
        status: "success",
        duration: 3000,
        isClosable: true,
      });
    } catch (error: any) {
      toast({
        title: "Food deletion failed.",
        description: error.message || "There was an error deleting the food.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      throw error;
    }
  };
  return deleteFood;
};

export async function getAccessRoles(): Promise<any[]> {
  const response = await fetchData("access_roles");
  return response; // This is now the actual array
}

export async function getJobTitles(): Promise<any[]> {
  const response = await fetchData("job_titles");
  return response; // This is now the actual array
}

export async function getPayrollSettings(): Promise<any> {
  const response = await fetchData("payroll_settings");
  return response; // This is now the settings object (not an array anymore)
}

// Add a test function to verify connection
export async function testConnection(): Promise<boolean> {
  try {
    const response = await fetch(`${BASE_URL}/health`);
    const data: StandardResponse = await response.json();
    console.log("Health check:", data);
    return data.code === 200;
  } catch (error) {
    console.error("Connection test failed:", error);
    return false;
  }
}

// Department functions
export async function getDepartments(): Promise<any[]> {
  const response = await fetchData("departments");
  return response; // This is now the actual array
}

// In api.ts - Update the getUsers function
export async function getUsers(): Promise<any[]> {
  const response = await fetchData("users");
  // Transform the data to match your frontend expectations
  return response.map((user: any) => ({
    ...user,
    // Create name field from first_name and last_name
    name:
      user.name ||
      `${user.first_name || ""} ${user.last_name || ""}`.trim() ||
      user.username,
    // Ensure all required fields are present
    email_verified_at: user.email_verified_at || null,
    remember_token: user.remember_token || null,
  }));
}

// Also update the useUsers hook
export const useUsers = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/users`,
    async (url) => {
      const users = await fetcher(url);
      return users.map((user: any) => ({
        ...user,
        name:
          user.name ||
          `${user.first_name || ""} ${user.last_name || ""}`.trim() ||
          user.username,
      }));
    }
  );

  return {
    users: data,
    isLoading,
    isError: error,
    refreshUsers: mutate,
  };
};

export const useDepartments = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/departments`,
    fetcher
  );
  return {
    departments: data, // This now contains the actual array of departments
    isLoading,
    isError: error,
    refreshDepartments: mutate,
  };
};

export const useAccessRoles = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/access_roles`,
    fetcher
  );
  return {
    accessRoles: data, // This now contains the actual array of access roles
    isLoading,
    isError: error,
    refreshAccessRoles: mutate,
  };
};

export const useJobTitles = () => {
  const { data, error, isLoading, mutate } = useSWR(
    `${BASE_URL}/job_titles`,
    fetcher
  );
  return {
    jobTitles: data, // This now contains the actual array of job titles
    isLoading,
    isError: error,
    refreshJobTitles: mutate,
  };
};

// Enhanced fetchData with better error handling
export async function enhancedFetchData(
  resource: string,
  id?: string,
  data?: Record<string, any>,
  method: "GET" | "POST" | "PUT" | "DELETE" = "GET"
): Promise<any | null> {
  try {
    return await fetchData(resource, id, data, method);
  } catch (error: any) {
    console.error(`API Error for ${resource}:`, error);
    throw error;
  }
}

export async function calculatePayroll(
  employeeId: string,
  periodStart: string,
  periodEnd: string
): Promise<any> {
  const response = await fetchData(
    "payroll/calculate",
    undefined,
    {
      employee_id: employeeId,
      period_start: periodStart,
      period_end: periodEnd,
    },
    "POST"
  );
  return response;
}

export async function processPayroll(payrollId: string): Promise<any> {
  const response = await fetchData(
    `payroll/${payrollId}/process`,
    undefined,
    {},
    "POST"
  );
  return response;
}

export async function createPayroll(payrollData: any): Promise<any> {
  const response = await fetchData("payroll", undefined, payrollData, "POST");
  return response;
}

export async function updatePayrollSettings(settings: any): Promise<any> {
  const response = await fetchData(
    "payroll_settings",
    undefined,
    settings,
    "POST"
  );
  return response;
}

// Inventory functions
export async function getInventoryProducts(): Promise<any[]> {
  const response = await fetchData("inventory_products");
  return response;
}

// Add these functions to your api.ts file

// Sites functions
export async function getSites(): Promise<any[]> {
  const response = await fetchData("sites");
  return response;
}

export async function createSite(siteData: any): Promise<any> {
  const response = await fetchData("sites", undefined, siteData, "POST");
  return response;
}

export async function updateSite(siteId: string, siteData: any): Promise<any> {
  const response = await fetchData("sites", siteId, siteData, "PUT");
  return response;
}

export async function deleteSite(siteId: string): Promise<any> {
  const response = await fetchData("sites", siteId, undefined, "DELETE");
  return response;
}

export async function deletePurchaseOrder(orderId: string): Promise<any> {
  const response = await fetchData(
    "purchase_orders",
    orderId,
    undefined,
    "DELETE"
  );
  return response;
}

export async function updateGoodsReceipt(
  receiptId: string,
  receiptData: any
): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
    receiptId,
    receiptData,
    "PUT"
  );
  return response;
}

export async function deleteGoodsReceipt(receiptId: string): Promise<any> {
  const response = await fetchData(
    "goods_receipts",
    receiptId,
    undefined,
    "DELETE"
  );
  return response;
}

export async function createInventoryProduct(productData: any): Promise<any> {
  const response = await fetchData(
    "inventory_products",
    undefined,
    productData,
    "POST"
  );
  return response;
}

export async function updateInventoryProduct(
  productId: string,
  productData: any
): Promise<any> {
  const response = await fetchData(
    "inventory_products",
    productId,
    productData,
    "PUT"
  );
  return response;
}

export async function deleteInventoryProduct(productId: string): Promise<any> {
  const response = await fetchData(
    "inventory_products",
    productId,
    undefined,
    "DELETE"
  );
  return response;
}


=== SHIFT MANAGEMENT COMPONENT ===
// src/app/pos/management/[entityName]/ShiftManagement.tsx
"use client";

import React, { useState, useEffect } from "react";
import {
  Box,
  Center,
  Flex,
  Heading,
  Spinner,
  useToast,
  useDisclosure,
  Text,
  Alert,
  AlertIcon,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Button,
  HStack,
} from "@chakra-ui/react";
import ShiftCalendar from "./ShiftManagementComponents/ShiftCalendar";
import EmployeeList from "./ShiftManagementComponents/EmployeeList";
import ShiftModal from "./ShiftManagementComponents/ShiftModal";
import ShiftUpdateModal from "./ShiftManagementComponents/ShiftUpdateModal";
import {
  getShifts,
  getEmployees,
  createShift,
  updateShift,
  deleteShift,
} from "@/lib/api";
import { usePOSStore } from "@/lib/usePOSStore";
import moment from "moment";
import {
  Employee as EmployeeDetails,
  Shift as ShiftDetails,
} from "@/lib/config/entities";
import { logger } from "@/lib/logger";
import { FaSync, FaExclamationTriangle } from "react-icons/fa";

export interface Employee extends EmployeeDetails {
  name?: string;
  role?: string;
}

export interface Shift extends ShiftDetails {
  recurs: boolean;
  recurringDay?: number;
  start: Date;
  end: Date;
  employee_name?: string;
  color?: string;
  active?: boolean;
}

export default function ShiftsPage() {
  const {
    shifts,
    setShifts,
    addShift,
    updateShift: updateStoreShift,
    deleteShift: deleteStoreShift,
    employees: storeEmployees,
    setEmployees,
  } = usePOSStore();

  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);
  const [selectedEmployee, setSelectedEmployee] = useState<Employee | null>(
    null
  );
  const [selectedShift, setSelectedShift] = useState<Shift | null>(null);
  const [error, setError] = useState<string | null>(null);
  const toast = useToast();
  const { isOpen, onOpen, onClose } = useDisclosure();

  useEffect(() => {
    logger.info("ShiftManagement: useEffect triggered. Starting data load.");
    const loadData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [fetchedShifts, fetchedEmployees] = await Promise.all([
          getShifts(),
          getEmployees(),
        ]);

        logger.info("ShiftManagement: Raw data from API received.");
        logger.info("   - Fetched Shifts: ", fetchedShifts);
        logger.info("   - Fetched Employees: ", fetchedEmployees);

        // Map employees with proper typing
        const mappedEmployees: Employee[] = fetchedEmployees.map((emp) => ({
          ...emp,
          name: `${emp.first_name} ${emp.last_name}`,
          role: emp.job_title_id,
          // Ensure color is set for calendar display
          color: emp.color || "#3182CE",
        }));

        logger.info(
          "ShiftManagement: Processed and mapped employees.",
          mappedEmployees
        );

        // Process shifts with proper date handling and employee enrichment
        const shiftsWithNamesAndDates: Shift[] = fetchedShifts
          .map((shift: any) => {
            try {
              const employee = mappedEmployees.find(
                (e) => e.id === shift.employee_id
              );

              // Handle date conversion safely
              let startDate: Date;
              let endDate: Date;

              try {
                startDate = moment(shift.start).toDate();
                endDate = moment(shift.end).toDate();
              } catch (dateError) {
                logger.error(
                  "ShiftManagement: Invalid date format, using current date as fallback",
                  shift
                );
                startDate = new Date();
                endDate = new Date();
              }

              return {
                ...shift,
                id: shift.id,
                employee_id: shift.employee_id,
                start: startDate,
                end: endDate,
                employee_name: employee ? employee.name : "Unknown",
                color: employee?.color || "#3182CE",
                recurs: shift.recurs || false,
                recurringDay: shift.recurringDay,
                active: shift.active !== false, // Default to true if not specified
                title: shift.title || `Shift - ${employee?.name || "Unknown"}`,
                created_at: shift.created_at,
                updated_at: shift.updated_at,
              };
            } catch (error) {
              logger.error(
                "ShiftManagement: Error processing shift, skipping.",
                shift,
                error
              );
              return null;
            }
          })
          .filter(Boolean) as Shift[];

        logger.info(
          "ShiftManagement: Processed shifts with employee names.",
          shiftsWithNamesAndDates
        );

        setShifts(shiftsWithNamesAndDates);
        setEmployees(mappedEmployees);
        logger.info("ShiftManagement: Data successfully set in Zustand store.");
      } catch (error: any) {
        logger.error("ShiftManagement: Failed to load data", error);
        setError(error.message || "Failed to load shift data.");
        toast({
          title: "Failed to load data.",
          description:
            error.message ||
            "Could not fetch shifts or employees. Please try again.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      } finally {
        setIsLoading(false);
      }
    };

    loadData();
  }, [setShifts, setEmployees, toast]);

  const handleAddShift = async (newShiftData: {
    employeeId: string;
    start: Date;
    end: Date;
    recurs: boolean;
  }) => {
    if (!selectedEmployee) return;

    try {
      setIsProcessing(true);
      const { employeeId, start, end, recurs } = newShiftData;

      // Calculate recurring day if needed
      const recurringDay = recurs ? moment(start).day() : undefined;

      // Prepare API payload
      const apiPayload = {
        employee_id: employeeId,
        start: start.toISOString(),
        end: end.toISOString(),
        recurs: recurs,
        recurringDay: recurringDay,
        active: true,
        title: `Shift - ${selectedEmployee.name}`,
        // Include store_id if available
        store_id: selectedEmployee.store_id || "default-store",
      };

      logger.info("ShiftManagement: Creating shift with payload:", apiPayload);

      const createdShift = await createShift(apiPayload);

      // Convert the created shift to the frontend format
      const shiftToAdd: Shift = {
        ...createdShift,
        start: moment(createdShift.start).toDate(),
        end: moment(createdShift.end).toDate(),
        employee_name: selectedEmployee.name,
        color: selectedEmployee.color,
        recurs: createdShift.recurs || false,
        recurringDay: createdShift.recurringDay,
        active: createdShift.active !== false,
        title: createdShift.title || `Shift - ${selectedEmployee.name}`,
      };

      addShift(shiftToAdd);

      toast({
        title: "Shift added successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to add shift", error);
      toast({
        title: "Failed to add shift.",
        description:
          error.message || "An error occurred while saving the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleUpdateShift = async (
    shiftId: string,
    updates: Partial<Shift>
  ) => {
    try {
      setIsProcessing(true);
      const originalShift = shifts.find((s) => s.id === shiftId);
      if (!originalShift) {
        logger.error("Shift not found for update:", shiftId);
        toast({
          title: "Error Updating Shift",
          description: "Original shift not found.",
          status: "error",
          duration: 4000,
          isClosable: true,
        });
        return;
      }

      // Prepare API payload with proper date formatting
      const apiPayload = {
        ...originalShift,
        ...updates,
        start: updates.start
          ? updates.start.toISOString()
          : originalShift.start.toISOString(),
        end: updates.end
          ? updates.end.toISOString()
          : originalShift.end.toISOString(),
        // Preserve recurrence settings
        recurs: originalShift.recurs,
        recurringDay: originalShift.recurs
          ? moment(updates.start || originalShift.start).day()
          : undefined,
        // Ensure required fields
        employee_id: originalShift.employee_id,
        active:
          updates.active !== undefined ? updates.active : originalShift.active,
      };

      logger.info("ShiftManagement: Updating shift with payload:", apiPayload);

      const updatedShift = await updateShift(shiftId, apiPayload);

      // Convert to frontend format
      const shiftToUpdate: Shift = {
        ...updatedShift,
        start: moment(updatedShift.start).toDate(),
        end: moment(updatedShift.end).toDate(),
        employee_name: originalShift.employee_name,
        color: originalShift.color,
        recurs: updatedShift.recurs || false,
        recurringDay: updatedShift.recurringDay,
        active: updatedShift.active !== false,
      };

      updateStoreShift(shiftId, shiftToUpdate);

      toast({
        title: "Shift updated successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to update shift", error);
      toast({
        title: "Failed to update shift.",
        description:
          error.message || "An error occurred while updating the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleDeleteShift = async (shiftId: string) => {
    try {
      setIsProcessing(true);
      await deleteShift(shiftId);
      deleteStoreShift(shiftId);

      toast({
        title: "Shift deleted successfully.",
        status: "success",
        duration: 5000,
        isClosable: true,
      });
      onClose();
    } catch (error: any) {
      logger.error("ShiftManagement: Failed to delete shift", error);
      toast({
        title: "Failed to delete shift.",
        description:
          error.message || "An error occurred while deleting the shift.",
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSelectEmployee = (employee: Employee) => {
    setSelectedEmployee(employee);
    setSelectedShift(null);
    onOpen();
  };

  const handleEditShift = (shift: Shift) => {
    setSelectedShift(shift);
    const employee = storeEmployees.find((emp) => emp.id === shift.employee_id);
    setSelectedEmployee(employee || null);
    onOpen();
  };

  const handleModalClose = () => {
    setSelectedEmployee(null);
    setSelectedShift(null);
    onClose();
  };

  const refreshData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [fetchedShifts, fetchedEmployees] = await Promise.all([
        getShifts(),
        getEmployees(),
      ]);

      const mappedEmployees: Employee[] = fetchedEmployees.map((emp) => ({
        ...emp,
        name: `${emp.first_name} ${emp.last_name}`,
        role: emp.job_title_id,
        color: emp.color || "#3182CE",
      }));

      const shiftsWithNamesAndDates: Shift[] = fetchedShifts
        .map((shift: any) => {
          try {
            const employee = mappedEmployees.find(
              (e) => e.id === shift.employee_id
            );
            return {
              ...shift,
              start: moment(shift.start).toDate(),
              end: moment(shift.end).toDate(),
              employee_name: employee ? employee.name : "Unknown",
              color: employee?.color || "#3182CE",
              recurs: shift.recurs || false,
              recurringDay: shift.recurringDay,
              active: shift.active !== false,
            };
          } catch (error) {
            return null;
          }
        })
        .filter(Boolean) as Shift[];

      setShifts(shiftsWithNamesAndDates);
      setEmployees(mappedEmployees);
    } catch (error: any) {
      setError(error.message || "Failed to refresh data.");
    } finally {
      setIsLoading(false);
    }
  };

  // Calculate statistics
  const activeShifts = shifts.filter((s) => s.active);
  const todayShifts = activeShifts.filter((shift) =>
    moment(shift.start).isSame(moment(), "day")
  );
  const upcomingShifts = activeShifts.filter((shift) =>
    moment(shift.start).isAfter(moment())
  );

  if (isLoading) {
    return (
      <Center minH="400px">
        <Spinner size="xl" />
      </Center>
    );
  }

  return (
    <Box bg="gray.50" minH="100vh">
      <Flex
        as="header"
        position="sticky"
        top="0"
        zIndex="10"
        bg="white"
        p={5}
        borderBottom="1px"
        borderColor="gray.200"
        justifyContent="space-between"
        alignItems="center"
      >
        <Heading as="h1" size="xl">
          Shift Management
        </Heading>
        <HStack spacing={4}>
          <Button
            leftIcon={<FaSync />}
            onClick={refreshData}
            isLoading={isProcessing}
          >
            Refresh
          </Button>
        </HStack>
      </Flex>

      {error && (
        <Alert status="error" mx={5} mt={5} borderRadius="md">
          <AlertIcon />
          {error}
        </Alert>
      )}

      {/* Statistics Overview */}
      <SimpleGrid columns={3} spacing={4} p={5}>
        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Total Shifts</StatLabel>
          <StatNumber>{activeShifts.length}</StatNumber>
          <StatHelpText>Active shifts</StatHelpText>
        </Stat>

        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Today's Shifts</StatLabel>
          <StatNumber color="blue.500">{todayShifts.length}</StatNumber>
          <StatHelpText>Scheduled for today</StatHelpText>
        </Stat>

        <Stat bg="white" p={4} borderRadius="md" shadow="sm">
          <StatLabel>Upcoming Shifts</StatLabel>
          <StatNumber color="green.500">{upcomingShifts.length}</StatNumber>
          <StatHelpText>Future shifts</StatHelpText>
        </Stat>
      </SimpleGrid>

      <Box p={5}>
        <Flex direction={{ base: "column", md: "row" }} gap={6}>
          {/* Employee List - Fixed width to match sidebar */}
          <Box flex="0 0 240px" bg="white" p={6} rounded="md" shadow="sm">
            <EmployeeList
              employees={storeEmployees || []}
              onEmployeeClick={handleSelectEmployee}
            />
          </Box>

          {/* Calendar - Takes remaining space */}
          <Box flex="1" bg="white" p={6} rounded="md" shadow="sm" minWidth="0">
            <Heading as="h2" size="lg" mb={4}>
              Shift Calendar
            </Heading>
            {activeShifts.length === 0 ? (
              <Center h="300px" flexDirection="column">
                <FaExclamationTriangle size={48} color="#CBD5E0" />
                <Text color="gray.500" mt={4}>
                  No shifts scheduled. Click on an employee to create a shift.
                </Text>
              </Center>
            ) : (
              <ShiftCalendar
                shifts={activeShifts}
                employees={storeEmployees || []}
                onUpdateShift={handleUpdateShift}
                onDeleteShift={handleDeleteShift}
                onSelectShift={handleEditShift}
              />
            )}
          </Box>
        </Flex>
      </Box>

      {/* Modals */}
      {selectedShift ? (
        <ShiftUpdateModal
          isOpen={isOpen}
          onClose={handleModalClose}
          selectedShift={selectedShift}
          employee={selectedEmployee}
          onUpdateShift={handleUpdateShift}
          onDeleteShift={handleDeleteShift}
          isLoading={isProcessing}
        />
      ) : (
        <ShiftModal
          isOpen={isOpen}
          onClose={handleModalClose}
          employee={selectedEmployee}
          existingShifts={shifts.filter(
            (s) => s.employee_id === selectedEmployee?.id && s.active
          )}
          onAddShift={handleAddShift}
          isLoading={isProcessing}
        />
      )}
    </Box>
  );
}


=== PAGE.TSX (with handleEdit error) ===
// src/app/pos/management/[entityName]/page.tsx
"use client";

import React, { useEffect, useState, useCallback, useMemo } from "react";
import { useParams, useRouter } from "next/navigation";
import DataTable from "@/components/DataTable";
import {
  Box,
  Heading,
  Text,
  Spinner,
  Center,
  Flex,
  Spacer,
  Button,
  useToast,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  FormControl,
  FormLabel,
  Input,
  VStack,
  Select,
  Checkbox,
  CheckboxGroup,
  Stack,
  HStack,
  IconButton,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  Textarea,
} from "@chakra-ui/react";
import { FaEdit, FaTrash, FaPlus } from "react-icons/fa";
import {
  entities,
  EntityConfig,
  RecipeItem,
  InventoryProduct,
  Food,
  Unit,
} from "@/lib/config/entities";
import { fetchData, deleteItem } from "@/lib/api";
import { v4 as uuidv4 } from "uuid";

// Import the new shift management components
import dynamic from "next/dynamic";
import PayrollManagement from "./PayrollManagement";
import InventoryManagement from "./InventoryManagement";
const ShiftManagement = dynamic(() => import("./ShiftManagement"), {
  ssr: false,
  loading: () => (
    <Center minH="400px">
      <Spinner size="xl" />
    </Center>
  ),
});

// Import the new TimesheetManagement component
const TimesheetManagement = dynamic(() => import("./TimesheetManagement"), {
  ssr: false,
  loading: () => (
    <Center minH="400px">
      <Spinner size="xl" />
    </Center>
  ),
});

// Import PurchaseOrderManagement
const PurchaseOrderManagement = dynamic(
  () => import("./PurchaseOrderManagement"),
  {
    ssr: false,
    loading: () => (
      <Center minH="400px">
        <Spinner size="xl" />
      </Center>
    ),
  }
);

interface Column {
  accessorKey: string;
  header: string | React.ReactNode;
  cell?: (row: any) => React.ReactNode;
  isSortable?: boolean;
}

interface AccessRole {
  id: string;
  name: string;
}

interface JobTitle {
  id: string;
  title: string;
}

interface Department {
  id: string;
  name: string;
}

interface User {
  id: string;
  email: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

// New interfaces for HR entities
interface Shift {
  shift_id: string;
  employee_id: string;
  date: string;
  start_time: string;
  end_time: string;
  employee_name?: string;
}

interface Payroll {
  payroll_id: string;
  employee_id: string;
  payment_cycle: string;
  pay_period_start: string;
  pay_period_end: string;
  total_wages_due: string;
  tax_deductions: string;
  net_pay: string;
  status: string;
  employee_name?: string;
}

interface Company {
  company_id: string;
  name: string;
  country: string;
  tax_details: {
    tax_year: string;
    efiling_admin: string;
    related_docs: string;
  };
  metrics: {
    total_employees: number;
    active_employees: number;
    employees_on_leave: number;
    terminated_employees: number;
    full_time_employees: number;
    part_time_employees: number;
    contract_employees: number;
    employee_invites: {
      sent: number;
      active: number;
      require_attention: number;
    };
  };
}

export default function DynamicEntityManagementPage() {
  const params = useParams();
  const router = useRouter();
  const toast = useToast();

  const entityName = params.entityName as string;
  const entityConfig: EntityConfig | undefined = entities[entityName];

  const [data, setData] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedItem, setSelectedItem] = useState<any | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [accessRoles, setAccessRoles] = useState<AccessRole[]>([]);
  const [jobTitles, setJobTitles] = useState<JobTitle[]>([]);
  const [departments, setDepartments] = useState<Department[]>([]);
  const [users, setUsers] = useState<User[]>([]);
  const [inventoryProducts, setInventoryProducts] = useState<
    InventoryProduct[]
  >([]);
  const [foodCategories, setFoodCategories] = useState<any[]>([]);
  const [units, setUnits] = useState<Unit[]>([]);
  const [currentRecipes, setCurrentRecipes] = useState<RecipeItem[]>([]);
  const [allEmployees, setAllEmployees] = useState<any[]>([]); // For HR entity relationships

  // If the entity is shifts, render the special shift management component
  if (entityName === "shifts") {
    return <ShiftManagement />;
  }

  // If the entity is timesheets, render the new timesheet management component
  if (entityName === "timesheets") {
    return <TimesheetManagement />;
  }

  if (entityName === "payrolls") {
    return <PayrollManagement />;
  }

  if (entityName === "inventory") {
    return <InventoryManagement />;
  }

  if (entityName === "purchase_orders") {
    return <PurchaseOrderManagement />;
  }

  // Enhanced error handling function
  const handleApiError = (error: any, operation: string) => {
    if (error.message?.includes("404")) {
      toast({
        title: "Not Found",
        description: `The requested resource was not found for ${operation}.`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } else if (error.message?.includes("405")) {
      toast({
        title: "Method Not Allowed",
        description: `The operation ${operation} is not supported.`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } else if (error.message?.includes("400")) {
      toast({
        title: "Bad Request",
        description: `Invalid data provided for ${operation}.`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    } else {
      toast({
        title: "Error",
        description: error.message || `Failed to ${operation}.`,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
    }
  };

  // Form validation function
  const validateForm = (): string | null => {
    if (entityName === "employees") {
      if (!selectedItem?.first_name?.trim()) return "First name is required";
      if (!selectedItem?.last_name?.trim()) return "Last name is required";
      if (!selectedItem?.user?.email?.trim()) return "Email is required";
      if (!selectedItem?.main_access_role_id)
        return "Main access role is required";
      if (!selectedItem?.job_title_id) return "Job title is required";
    }
    if (entityName === "foods" || entityName === "recipes") {
      if (!selectedItem?.name?.trim()) return "Food name is required";
      if (!selectedItem?.price || selectedItem.price <= 0)
        return "Valid price is required";
      if (!selectedItem?.category_id) return "Category is required";
    }
    if (["timesheets", "payrolls"].includes(entityName)) {
      if (!selectedItem?.employee_id) return "Employee is required";
    }
    return null;
  };

  const refreshData = useCallback(async () => {
    if (!entityConfig) return;
    setIsLoading(true);
    setError(null);
    try {
      const promises = [fetchData(entityConfig.endpoint)];

      // Add necessary data for different entities
      if (entityName === "employees") {
        promises.push(fetchData("access_roles"));
        promises.push(fetchData("job_titles"));
        promises.push(fetchData("departments"));
        promises.push(fetchData("users"));
      } else if (entityName === "foods" || entityName === "recipes") {
        promises.push(fetchData("inventory_products"));
        promises.push(fetchData("categories"));
        promises.push(fetchData("units"));
      } else if (["payrolls", "timesheets"].includes(entityName)) {
        // For HR entities, we need employee data
        promises.push(fetchData("employees"));
      }

      const results = await Promise.all(promises);

      const fetchedEntityData = results[0];
      let fetchedAccessRoles: any,
        fetchedJobTitles: any,
        fetchedDepartments: any,
        fetchedUsers: any;
      let fetchedInventoryProducts, fetchedFoodCategories, fetchedUnits;
      let fetchedEmployees: any;

      if (entityName === "employees") {
        [
          fetchedAccessRoles,
          fetchedJobTitles,
          fetchedDepartments,
          fetchedUsers,
        ] = results.slice(1);
      } else if (entityName === "foods" || entityName === "recipes") {
        [fetchedInventoryProducts, fetchedFoodCategories, fetchedUnits] =
          results.slice(1);
      } else if (["payrolls", "timesheets"].includes(entityName)) {
        fetchedEmployees = results[1];
        setAllEmployees(fetchedEmployees || []);
      }

      // Process data based on entity type
      if (entityName === "employees") {
        const combinedData = (fetchedEntityData || []).map((employee: any) => {
          const user = (fetchedUsers || []).find(
            (u: any) => u.id === employee.user_id
          );
          const mainRole = (fetchedAccessRoles || []).find(
            (r: any) => r.id === employee.main_access_role_id
          );
          const jobTitle = (fetchedJobTitles || []).find(
            (p: any) => p.id === employee.job_title_id
          );

          return {
            ...employee,
            user,
            email: user?.email || "N/A",
            mainAccessRoleName: mainRole?.name || "N/A",
            jobTitleName: jobTitle?.title || "N/A",
          };
        });
        setData(combinedData);
        setAccessRoles(fetchedAccessRoles || []);
        setJobTitles(fetchedJobTitles || []);
        setDepartments(fetchedDepartments || []);
        setUsers(fetchedUsers || []);
      } else if (entityName === "foods" || entityName === "recipes") {
        const foodsWithCategories = (fetchedEntityData || []).map(
          (food: Food) => {
            const category = (fetchedFoodCategories || []).find(
              (cat: any) => cat.id === food.category_id
            );
            return {
              ...food,
              category_name: category?.name || "N/A",
            };
          }
        );
        setData(foodsWithCategories);
        setInventoryProducts(fetchedInventoryProducts || []);
        setFoodCategories(fetchedFoodCategories || []);
        setUnits(fetchedUnits || []);
      } else if (["timesheets", "payrolls"].includes(entityName)) {
        // Add employee names to HR entities
        const dataWithEmployeeNames = (fetchedEntityData || []).map(
          (item: any) => {
            const employee = (fetchedEmployees || []).find(
              (e: any) => e.id === item.employee_id
            );
            return {
              ...item,
              employee_name: employee
                ? `${employee.first_name} ${employee.last_name}`
                : "N/A",
            };
          }
        );
        setData(dataWithEmployeeNames);
      } else {
        setData(fetchedEntityData || []);
      }
    } catch (err: any) {
      setError(err.message || "Failed to fetch data.");
      handleApiError(err, "fetching data");
    } finally {
      setIsLoading(false);
    }
  }, [entityConfig, entityName, toast]);

  useEffect(() => {
    if (!entityName || !entityConfig) {
      // Avoid running for components that have their own management
      if (
        ![
          "shifts",
          "timesheets",
          "payrolls",
          "inventory",
          "purchase_orders",
        ].includes(entityName)
      ) {
        toast({
          title: "Error",
          description: `Invalid entity: ${entityName}`,
          status: "error",
          duration: 5000,
          isClosable: true,
        });
        router.replace("/pos/management");
      }
      return;
    }
    refreshData();
  }, [entityName, entityConfig, router, toast, refreshData]);

  const handleDelete = useCallback(
    async (id: string) => {
      if (
        !window.confirm(
          `Are you sure you want to delete this ${entityConfig?.label.toLowerCase()}?`
        )
      ) {
        return;
      }
      try {
        if (entityName === "employees") {
          const employeeToDelete = data.find((item) => item.id === id);
          if (employeeToDelete && employeeToDelete.user_id) {
            await deleteItem("users", employeeToDelete.user_id);
          }
          await deleteItem(entityConfig!.endpoint, id);
        } else {
          // For foods, just delete the food - recipes are embedded and will be deleted automatically
          await deleteItem(entityConfig!.endpoint, id);
        }
        toast({
          title: "Deleted",
          description: `${entityConfig?.label} deleted successfully.`,
          status: "success",
          duration: 3000,
          isClosable: true,
        });
        refreshData();
      } catch (err: any) {
        handleApiError(err, `deleting ${entityConfig?.label.toLowerCase()}`);
      }
    },
    [entityConfig, entityName, toast, refreshData, data]
  );

  const handleAdd = () => {
    setSelectedItem({
      user: {},
      other_access_roles: [],
      is_active: true,
      is_available: true,
    });
    setCurrentRecipes([]);
    setIsEditing(false);
    onOpen();
  };

  const handleEdit = useCallback(
    (item: any) => {
      const otherRoles = Array.isArray(item.other_access_roles)
        ? item.other_access_roles
        : [];
      setSelectedItem({
        ...item,
        user: { ...item.user } || {},
        other_access_roles: otherRoles,
      });
      setCurrentRecipes(item.recipes || []);
      setIsEditing(true);
      onOpen();
    },
    [onOpen]
  );

  const handleAddRecipe = () => {
    setCurrentRecipes((prev) => [
      ...prev,
      {
        id: uuidv4(),
        food_id: selectedItem?.id || "",
        inventory_product_id: "",
        quantity_used: 0,
        unit_of_measure: "",
      },
    ]);
  };

  const handleRecipeChange = (
    index: number,
    field: keyof RecipeItem,
    value: any
  ) => {
    setCurrentRecipes((prev) =>
      prev.map((recipe, i) =>
        i === index ? { ...recipe, [field]: value } : recipe
      )
    );
  };

  const handleRemoveRecipe = (id: string) => {
    setCurrentRecipes((prev) => prev.filter((recipe) => recipe.id !== id));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!entityConfig || !selectedItem) return;

    // Validate form
    const validationError = validateForm();
    if (validationError) {
      toast({
        title: "Validation Error",
        description: validationError,
        status: "error",
        duration: 5000,
        isClosable: true,
      });
      return;
    }

    setIsSubmitting(true);
    try {
      if (isEditing) {
        if (entityName === "employees" && selectedItem.user) {
          await fetchData(
            "users",
            selectedItem.user.id,
            selectedItem.user,
            "PUT"
          );
        }
        if (entityName === "foods" || entityName === "recipes") {
          // Include recipes directly in the food update
          const foodWithRecipes = {
            ...selectedItem,
            recipes: currentRecipes,
          };
          await fetchData(
            entities.foods.endpoint,
            selectedItem.id,
            foodWithRecipes,
            "PUT"
          );
        } else {
          await fetchData(
            entityConfig.endpoint,
            selectedItem.id,
            selectedItem,
            "PUT"
          );
        }
        toast({
          title: "Updated",
          description: `${entityConfig.label} updated successfully.`,
          status: "success",
          duration: 3000,
          isClosable: true,
        });
      } else {
        const newItem = {
          ...selectedItem,
          id: uuidv4(),
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };

        if (entityName === "employees") {
          const newUserId = uuidv4();
          const newUser = {
            id: newUserId,
            ...selectedItem.user,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };
          newItem.user_id = newUserId;
          await fetchData("users", undefined, newUser, "POST");
        }

        if (entityName === "foods" || entityName === "recipes") {
          // Include recipes directly in the new food creation
          newItem.recipes = currentRecipes;
          await fetchData(entities.foods.endpoint, undefined, newItem, "POST");
        } else {
          await fetchData(entityConfig.endpoint, undefined, newItem, "POST");
        }

        toast({
          title: "Added",
          description: `${entityConfig.label} added successfully.`,
          status: "success",
          duration: 3000,
          isClosable: true,
        });
      }
      onClose();
      refreshData();
    } catch (err: any) {
      handleApiError(
        err,
        `${
          isEditing ? "updating" : "adding"
        } ${entityConfig.label.toLowerCase()}`
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleItemChange = (field: string, value: any) => {
    setSelectedItem((prev: any) => ({ ...prev, [field]: value }));
  };

  const handleUserChange = (field: string, value: any) => {
    setSelectedItem((prev: any) => ({
      ...prev,
      user: { ...prev.user, [field]: value },
    }));
  };

  const excludedFields = useMemo(
    () => ["created_at", "updated_at", "store_id", "tenant_id"],
    []
  );

  const actionColumn = useMemo(
    () => ({
      accessorKey: "actions",
      header: "Actions",
      isSortable: false,
      cell: (row: any) => (
        <HStack>
          <IconButton
            aria-label="Edit"
            icon={<FaEdit />}
            onClick={() => handleEdit(row)}
            size="sm"
            colorScheme="blue"
          />
          <IconButton
            aria-label="Delete"
            icon={<FaTrash />}
            onClick={() => handleDelete(row.id)}
            size="sm"
            colorScheme="red"
          />
        </HStack>
      ),
    }),
    [handleDelete, handleEdit]
  );

  const columns: Column[] = useMemo(() => {
    if (!entityConfig) {
      return [];
    }

    let entityColumns: Column[] = [];

    if (entityName === "employees") {
      entityColumns = [
        { accessorKey: "first_name", header: "First Name", isSortable: true },
        { accessorKey: "last_name", header: "Last Name", isSortable: true },
        { accessorKey: "email", header: "Email", isSortable: true },
        { accessorKey: "mainAccessRoleName", header: "Role", isSortable: true },
        { accessorKey: "jobTitleName", header: "Position", isSortable: true },
        { accessorKey: "hire_date", header: "Hire Date", isSortable: true },
      ];
    } else if (entityName === "foods" || entityName === "recipes") {
      entityColumns = [
        { accessorKey: "name", header: "Name", isSortable: true },
        { accessorKey: "category_name", header: "Category", isSortable: true },
        { accessorKey: "description", header: "Description", isSortable: true },
        { accessorKey: "price", header: "Price (ZAR)", isSortable: true },
        {
          accessorKey: "recipes",
          header: "Ingredients",
          cell: (row: Food) => (
            <VStack align="start" spacing={1}>
              {(row.recipes || []).map((recipe: RecipeItem, index: number) => {
                const product = inventoryProducts.find(
                  (p) => p.id === recipe.inventory_product_id
                );
                const unit = units.find((u) => u.id === recipe.unit_of_measure);
                return (
                  <Text key={index} fontSize="sm">
                    - {recipe.quantity_used}{" "}
                    {unit?.symbol || recipe.unit_of_measure} of{" "}
                    {product?.name || "N/A"}
                  </Text>
                );
              })}
            </VStack>
          ),
          isSortable: false,
        },
      ];
    } else if (entityName === "payrolls") {
      entityColumns = [
        { accessorKey: "employee_name", header: "Employee", isSortable: true },
        {
          accessorKey: "payment_cycle",
          header: "Payment Cycle",
          isSortable: true,
        },
        {
          accessorKey: "pay_period_start",
          header: "Period Start",
          isSortable: true,
        },
        {
          accessorKey: "pay_period_end",
          header: "Period End",
          isSortable: true,
        },
        { accessorKey: "net_pay", header: "Net Pay", isSortable: true },
        { accessorKey: "status", header: "Status", isSortable: true },
      ];
    } else if (entityName === "companies") {
      entityColumns = [
        { accessorKey: "name", header: "Company Name", isSortable: true },
        { accessorKey: "country", header: "Country", isSortable: true },
        {
          accessorKey: "metrics.total_employees",
          header: "Total Employees",
          isSortable: true,
          cell: (row: Company) => row.metrics.total_employees,
        },
      ];
    } else {
      entityColumns = entityConfig.fields
        .filter((field) => !excludedFields.includes(field))
        .map((field) => ({
          accessorKey: field,
          header: field
            .replace(/_/g, " ")
            .replace(/\b\w/g, (c) => c.toUpperCase()),
          isSortable: true,
        }));
    }
    return [actionColumn, ...entityColumns];
  }, [
    entityConfig,
    entityName,
    excludedFields,
    actionColumn,
    inventoryProducts,
    units,
  ]);

  if (!entityConfig) {
    // This will be true for components that have their own management
    return null;
  }
  if (isLoading) {
    return (
      <Center minH="100vh">
        <Spinner size="xl" />
      </Center>
    );
  }

  if (error) {
    return (
      <Box p={8}>
        <Heading>Error</Heading>
        <Text>Failed to load data for {entityName}.</Text>
        <Text color="red.500">{error}</Text>
        <Button mt={4} onClick={refreshData}>
          Retry
        </Button>
      </Box>
    );
  }

  // Render special form fields for different entities
  const renderEmployeeFormFields = () => (
    <>
      <FormControl isRequired>
        <FormLabel>First Name</FormLabel>
        <Input
          value={selectedItem?.first_name || ""}
          onChange={(e) => handleItemChange("first_name", e.target.value)}
          placeholder="Enter first name"
        />
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Last Name</FormLabel>
        <Input
          value={selectedItem?.last_name || ""}
          onChange={(e) => handleItemChange("last_name", e.target.value)}
          placeholder="Enter last name"
        />
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Email</FormLabel>
        <Input
          type="email"
          value={selectedItem?.user?.email || ""}
          onChange={(e) => handleUserChange("email", e.target.value)}
          placeholder="Enter email address"
        />
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Main Access Role</FormLabel>
        <Select
          placeholder="Select role"
          value={selectedItem?.main_access_role_id || ""}
          onChange={(e) =>
            handleItemChange("main_access_role_id", e.target.value)
          }
        >
          {accessRoles.map((role) => (
            <option key={role.id} value={role.id}>
              {role.name}
            </option>
          ))}
        </Select>
      </FormControl>
      <FormControl>
        <FormLabel>Other Access Roles</FormLabel>
        <CheckboxGroup
          value={selectedItem?.other_access_roles || []}
          onChange={(val) => handleItemChange("other_access_roles", val)}
        >
          <Stack direction="row" flexWrap="wrap">
            {accessRoles.map((role) => (
              <Checkbox key={role.id} value={role.id}>
                {role.name}
              </Checkbox>
            ))}
          </Stack>
        </CheckboxGroup>
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Job Title</FormLabel>
        <Select
          placeholder="Select job title"
          value={selectedItem?.job_title_id || ""}
          onChange={(e) => handleItemChange("job_title_id", e.target.value)}
        >
          {jobTitles.map((title) => (
            <option key={title.id} value={title.id}>
              {title.title}
            </option>
          ))}
        </Select>
      </FormControl>
      <FormControl>
        <FormLabel>Hire Date</FormLabel>
        <Input
          type="date"
          value={selectedItem?.hire_date || ""}
          onChange={(e) => handleItemChange("hire_date", e.target.value)}
        />
      </FormControl>
      <FormControl>
        <FormLabel>Salary</FormLabel>
        <NumberInput
          value={selectedItem?.salary || 0}
          onChange={(_, value) => handleItemChange("salary", value)}
        >
          <NumberInputField />
          <NumberInputStepper>
            <NumberIncrementStepper />
            <NumberDecrementStepper />
          </NumberInputStepper>
        </NumberInput>
      </FormControl>
      <FormControl>
        <Checkbox
          isChecked={selectedItem?.is_active}
          onChange={(e) => handleItemChange("is_active", e.target.checked)}
        >
          Is Active
        </Checkbox>
      </FormControl>
    </>
  );

  const renderFoodFormFields = () => (
    <>
      <FormControl isRequired>
        <FormLabel>Food Name</FormLabel>
        <Input
          value={selectedItem?.name || ""}
          onChange={(e) => handleItemChange("name", e.target.value)}
          placeholder="Enter food name"
        />
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Price (ZAR)</FormLabel>
        <NumberInput
          value={selectedItem?.price || 0}
          onChange={(_, value) => handleItemChange("price", value)}
          min={0}
          precision={2}
        >
          <NumberInputField />
          <NumberInputStepper>
            <NumberIncrementStepper />
            <NumberDecrementStepper />
          </NumberInputStepper>
        </NumberInput>
      </FormControl>
      <FormControl isRequired>
        <FormLabel>Category</FormLabel>
        <Select
          placeholder="Select category"
          value={selectedItem?.category_id || ""}
          onChange={(e) => handleItemChange("category_id", e.target.value)}
        >
          {foodCategories.map((category: any) => (
            <option key={category.id} value={category.id}>
              {category.name}
            </option>
          ))}
        </Select>
      </FormControl>
      <FormControl>
        <FormLabel>Description</FormLabel>
        <Textarea
          value={selectedItem?.description || ""}
          onChange={(e) => handleItemChange("description", e.target.value)}
          placeholder="Enter food description"
        />
      </FormControl>
      <FormControl>
        <FormLabel>Preparation Time (minutes)</FormLabel>
        <NumberInput
          value={selectedItem?.preparation_time || 0}
          onChange={(_, value) => handleItemChange("preparation_time", value)}
          min={0}
        >
          <NumberInputField />
          <NumberInputStepper>
            <NumberIncrementStepper />
            <NumberDecrementStepper />
          </NumberInputStepper>
        </NumberInput>
      </FormControl>
      <FormControl>
        <Checkbox
          isChecked={selectedItem?.is_available}
          onChange={(e) => handleItemChange("is_available", e.target.checked)}
        >
          Is Available
        </Checkbox>
      </FormControl>

      <Box w="100%">
        <Heading size="md" mb={4}>
          Recipes
        </Heading>
        <VStack spacing={4} align="stretch">
          {currentRecipes.map((recipe, index) => (
            <HStack
              key={recipe.id}
              spacing={2}
              borderWidth="1px"
              p={4}
              borderRadius="lg"
            >
              <FormControl>
                <FormLabel>Product</FormLabel>
                <Select
                  placeholder="Select inventory product"
                  value={recipe.inventory_product_id}
                  onChange={(e) =>
                    handleRecipeChange(
                      index,
                      "inventory_product_id",
                      e.target.value
                    )
                  }
                >
                  {inventoryProducts.map((product) => (
                    <option key={product.id} value={product.id}>
                      {product.name}
                    </option>
                  ))}
                </Select>
              </FormControl>
              <FormControl w="30%">
                <FormLabel>Quantity</FormLabel>
                <NumberInput
                  value={recipe.quantity_used}
                  onChange={(_, value) =>
                    handleRecipeChange(index, "quantity_used", value)
                  }
                  min={0}
                  precision={2}
                >
                  <NumberInputField />
                  <NumberInputStepper>
                    <NumberIncrementStepper />
                    <NumberDecrementStepper />
                  </NumberInputStepper>
                </NumberInput>
              </FormControl>
              <FormControl w="30%">
                <FormLabel>Unit</FormLabel>
                <Select
                  placeholder="Select unit"
                  value={recipe.unit_of_measure}
                  onChange={(e) =>
                    handleRecipeChange(index, "unit_of_measure", e.target.value)
                  }
                >
                  {units.map((unit) => (
                    <option key={unit.id} value={unit.id}>
                      {unit.symbol}
                    </option>
                  ))}
                </Select>
              </FormControl>
              <IconButton
                icon={<FaTrash />}
                aria-label="Remove recipe item"
                onClick={() => handleRemoveRecipe(recipe.id)}
                colorScheme="red"
                alignSelf="flex-end"
                mt={6}
              />
            </HStack>
          ))}
          <Button
            leftIcon={<FaPlus />}
            onClick={handleAddRecipe}
            colorScheme="teal"
            variant="outline"
          >
            Add Recipe Item
          </Button>
        </VStack>
      </Box>
    </>
  );

  const renderHRFormFields = () => (
    <>
      <FormControl isRequired>
        <FormLabel>Employee</FormLabel>
        <Select
          placeholder="Select employee"
          value={selectedItem?.employee_id || ""}
          onChange={(e) => handleItemChange("employee_id", e.target.value)}
        >
          {allEmployees.map((emp: any) => (
            <option key={emp.id} value={emp.id}>
              {emp.first_name} {emp.last_name}
            </option>
          ))}
        </Select>
      </FormControl>
      {entityName === "payrolls" && (
        <>
          <FormControl isRequired>
            <FormLabel>Payment Cycle</FormLabel>
            <Select
              value={selectedItem?.payment_cycle || ""}
              onChange={(e) =>
                handleItemChange("payment_cycle", e.target.value)
              }
            >
              <option value="weekly">Weekly</option>
              <option value="bi-weekly">Bi-Weekly</option>
              <option value="monthly">Monthly</option>
            </Select>
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Pay Period Start</FormLabel>
            <Input
              type="date"
              value={selectedItem?.pay_period_start || ""}
              onChange={(e) =>
                handleItemChange("pay_period_start", e.target.value)
              }
            />
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Pay Period End</FormLabel>
            <Input
              type="date"
              value={selectedItem?.pay_period_end || ""}
              onChange={(e) =>
                handleItemChange("pay_period_end", e.target.value)
              }
            />
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Gross Pay</FormLabel>
            <NumberInput
              value={selectedItem?.gross_pay || 0}
              onChange={(_, value) => handleItemChange("gross_pay", value)}
              min={0}
              precision={2}
            >
              <NumberInputField />
              <NumberInputStepper>
                <NumberIncrementStepper />
                <NumberDecrementStepper />
              </NumberInputStepper>
            </NumberInput>
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Tax Deductions</FormLabel>
            <NumberInput
              value={selectedItem?.tax_deductions || 0}
              onChange={(_, value) => handleItemChange("tax_deductions", value)}
              min={0}
              precision={2}
            >
              <NumberInputField />
              <NumberInputStepper>
                <NumberIncrementStepper />
                <NumberDecrementStepper />
              </NumberInputStepper>
            </NumberInput>
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Net Pay</FormLabel>
            <NumberInput
              value={selectedItem?.net_pay || 0}
              onChange={(_, value) => handleItemChange("net_pay", value)}
              min={0}
              precision={2}
            >
              <NumberInputField />
              <NumberInputStepper>
                <NumberIncrementStepper />
                <NumberDecrementStepper />
              </NumberInputStepper>
            </NumberInput>
          </FormControl>
          <FormControl isRequired>
            <FormLabel>Status</FormLabel>
            <Select
              value={selectedItem?.status || ""}
              onChange={(e) => handleItemChange("status", e.target.value)}
            >
              <option value="pending">Pending</option>
              <option value="processing">Processing</option>
              <option value="paid">Paid</option>
              <option value="failed">Failed</option>
            </Select>
          </FormControl>
        </>
      )}
    </>
  );

  const renderGenericFormFields = () => (
    <>
      {entityConfig?.fields
        .filter((field) => !excludedFields.includes(field))
        .map((field) => (
          <FormControl
            key={field}
            isRequired={
              !field.includes("description") && !field.includes("notes")
            }
          >
            <FormLabel>
              {field
                .replace(/_/g, " ")
                .replace(/\b\w/g, (c) => c.toUpperCase())}
            </FormLabel>
            {field.includes("description") || field.includes("notes") ? (
              <Textarea
                value={selectedItem?.[field] || ""}
                onChange={(e) => handleItemChange(field, e.target.value)}
                placeholder={`Enter ${field.replace(/_/g, " ")}`}
              />
            ) : (
              <Input
                value={selectedItem?.[field] || ""}
                onChange={(e) => handleItemChange(field, e.target.value)}
                placeholder={`Enter ${field.replace(/_/g, " ")}`}
                type={
                  field.includes("email")
                    ? "email"
                    : field.includes("date")
                    ? "date"
                    : "text"
                }
              />
            )}
          </FormControl>
        ))}
    </>
  );

  return (
    <Box p={8}>
      <Flex mb={6} align="center">
        <Heading as="h1" size="xl">
          {entityConfig?.label} Management
        </Heading>
        <Spacer />
        <Button colorScheme="green" leftIcon={<FaPlus />} onClick={handleAdd}>
          Add New {entityConfig?.label}
        </Button>
      </Flex>

      <DataTable columns={columns} data={data} />

      <Modal
        isOpen={isOpen}
        onClose={onClose}
        size="xl"
        scrollBehavior="inside"
      >
        <ModalOverlay />
        <ModalContent as="form" onSubmit={handleSubmit}>
          <ModalHeader>
            {isEditing
              ? `Edit ${
                  entityName === "recipes" ? "Food Recipe" : entityConfig.label
                }`
              : `Add ${entityName === "recipes" ? "Food" : entityConfig.label}`}
          </ModalHeader>
          <ModalCloseButton />
          <ModalBody maxH="70vh" overflowY="auto">
            <VStack spacing={4}>
              {entityName === "employees"
                ? renderEmployeeFormFields()
                : entityName === "foods" || entityName === "recipes"
                ? renderFoodFormFields()
                : ["timesheets", "payrolls", "companies"].includes(entityName)
                ? renderHRFormFields()
                : renderGenericFormFields()}
            </VStack>
          </ModalBody>
          <ModalFooter>
            <Button
              colorScheme="red"
              mr={3}
              onClick={onClose}
              isDisabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button
              colorScheme="green"
              type="submit"
              isLoading={isSubmitting}
              loadingText={isEditing ? "Saving..." : "Adding..."}
            >
              {isEditing ? "Save" : "Add"}
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>
    </Box>
  );
}


=== ENTITIES CONFIG ===
// src/app/config/entities.ts

import { ReactNode } from "react";

export interface EntityConfig {
  subMenus?: any;
  label: string;
  fields: string[];
  endpoint: string;
}

// --- Core POS Entities ---

export interface Food {
  id: string;
  name: string;
  description: string;
  price: number;
  category_id: string;
  image_url?: string;
  preparation_time?: number;
  allergens?: string[];
  tenant_id: string;
  recipes?: RecipeItem[];
  store_id?: string;
  is_available?: boolean;
  created_at?: string;
  updated_at?: string;
}

export interface StoreFood {
  food_id: string;
  store_id: string;
  is_available: boolean;
}

export interface RecipeItem {
  id: string;
  food_id: string;
  inventory_product_id: string;
  quantity_used: number;
  unit_of_measure: string;
  created_at?: string;
  updated_at?: string;
}

export interface Order {
  id: string;
  store_id?: string;
  table_id: string | null;
  customer_id: string | null;
  total_amount: number;
  status: string;
  notes: string;
  created_at: string;
  updated_at: string;
  items: OrderItem[];
  subtotal_amount: number;
  tax_amount: number;
  discount_amount: number;
  employee_id?: string;
  order_type?: "dine-in" | "takeaway";
  payment_status?: string;
  payment_method?: string;
}

export interface OrderItem {
  id: string;
  order_id: string;
  food_id: string;
  quantity: number;
  price: number;
  sub_total: number;
  notes?: string;
  created_at: string;
  updated_at: string;
  name: string;
  price_at_sale: number;
}

export interface Category {
  id: string;
  name: string;
  description?: string;
  created_at?: string;
  updated_at?: string;
}

export interface invCategory {
  id: string;
  name: string;
  description?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Customer {
  id: string;
  first_name: string;
  last_name?: string;
  email?: string;
  phone_number?: string;
  loyalty_points?: number;
  created_at?: string;
  updated_at?: string;
  store_id: string;
}

export interface Table {
  id: string;
  name: string;
  capacity: number;
  location: string;
  status: string;
  current_order_id?: string | null;
  created_at?: string;
  updated_at?: string;
  store_id: string;
}

export interface AccessRole {
  id: string;
  name: string;
  description: string;
  permissions: string[];
  landing_page: string;
  created_at?: string;
  updated_at?: string;
}

// Updated Employee Interface with HR details
export interface Employee {
  id: string;
  user_id: string;
  job_title_id: string;
  access_role_ids: string[];
  tenant_id: string;
  store_id: string;
  main_access_role_id: string;
  hire_date: string;
  salary: number;
  first_name: string;
  last_name?: string;
  avatar_url?: string;
  created_at?: string;
  updated_at?: string;

  // New HR fields
  employee_id?: string;
  full_name?: string;
  middle_name?: string;
  suffix?: string;
  profile_photo_url?: string;
  personal_details?: PersonalDetails;
  contact_details?: ContactDetails;
  employment_details?: EmploymentDetails;
  status?: EmployeeStatus;
}

export interface PersonalDetails {
  citizenship: string;
  gender: string;
  birth_date: string;
  age: string;
}

export interface ContactDetails {
  cell_phone: string;
  whatsapp_number: string;
  email: string;
  address: string;
}

export interface EmploymentDetails {
  job_title: string;
  team: string;
  employment_type: string;
  location: string;
}

export interface EmployeeStatus {
  current_status: string;
  on_leave_since?: string;
  termination_date?: string;
  termination_reason?: string;
}

export interface Reservation {
  id: string;
  customer_id: string;
  table_id: string | null;
  date_time: string;
  number_of_guests: number;
  status: string;
  notes?: string;
  created_at?: string;
  updated_at?: string;
  store_id: string;
}

// --- New HR Entities ---

// Update the Shift interface to include recurrence details
export interface Shift {
  id: string;
  employee_id: string;
  start: string; // ISO string
  end: string; // ISO string
  title?: string;
  employee_name?: string;
  color?: string;
  // --- New fields ---
  active?: boolean;
  recurring?: boolean;
  updated_at?: string;
  created_at?: string;
}

export interface Timesheet {
  timesheet_id: string;
  employee_id: string;
  start_date: string;
  end_date: string;
  daily_hours: { [date: string]: string };
  total_weekly_hours: string;
}

// This interface represents a single clock-in/out record.
export interface TimesheetEntry {
  id: string;
  employee_id: string;
  clock_in: string; // ISO 8601 string
  clock_out: string | null; // ISO 8601 string or null if still clocked in
  duration_minutes: number | null; // Calculated duration in minutes
  created_at: string;
  updated_at: string;
}

export interface Company {
  company_id: string;
  name: string;
  country: string;
  tax_details: TaxDetails;
  metrics: CompanyMetrics;
}

export interface TaxDetails {
  tax_year: string;
  efiling_admin: string;
  related_docs: string;
}

export interface CompanyMetrics {
  total_employees: number;
  active_employees: number;
  employees_on_leave: number;
  terminated_employees: number;
  full_time_employees: number;
  part_time_employees: number;
  contract_employees: number;
  employee_invites: EmployeeInvites;
}

export interface EmployeeInvites {
  sent: number;
  active: number;
  require_attention: number;
}

// Updated Store interface with new fields
export interface Store {
  id: string;
  name: string;
  address: string;
  phone: string;
  email: string;
  tenant_id: string;
  created_at: string;
  updated_at: string;
  location?: string;
  manager_id?: string;
  kiosk_user_id: string; // ADDED: Field for the kiosk account
}

// --- Other Entities ---

export interface Tenant {
  id: string;
  name: string;
  email: string;
  password?: string;
  remember_token?: string;
  created_at: string;
  updated_at: string;
  phone?: string;
  address?: string;
}

export interface Domain {
  id: string;
  tenant_id: string;
  domain: string;
  is_primary: boolean;
  created_at: string;
  updated_at: string;
}

export interface Job {
  id: string;
  queue: string;
  payload: string;
  attempts: number;
  reserved_at: number | null;
  available_at: number;
  created_at: number;
}

export interface FailedJob {
  id: string;
  uuid: string;
  connection: string;
  queue: string;
  payload: string;
  exception: string;
  failed_at: string;
}

export interface PasswordReset {
  email: string;
  token: string;
  created_at: string;
}

export interface User {
  id: string;
  name: string;
  email: string;
  email_verified_at: string | null;
  password: string;
  remember_token: string | null;
  created_at: string;
  updated_at: string;
  cashAccounts?: any[];
  cardAccounts?: any[];
  onlineAccounts?: any[];
  gpayAccounts?: any[];
  phonepeAccounts?: any[];
  amazonpayAccounts?: any[];
  locations?: any[];
}

export interface Payment {
  id: string;
  order_id: string;
  payment_method_id: string;
  amount: number;
  payment_date: string;
  transaction_id: string | null;
  status: string;
  created_at: string;
  updated_at: string;
}

export interface Stock {
  id: string;
  food_id: string;
  quantity: number;
  unit_id: string;
  supplier_id: string;
  last_restock_date: string;
  expiration_date: string | null;
  created_at: string;
  updated_at: string;
}

export interface StockAdjustment {
  id: string;
  stock_id: string;
  quantity_change: number;
  reason: string;
  adjustment_date: string;
  created_at: string;
  updated_at: string;
}

export interface Tax {
  id: string;
  name: string;
  percentage: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface JobTitle {
  id: string;
  title: string;
  description: string;
  created_at: string;
  updated_at: string;
}

export interface PaymentMethod {
  id: string;
  name: string;
  description: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface Brand {
  id: string;
  name: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface Unit {
  id: string;
  name: string;
  symbol: string;
  created_at: string;
  updated_at: string;
}

export interface Supplier {
  id: string;
  name: string;
  contact_person: string;
  phone: string;
  email: string;
  address: string;
  created_at: string;
  updated_at: string;
}

export interface ContactMessage {
  id: string;
  name: string;
  email: string;
  subject: string;
  message: string;
  created_at: string;
  updated_at: string;
}

export interface Report {
  id: string;
  user_id: string;
  user_name: string;
  user_role: string;
  attempted_path: string;
  attempts: number;
  last_attempt_at: string;
  created_at: string;
}

export interface InventoryProduct {
  id: string;
  name: string;
  description?: string;
  sku: string;
  unit_of_measure: string;
  tenant_id: string;
  unit_cost: number;
  quantity_in_stock: number;
  reorder_level: number;
  supplier_id?: string;
  inv_category_id?: string;
  location_in_warehouse?: string;
  last_restocked_at?: string;
  created_at?: string;
  updated_at?: string;
}

// Add these interfaces to your entities.ts file

export interface Payroll {
  id: string;
  employee_id: string;
  pay_period_start: string;
  pay_period_end: string;
  payment_cycle: "weekly" | "bi-weekly" | "monthly";
  gross_pay: number;
  tax_deductions: number;
  net_pay: number;
  status: "pending" | "processing" | "paid" | "failed";
  hours_worked: number;
  overtime_hours: number;
  overtime_rate: number;
  deductions: PayrollDeduction[];
  created_at: string;
  updated_at: string;
  store_id: string;
}

export interface PayrollDeduction {
  id: string;
  payroll_id: string;
  type: "tax" | "insurance" | "retirement" | "other";
  description: string;
  amount: number;
  created_at: string;
  updated_at: string;
}

export interface PayrollSettings {
  id: string;
  store_id: string;
  default_payment_cycle: "weekly" | "bi-weekly" | "monthly";
  tax_rate: number;
  overtime_multiplier: number;
  created_at: string;
  updated_at: string;
}

export const entities: { [key: string]: EntityConfig } = {
  // Core POS Entities
  payrolls: {
    label: "Payrolls",
    endpoint: "/api/payrolls",
    fields: [
      "id",
      "employee_id",
      "pay_period_start",
      "pay_period_end",
      "payment_cycle",
      "gross_pay",
      "tax_deductions",
      "net_pay",
      "status",
      "hours_worked",
      "overtime_hours",
      "overtime_rate",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },

  payroll_settings: {
    label: "Payroll Settings",
    endpoint: "/api/payroll_settings",
    fields: [
      "id",
      "store_id",
      "default_payment_cycle",
      "tax_rate",
      "overtime_multiplier",
      "created_at",
      "updated_at",
    ],
  },
  inventory_products: {
    label: "Inventory Products",
    endpoint: "/api/inventory_products",
    fields: [
      "id",
      "name",
      "description",
      "sku",
      "unit_of_measure",
      "unit_cost",
      "quantity_in_stock",
      "reorder_level",
      "supplier_id",
      "inv_category_id",
      "location_in_warehouse",
      "last_restock_at",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },
  orders: {
    label: "Orders",
    endpoint: "/api/orders",
    fields: [
      "id",
      "store_id",
      "table_id",
      "customer_id",
      "total_amount",
      "status",
      "notes",
      "created_at",
      "updated_at",
      "items",
      "subtotal_amount",
      "tax_amount",
      "discount_amount",
      "employee_id",
      "order_type",
      "payment_status",
      "payment_method",
    ],
  },
  reports: {
    label: "Reports",
    endpoint: "/api/reports",
    fields: [
      "id",
      "user_id",
      "user_name",
      "user_role",
      "attempted_path",
      "attempts",
      "last_attempt_at",
      "created_at",
    ],
  },
  order_items: {
    label: "Order Items",
    endpoint: "/api/order_items",
    fields: [
      "id",
      "order_id",
      "food_id",
      "quantity",
      "price",
      "sub_total",
      "notes",
      "created_at",
      "updated_at",
      "name",
      "price_at_sale",
    ],
  },
  foods: {
    label: "Foods",
    endpoint: "/api/foods",
    fields: [
      "id",
      "name",
      "description",
      "price",
      "category_id",
      "is_available",
      "image_url",
      "preparation_time",
      "allergens",
      "created_at",
      "updated_at",
      "tenant_id",
      "recipes",
    ],
  },
  store_foods: {
    label: "Store Foods",
    endpoint: "/api/store_foods",
    fields: ["food_id", "store_id", "is_available"],
  },
  recipes: {
    label: "Recipes",
    endpoint: "/api/recipes",
    fields: [
      "id",
      "food_id",
      "inventory_product_id",
      "quantity_used",
      "unit_of_measure",
      "created_at",
      "updated_at",
    ],
  },
  categories: {
    label: "Categories",
    endpoint: "/api/categories",
    fields: [
      "id",
      "name",
      "description",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },
  inv_categories: {
    label: "Inv. Categories",
    endpoint: "/api/inv_categories",
    fields: [
      "id",
      "name",
      "description",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },
  customers: {
    label: "Customers",
    endpoint: "/api/customers",
    fields: [
      "id",
      "first_name",
      "last_name",
      "email",
      "phone_number",
      "loyalty_points",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },
  tables: {
    label: "Tables",
    endpoint: "/api/tables",
    fields: [
      "id",
      "name",
      "capacity",
      "location",
      "status",
      "current_order_id",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },
  employees: {
    label: "Employees",
    endpoint: "/api/employees",
    fields: [
      "id",
      "user_id",
      "job_title_id",
      "access_role_ids",
      "main_access_role_id",
      "hire_date",
      "salary",
      "first_name",
      "last_name",
      "store_id",
      "avatar_url",
      "created_at",
      "updated_at",
      "employee_id",
      "full_name",
      "middle_name",
      "suffix",
      "profile_photo_url",
      "personal_details",
      "contact_details",
      "employment_details",
      "status",
    ],
  },
  access_roles: {
    label: "Access Roles",
    endpoint: "/api/access_roles",
    fields: [
      "id",
      "name",
      "description",
      "permissions",
      "landing_page",
      "created_at",
      "updated_at",
    ],
  },
  reservations: {
    label: "Reservations",
    endpoint: "/api/reservations",
    fields: [
      "id",
      "customer_id",
      "table_id",
      "date_time",
      "number_of_guests",
      "status",
      "notes",
      "created_at",
      "updated_at",
      "store_id",
    ],
  },

  // New HR Entities
  shifts: {
    label: "Shifts",
    endpoint: "/api/shifts",
    fields: [
      "id",
      "employee_id",
      "start",
      "end",
      "title",
      "employee_name",
      "color",
      "created_at",
      "updated_at",
      "active",
      "recurring",
    ],
  },
  timesheetsManagement: {
    label: "Timesheets Management",
    endpoint: "/api/timesheets_management",
    fields: [
      "timesheet_id",
      "employee_id",
      "start_date",
      "end_date",
      "daily_hours",
      "total_weekly_hours",
    ],
  },
  timesheets: {
    label: "Timesheets",
    endpoint: "/api/timesheets",
    fields: ["id", "employee_id", "clock_in", "clock_out", "duration_minutes"],
  },
  payroll: {
    label: "Payrolls",
    endpoint: "/api/payrolls",
    fields: [
      "payroll_id",
      "employee_id",
      "payment_cycle",
      "pay_period_start",
      "pay_period_end",
      "total_wages_due",
      "tax_deductions",
      "net_pay",
      "status",
    ],
  },
  companies: {
    label: "Companies",
    endpoint: "/api/companies",
    fields: ["company_id", "name", "country", "tax_details", "metrics"],
  },

  // Other Entities
  tenants: {
    label: "Tenants",
    endpoint: "/api/tenants",
    fields: [
      "id",
      "name",
      "email",
      "password",
      "remember_token",
      "phone",
      "address",
      "created_at",
      "updated_at",
    ],
  },
  domains: {
    label: "Domains",
    endpoint: "/api/domains",
    fields: [
      "id",
      "tenant_id",
      "domain",
      "is_primary",
      "created_at",
      "updated_at",
    ],
  },
  jobs: {
    label: "Jobs",
    endpoint: "/api/jobs",
    fields: [
      "id",
      "queue",
      "payload",
      "attempts",
      "reserved_at",
      "available_at",
      "created_at",
    ],
  },
  failed_jobs: {
    label: "Failed Jobs",
    endpoint: "/api/failed_jobs",
    fields: [
      "id",
      "uuid",
      "connection",
      "queue",
      "payload",
      "exception",
      "failed_at",
    ],
  },
  password_resets: {
    label: "Password Resets",
    endpoint: "/api/password_resets",
    fields: ["email", "token", "created_at"],
  },
  users: {
    label: "Users",
    endpoint: "/api/users",
    fields: [
      "id",
      "name",
      "email",
      "email_verified_at",
      "password",
      "remember_token",
      "created_at",
      "updated_at",
      "cashAccounts",
      "cardAccounts",
      "onlineAccounts",
      "gpayAccounts",
      "phonepeAccounts",
      "amazonpayAccounts",
      "locations",
    ],
  },
  payments: {
    label: "Payments",
    endpoint: "/api/payments",
    fields: [
      "id",
      "order_id",
      "payment_method_id",
      "amount",
      "payment_date",
      "transaction_id",
      "status",
      "created_at",
      "updated_at",
    ],
  },
  stocks: {
    label: "Stocks",
    endpoint: "/api/stocks",
    fields: [
      "id",
      "food_id",
      "quantity",
      "unit_id",
      "supplier_id",
      "last_restock_date",
      "expiration_date",
      "created_at",
      "updated_at",
    ],
  },
  recipe_items: {
    label: "Recipe Items",
    endpoint: "/api/recipe_items",
    fields: [
      "id",
      "food_id",
      "inventory_product_id",
      "quantity_used",
      "unit_of_measure",
      "created_at",
      "updated_at",
    ],
  },
  stock_adjustments: {
    label: "Stock Adjustments",
    endpoint: "/api/stock_adjustments",
    fields: [
      "id",
      "stock_id",
      "quantity_change",
      "reason",
      "adjustment_date",
      "created_at",
      "updated_at",
    ],
  },
  taxes: {
    label: "Taxes",
    endpoint: "/api/taxes",
    fields: [
      "id",
      "name",
      "percentage",
      "is_active",
      "created_at",
      "updated_at",
    ],
  },
  stores: {
    label: "Stores",
    endpoint: "/api/stores",
    fields: [
      "id",
      "name",
      "address",
      "phone",
      "email",
      "tenant_id",
      "created_at",
      "updated_at",
      "location",
      "manager_id",
    ],
  },
  job_titles: {
    label: "Job Titles",
    endpoint: "/api/job_titles",
    fields: ["id", "title", "description", "created_at", "updated_at"],
  },
  payment_methods: {
    label: "Payment Methods",
    endpoint: "/api/payment_methods",
    fields: [
      "id",
      "name",
      "description",
      "is_active",
      "created_at",
      "updated_at",
    ],
  },
  brands: {
    label: "Brands",
    endpoint: "/api/brands",
    fields: ["id", "name", "description", "created_at", "updated_at"],
  },
  suppliers: {
    label: "Suppliers",
    endpoint: "/api/suppliers",
    fields: [
      "id",
      "name",
      "contact_person",
      "phone",
      "email",
      "address",
      "created_at",
      "updated_at",
    ],
  },
  contact_messages: {
    label: "Contact Messages",
    endpoint: "/api/contact_messages",
    fields: [
      "id",
      "name",
      "email",
      "subject",
      "message",
      "created_at",
      "updated_at",
    ],
  },
  units: {
    label: "Units",
    endpoint: "/api/units",
    fields: ["id", "name", "symbol", "created_at", "updated_at"],
    subMenus: [
      {
        label: "Common Units",
        items: [
          { id: "milliliter", name: "Milliliter", symbol: "ml" },
          { id: "liter", name: "Liter", symbol: "L" },
          { id: "ounce_fl", name: "Fluid Ounce", symbol: "fl oz" },
          { id: "cup", name: "Cup", symbol: "cup" },
          { id: "pint", name: "Pint", symbol: "pt" },
          { id: "quart", name: "Quart", symbol: "qt" },
          { id: "gallon", name: "Gallon", symbol: "gal" },
          { id: "teaspoon", name: "Teaspoon", symbol: "tsp" },
          { id: "tablespoon", name: "Tablespoon", symbol: "tbsp" },
          { id: "gram", name: "Gram", symbol: "g" },
          { id: "kilogram", name: "Kilogram", symbol: "kg" },
          { id: "milligram", name: "Milligram", symbol: "mg" },
          { id: "ounce_wt", name: "Ounce", symbol: "oz" },
          { id: "pound", name: "Pound", symbol: "lb" },
          { id: "unit", name: "Unit", symbol: "unit" },
          { id: "each", name: "Each", symbol: "ea" },
          { id: "can", name: "Can", symbol: "can" },
          { id: "bottle", name: "Bottle", symbol: "bottle" },
          { id: "box", name: "Box", symbol: "box" },
          { id: "bag", name: "Bag", symbol: "bag" },
          { id: "case", name: "Case", symbol: "case" },
        ],
      },
    ],
  },
  purchase_orders: {
    label: "Purchase Orders",
    endpoint: "purchase_orders",
    fields: [
      "id",
      "po_number",
      "supplier_id",
      "site_id",
      "status",
      "order_date",
      "expected_delivery_date",
      "total_amount",
      "ordered_by",
      "notes",
      "items",
      "created_at",
      "updated_at",
    ],
  },

  goods_receipts: {
    label: "Goods Receipts",
    endpoint: "goods_receipts",
    fields: [
      "id",
      "receipt_number",
      "purchase_order_id",
      "receipt_date",
      "received_by",
      "receiving_bin_id",
      "notes",
      "status",
      "received_items",
      "created_at",
      "updated_at",
    ],
  },

  sites: {
    label: "Sites",
    endpoint: "sites",
    fields: ["id", "name", "address", "type", "created_at", "updated_at"],
  },
};


=== SHIFT MANAGEMENT COMPONENTS ===

--- src/app/pos/management/[entityName]/ShiftManagementComponents/ShiftCalendar.tsx ---
// src/app/pos/management/[entityName]/components/ShiftCalendar.tsx

"use client";

import React, { useMemo, useState } from "react";
import moment from 'moment';
import {
    Box,
    HStack,
    IconButton,
    Text,
    useToast,
    Badge,
    VStack,
} from "@chakra-ui/react";
import { CloseIcon } from "@chakra-ui/icons";
import { Employee, Shift } from "../ShiftManagement";
import dynamic from 'next/dynamic';
import { momentLocalizer, Views, View } from 'react-big-calendar';
import withDragAndDrop, { EventInteractionArgs } from 'react-big-calendar/lib/addons/dragAndDrop';
import 'react-big-calendar/lib/css/react-big-calendar.css';
import 'react-big-calendar/lib/addons/dragAndDrop/styles.css';
import { logger } from "@/lib/logger";

// Define a new type for the calendar events
interface CalendarEvent extends Omit<Shift, 'start' | 'end'> {
    start: Date;
    end: Date;
    // The original shift ID is used for dragging and updating
    originalShiftId: string;
    employeeRole?: string;
}

// Dynamically import the Calendar component and wrap it
const Calendar = dynamic(
    async () => {
        const { Calendar: RbcCalendar } = await import('react-big-calendar');
        momentLocalizer(moment);
        const DndCalendar = withDragAndDrop<CalendarEvent, object>(RbcCalendar);
        return DndCalendar;
    },
    { ssr: false, loading: () => <Text>Loading calendar...</Text> }
);

interface ShiftCalendarProps {
    shifts: Shift[];
    employees: Employee[];
    onUpdateShift: (shiftId: string, updates: Partial<Shift>) => void;
    onDeleteShift: (shiftId: string) => void;
    onSelectShift: (shift: Shift) => void;
}

// Role-based color mapping
const roleColors: Record<string, string> = {
    'Cashier': '#3182CE', // Blue
    'Waiter': '#38A169', // Green
    'Server': '#38A169', // Green (alias for Waiter)
    'Kitchen Staff': '#E53E3E', // Red
    'Chef': '#E53E3E', // Red (alias for Kitchen Staff)
    'Manager': '#D69E2E', // Yellow
    'Admin': '#805AD5', // Purple
    'default': '#718096', // Gray
};

// Get color based on employee role
const getRoleColor = (role?: string): string => {
    if (!role) return roleColors.default;

    const normalizedRole = role.toLowerCase();
    for (const [key, color] of Object.entries(roleColors)) {
        if (normalizedRole.includes(key.toLowerCase())) {
            return color;
        }
    }
    return roleColors.default;
};

export default function ShiftCalendar({ shifts, employees, onUpdateShift, onDeleteShift, onSelectShift }: ShiftCalendarProps) {
    const toast = useToast();
    const [date, setDate] = useState<Date>(new Date());
    const [view, setView] = useState<View>(Views.WEEK);
    const [currentView, setCurrentView] = useState<View>(Views.WEEK);

    const events = useMemo(() => {
        logger.info("ShiftCalendar", "Reformatting shifts for calendar...");
        const calendarEvents: CalendarEvent[] = [];

        const now = moment();
        const futureDate = moment().add(1, 'year');

        shifts.forEach(shift => {
            const employee = employees.find(emp => emp.id === shift.employee_id);
            const employeeRole = employee?.role;
            const eventColor = getRoleColor(employeeRole);

            if (shift.recurs) {
                let current = moment(shift.start).day(shift.recurringDay as number);
                if (current.isBefore(now, 'day')) {
                    current = current.add(1, 'week').day(shift.recurringDay as number);
                }

                while (current.isBefore(futureDate)) {
                    const startDateTime = current.clone().set({
                        hour: moment(shift.start).hour(),
                        minute: moment(shift.start).minute(),
                    });
                    const endDateTime = current.clone().set({
                        hour: moment(shift.end).hour(),
                        minute: moment(shift.end).minute(),
                    });

                    calendarEvents.push({
                        ...shift,
                        id: `${shift.id}-${current.format('YYYYMMDD')}`,
                        originalShiftId: shift.id,
                        start: startDateTime.toDate(),
                        end: endDateTime.toDate(),
                        title: `${shift.employee_name} (Recurring)`,
                        color: eventColor,
                        employeeRole,
                    });
                    current.add(1, 'week');
                }
            } else {
                calendarEvents.push({
                    ...shift,
                    originalShiftId: shift.id,
                    start: new Date(shift.start),
                    end: new Date(shift.end),
                    color: eventColor,
                    employeeRole,
                });
            }
        });

        logger.info("ShiftCalendar", "Generated events:", calendarEvents);
        return calendarEvents;
    }, [shifts, employees]);

    const handleEventDrop = async (data: EventInteractionArgs<CalendarEvent>) => {
        const { event, start, end } = data;
        if (!event.originalShiftId) {
            toast({
                title: "Error",
                description: "Cannot update a shift without a valid ID.",
                status: "error",
                duration: 4000,
                isClosable: true,
            });
            return;
        }

        const updates = {
            start: start,
            end: end,
            employee_id: event.employee_id,
        };

        await onUpdateShift(event.originalShiftId, updates);
    };

    const handleSelectEvent = (event: CalendarEvent) => {
        const originalShift = shifts.find(s => s.id === event.originalShiftId);
        if (originalShift) {
            const clickedShift: Shift = {
                ...originalShift,
                start: event.start,
                end: event.end,
            };
            onSelectShift(clickedShift);
        }
    };

    // Simplified event style getter - only handles background color
    const eventStyleGetter = (event: CalendarEvent) => {
        return {
            style: {
                backgroundColor: event.color || roleColors.default,
                borderRadius: '4px',
                opacity: 1,
                fontWeight: 'bold',
                border: 'none',
            },
        };
    };

    // Custom event component with rotated text
    const CustomEvent = ({ event }: { event: CalendarEvent }) => {
        const isMonthView = currentView === Views.MONTH;

        return (
            <Box
                p={1}
                height="100%"
                bg={event.color}
                borderRadius="md"
                _hover={{ bg: `${event.color}CC` }}
                overflow="hidden"
                display="flex"
                alignItems="center"
                justifyContent="center"
            // Remove any width constraints here - let the library handle it
            >
                <VStack
                    spacing={0}
                    align="center"
                    justify="center"
                    width="100%"
                    height="100%"
                    transform={isMonthView ? 'none' : 'rotate(-90deg)'}
                    transformOrigin="center"
                >
                    <Text
                        fontSize="m"
                        fontWeight="bold"
                        color="#333"
                        textAlign="center"
                        noOfLines={1}
                        title={event.employee_name}
                    >
                        {event.employee_name}
                    </Text>
                    {!isMonthView && (
                        <Text fontSize="s" color="#333" textAlign="center" noOfLines={1}>
                            {moment(event.start).format('HH:mm')} - {moment(event.end).format('HH:mm')}
                        </Text>
                    )}
                    {event.employeeRole && !isMonthView && (
                        <Badge
                            fontSize="2xs"
                            colorScheme="gray"
                            variant="solid"
                            opacity={0.8}
                            mt={0.5}
                            color="#333"
                            bg="rgba(255, 255, 255, 0.7)"
                        >
                            {event.employeeRole}
                        </Badge>
                    )}
                    {event.recurs && !isMonthView && (
                        <Badge
                            fontSize="2xs"
                            colorScheme="green"
                            variant="solid"
                            opacity={0.8}
                            mt={0.5}
                            color="#333"
                            bg="rgba(255, 255, 255, 0.7)"
                        >
                            Recurring
                        </Badge>
                    )}
                </VStack>
            </Box>
        );
    };

    const handleViewChange = (newView: View) => {
        setCurrentView(newView);
        setView(newView);
    };

    return (
        <Box height="700px">
            <Box
                borderWidth="1px"
                borderRadius="md"
                p={4}
                bg="white"
                height="100%"
                overflowY="auto"
                sx={{
                    // Target the calendar's toolbar and headers to make them sticky
                    '.rbc-toolbar': {
                        position: 'sticky',
                        top: 0,
                        zIndex: 10,
                        bg: 'white',
                        borderBottom: '1px solid',
                        borderColor: 'gray.200',
                    },
                    '.rbc-time-header': {
                        position: 'sticky',
                        top: '56px',
                        zIndex: 9,
                        bg: 'white',
                    },
                    // Make resize handles more visible
                    '.rbc-addons-dnd-resize-ns-anchor': {
                        height: '8px',
                        '&:nth-of-type(1)': {
                            top: '-4px',
                        },
                        '&:nth-last-of-type(1)': {
                            bottom: '-4px',
                        },
                    },
                    '.rbc-addons-dnd-resize-ew-anchor': {
                        width: '8px',
                        '&:nth-of-type(1)': {
                            left: '-4px',
                        },
                        '&:nth-last-of-type(1)': {
                            right: '-4px',
                        },
                    },
                    // Ensure events are properly positioned
                    '.rbc-event': {
                        overflow: 'hidden !important',
                    },
                }}
            >
                <Calendar
                    localizer={momentLocalizer(moment)}
                    events={events}
                    date={date}
                    view={view}
                    onNavigate={newDate => setDate(newDate)}
                    onView={handleViewChange}
                    views={[Views.MONTH, Views.WEEK, Views.DAY]}
                    selectable
                    onEventDrop={handleEventDrop}
                    onEventResize={handleEventDrop}
                    onSelectEvent={handleSelectEvent}
                    resizable
                    step={15}
                    timeslots={4}
                    showMultiDayTimes
                    dragabbleAccessor={() => true}
                    eventPropGetter={eventStyleGetter}
                    components={{
                        event: CustomEvent,
                    }}
                    dayLayoutAlgorithm={currentView === Views.MONTH ? 'overlap' : 'overlap'}
                />
            </Box>

            {/* Legend for role colors */}
            <Box mt={4} p={3} bg="gray.50" borderRadius="md">
                <Text fontWeight="bold" mb={2} fontSize="sm">Role Legend:</Text>
                <HStack spacing={3} flexWrap="wrap">
                    {Object.entries(roleColors).map(([role, color]) => (
                        <HStack key={role} spacing={1}>
                            <Box w={3} h={3} bg={color} borderRadius="sm" />
                            <Text fontSize="xs">{role}</Text>
                        </HStack>
                    ))}
                </HStack>
            </Box>
        </Box>
    );
}
--- src/app/pos/management/[entityName]/ShiftManagementComponents/ShiftForm.tsx ---
// Create a new component ShiftForm.tsx
"use client";

import React, { useState } from 'react';
import {
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalFooter,
    ModalBody,
    ModalCloseButton,
    Button,
    FormControl,
    FormLabel,
    Input,
    Select,
    VStack,
} from '@chakra-ui/react';
import { Employee } from './ShiftManagement';

interface ShiftFormProps {
    isOpen: boolean;
    onClose: () => void;
    employees: Employee[];
    onSubmit: (shiftData: { employeeId: string; start: string; end: string }) => void;
}

const ShiftForm: React.FC<ShiftFormProps> = ({ isOpen, onClose, employees, onSubmit }) => {
    const [employeeId, setEmployeeId] = useState('');
    const [start, setStart] = useState('');
    const [end, setEnd] = useState('');

    const handleSubmit = () => {
        onSubmit({ employeeId, start, end });
        onClose();
        // Reset form
        setEmployeeId('');
        setStart('');
        setEnd('');
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <ModalOverlay />
            <ModalContent>
                <ModalHeader>Add New Shift</ModalHeader>
                <ModalCloseButton />
                <ModalBody>
                    <VStack spacing={4}>
                        <FormControl isRequired>
                            <FormLabel>Employee</FormLabel>
                            <Select
                                placeholder="Select employee"
                                value={employeeId}
                                onChange={(e) => setEmployeeId(e.target.value)}
                            >
                                {employees.map(emp => (
                                    <option key={emp.id} value={emp.id}>
                                        {emp.name} - {emp.role}
                                    </option>
                                ))}
                            </Select>
                        </FormControl>
                        <FormControl isRequired>
                            <FormLabel>Start Time</FormLabel>
                            <Input
                                type="datetime-local"
                                value={start}
                                onChange={(e) => setStart(e.target.value)}
                            />
                        </FormControl>
                        <FormControl isRequired>
                            <FormLabel>End Time</FormLabel>
                            <Input
                                type="datetime-local"
                                value={end}
                                onChange={(e) => setEnd(e.target.value)}
                            />
                        </FormControl>
                    </VStack>
                </ModalBody>
                <ModalFooter>
                    <Button variant="ghost" mr={3} onClick={onClose}>
                        Cancel
                    </Button>
                    <Button colorScheme="blue" onClick={handleSubmit}>
                        Save Shift
                    </Button>
                </ModalFooter>
            </ModalContent>
        </Modal>
    );
};

export default ShiftForm;
--- src/app/pos/management/[entityName]/ShiftManagementComponents/ShiftUpdateModal.tsx ---
// src/app/pos/management/[entityName]/components/ShiftUpdateModal.tsx
"use client";

import React, { useState, useEffect } from 'react';
import {
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalFooter,
    ModalBody,
    ModalCloseButton,
    Button,
    FormControl,
    FormLabel,
    Input,
    VStack,
    HStack,
    useToast,
    Checkbox,
    Box,
    Text
} from '@chakra-ui/react';
import { Employee as EmployeeDetails, Shift as ShiftDetails } from '../ShiftManagement';
import moment from 'moment';
import { logger } from '@/lib/logger';

interface ShiftUpdateModalProps {
    isOpen: boolean;
    onClose: () => void;
    onUpdateShift: (shiftId: string, updates: Partial<ShiftDetails>) => Promise<void>;
    onDeleteShift: (shiftId: string) => Promise<{ success: boolean; error?: string }>;
    selectedShift: ShiftDetails | null;
    employee: EmployeeDetails | null;
}

const ShiftUpdateModal: React.FC<ShiftUpdateModalProps> = ({ isOpen, onClose, onUpdateShift, onDeleteShift, selectedShift, employee }) => {
    const [startDate, setStartDate] = useState('');
    const [startTime, setStartTime] = useState('09:00');
    const [endTime, setEndTime] = useState('17:00');
    const [recurs, setRecurs] = useState(false);
    const [isSaving, setIsSaving] = useState(false);
    const toast = useToast();

    // Use useEffect to update state when a new shift is selected
    useEffect(() => {
        if (selectedShift) {
            // Split the datetime into date and time components
            const startMoment = moment(selectedShift.start);
            setStartDate(startMoment.format('YYYY-MM-DD'));
            setStartTime(startMoment.format('HH:mm'));

            const endMoment = moment(selectedShift.end);
            setEndTime(endMoment.format('HH:mm'));

            setRecurs(selectedShift.recurs || false);
        }
    }, [selectedShift]);

    const handleUpdate = async () => {
        if (!selectedShift) return;

        // Combine date and time
        const newStartTime = moment(`${startDate}T${startTime}`);
        const newEndTime = moment(`${startDate}T${endTime}`);

        if (!newStartTime.isValid() || !newEndTime.isValid() || newEndTime.isSameOrBefore(newStartTime)) {
            toast({
                title: "Invalid shift times.",
                description: "End time must be after start time.",
                status: "error",
                duration: 5000,
                isClosable: true,
            });
            return;
        }

        setIsSaving(true);
        try {
            await onUpdateShift(selectedShift.id, {
                start: newStartTime.toDate(),
                end: newEndTime.toDate(),
                recurs,
                recurringDay: recurs ? newStartTime.day() : undefined,
            });

            toast({
                title: 'Shift Updated',
                description: `Successfully updated the shift for ${employee?.name}.`,
                status: 'success',
                duration: 3000,
                isClosable: true,
            });

            onClose();
        } catch (error) {
            logger.error("ShiftUpdateModal", "Update failed:", error);
            toast({
                title: 'Error Updating Shift',
                description: 'Failed to update shift.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setIsSaving(false);
        }
    };

    const handleDelete = async () => {
        if (!selectedShift) return;
        setIsSaving(true);
        try {
            const result = await onDeleteShift(selectedShift.id);
            if (result.success) {
                toast({
                    title: "Shift deleted.",
                    description: "Shift has been set as inactive.",
                    status: "success",
                    duration: 5000,
                    isClosable: true,
                });
                onClose();
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            logger.error("ShiftUpdateModal", "Delete failed:", error);
            toast({
                title: 'Error Deleting Shift',
                description: 'Failed to delete shift.',
                status: 'error',
                duration: 4000,
                isClosable: true,
            });
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} size="lg">
            <ModalOverlay />
            <ModalContent>
                <ModalHeader>Edit Shift for {employee?.name}</ModalHeader>
                <ModalCloseButton />
                <ModalBody>
                    <VStack spacing={4} align="stretch">
                        <FormControl>
                            <FormLabel>Shift Date</FormLabel>
                            <Input
                                type="date"
                                value={startDate}
                                onChange={(e) => setStartDate(e.target.value)}
                            />
                        </FormControl>

                        <HStack>
                            <FormControl>
                                <FormLabel>Start Time</FormLabel>
                                <Input
                                    type="time"
                                    value={startTime}
                                    onChange={(e) => setStartTime(e.target.value)}
                                />
                            </FormControl>
                            <FormControl>
                                <FormLabel>End Time</FormLabel>
                                <Input
                                    type="time"
                                    value={endTime}
                                    onChange={(e) => setEndTime(e.target.value)}
                                />
                            </FormControl>
                        </HStack>

                        <FormControl>
                            <Checkbox isChecked={recurs} onChange={(e) => setRecurs(e.target.checked)}>
                                Recur weekly
                            </Checkbox>
                        </FormControl>

                        {selectedShift && (
                            <Box mt={4} p={3} bg="gray.50" borderRadius="md">
                                <Text fontWeight="bold" mb={2}>Current Shift Details:</Text>
                                <Text fontSize="sm">
                                    {moment(selectedShift.start).format('MMM Do, YYYY')} - {moment(selectedShift.start).format('HH:mm')} to {moment(selectedShift.end).format('HH:mm')}
                                    {selectedShift.recurs && <Text as="span" ml={2} color="green.500">(Recurring)</Text>}
                                </Text>
                            </Box>
                        )}
                    </VStack>
                </ModalBody>
                <ModalFooter>
                    <Button variant="ghost" mr={3} onClick={onClose}>
                        Cancel
                    </Button>
                    <Button
                        colorScheme="red"
                        onClick={handleDelete}
                        isLoading={isSaving}
                        mr={3}
                    >
                        Delete Shift
                    </Button>
                    <Button
                        colorScheme="blue"
                        onClick={handleUpdate}
                        isLoading={isSaving}
                    >
                        Save Changes
                    </Button>
                </ModalFooter>
            </ModalContent>
        </Modal>
    );
};

export default ShiftUpdateModal;
--- src/app/pos/management/[entityName]/ShiftManagementComponents/ShiftModal.tsx ---
"use client";

import React, { useState } from 'react';
import {
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalFooter,
    ModalBody,
    ModalCloseButton,
    Button,
    FormControl,
    FormLabel,
    Input,
    Select,
    VStack,
    HStack,
    Text,
    useToast,
    Box,
    IconButton,
    Checkbox
} from '@chakra-ui/react';
import { DeleteIcon } from '@chakra-ui/icons';
import { Employee, Shift } from '../ShiftManagement';
import moment from 'moment';
import { logger } from "@/lib/logger";

interface ShiftModalProps {
    isOpen: boolean;
    onClose: () => void;
    employee: Employee | null;
    existingShifts: Shift[];
    onAddShift: (newShift: { employeeId: string; start: Date; end: Date; recurs: boolean }) => Promise<any>;
}

interface ShiftDay {
    date: Date;
    startTime: string;
    endTime: string;
    recurs: boolean;
}

const ShiftModal: React.FC<ShiftModalProps> = ({ isOpen, onClose, employee, existingShifts, onAddShift }) => {
    const [shiftDays, setShiftDays] = useState<ShiftDay[]>([]);
    const [selectedDate, setSelectedDate] = useState('');
    const [startTime, setStartTime] = useState('09:00');
    const [endTime, setEndTime] = useState('17:00');
    const [isSaving, setIsSaving] = useState(false);
    const [recurs, setRecurs] = useState(false);
    const toast = useToast();

    const getNextWeekDays = () => {
        const days = [];
        const today = moment().startOf('day');
        for (let i = 0; i < 7; i++) {
            const date = today.clone().add(i, 'days').toDate();
            days.push(date);
        }
        return days;
    };

    const getAvailableDays = () => {
        if (!employee) return [];

        const scheduledDates = existingShifts.map(shift =>
            moment(shift.start).format('YYYY-MM-DD')
        );

        return getNextWeekDays().filter(day =>
            !scheduledDates.includes(moment(day).format('YYYY-MM-DD'))
        );
    };

    const addShiftDay = () => {
        if (!selectedDate) {
            toast({
                title: 'Please select a date',
                status: 'warning',
                duration: 3000,
                isClosable: true,
            });
            return;
        }

        if (startTime >= endTime) {
            toast({
                title: 'End time must be after start time',
                status: 'error',
                duration: 3000,
                isClosable: true,
            });
            return;
        }

        const newShiftDay: ShiftDay = {
            date: new Date(selectedDate),
            startTime,
            endTime,
            recurs,
        };

        setShiftDays(prev => [...prev, newShiftDay]);
        setSelectedDate('');
        setStartTime('09:00');
        setEndTime('17:00');
        setRecurs(false);
    };

    const removeShiftDay = (index: number) => {
        setShiftDays(prev => prev.filter((_, i) => i !== index));
    };

    const saveAllShifts = async () => {
        if (!employee || shiftDays.length === 0) return;

        setIsSaving(true);
        try {
            // Corrected logic: Iterate and add each single shift record.
            const shiftPromises = shiftDays.map(async (shiftDay) => {
                const start = moment(shiftDay.date).set({
                    hour: parseInt(shiftDay.startTime.split(':')[0]),
                    minute: parseInt(shiftDay.startTime.split(':')[1])
                }).toDate();
                const end = moment(shiftDay.date).set({
                    hour: parseInt(shiftDay.endTime.split(':')[0]),
                    minute: parseInt(shiftDay.endTime.split(':')[1])
                }).toDate();

                // Call onAddShift once per record, with the recurs flag
                return onAddShift({
                    employeeId: employee.id,
                    start,
                    end,
                    recurs: shiftDay.recurs,
                });
            });

            await Promise.all(shiftPromises);

            setShiftDays([]);
            onClose();

            toast({
                title: 'Shifts Added',
                description: `Successfully added the selected shifts for ${employee.name}.`,
                status: 'success',
                duration: 3000,
                isClosable: true,
            });
        } catch (error) {
            logger.error("ShiftModal: Failed to add shifts:", error);
            toast({
                title: 'Error Adding Shifts',
                description: 'Failed to add one or more shifts.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setIsSaving(false);
        }
    };

    const availableDays = getAvailableDays();

    return (
        <Modal isOpen={isOpen} onClose={onClose} size="lg">
            <ModalOverlay />
            <ModalContent>
                <ModalHeader>Add Shifts for {employee?.name}</ModalHeader>
                <ModalCloseButton />
                <ModalBody>
                    <VStack spacing={4} align="stretch">
                        <FormControl>
                            <FormLabel>Available Days</FormLabel>
                            <Select
                                value={selectedDate}
                                onChange={(e) => setSelectedDate(e.target.value)}
                                placeholder="Select a day"
                            >
                                {availableDays.map(day => (
                                    <option key={day.toISOString()} value={day.toISOString()}>
                                        {day.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}
                                    </option>
                                ))}
                            </Select>
                        </FormControl>

                        <HStack>
                            <FormControl>
                                <FormLabel>Start Time</FormLabel>
                                <Input
                                    type="time"
                                    value={startTime}
                                    onChange={(e) => setStartTime(e.target.value)}
                                />
                            </FormControl>
                            <FormControl>
                                <FormLabel>End Time</FormLabel>
                                <Input
                                    type="time"
                                    value={endTime}
                                    onChange={(e) => setEndTime(e.target.value)}
                                />
                            </FormControl>
                        </HStack>

                        <FormControl>
                            <Checkbox isChecked={recurs} onChange={(e) => setRecurs(e.target.checked)}>
                                Recur weekly for 1 year
                            </Checkbox>
                        </FormControl>

                        <Button onClick={addShiftDay} colorScheme="blue">
                            Add This Shift
                        </Button>

                        {shiftDays.length > 0 && (
                            <Box mt={4}>
                                <Text fontWeight="bold" mb={2}>Shifts to Add:</Text>
                                <VStack spacing={2} align="stretch">
                                    {shiftDays.map((shiftDay, index) => (
                                        <HStack key={index} justify="space-between" p={2} bg="gray.50" borderRadius="md">
                                            <Text fontSize="sm">
                                                {shiftDay.date.toLocaleDateString()} - {shiftDay.startTime} to {shiftDay.endTime}
                                                {shiftDay.recurs && <Text as="span" ml={2} color="green.500">(Recurring)</Text>}
                                            </Text>
                                            <IconButton
                                                icon={<DeleteIcon />}
                                                aria-label={`Remove shift on ${shiftDay.date.toLocaleDateString()}`}
                                                size="sm"
                                                onClick={() => removeShiftDay(index)}
                                                variant="ghost"
                                            />
                                        </HStack>
                                    ))}
                                </VStack>
                            </Box>
                        )}
                    </VStack>
                </ModalBody>
                <ModalFooter>
                    <Button variant="ghost" mr={3} onClick={onClose}>
                        Cancel
                    </Button>
                    <Button
                        colorScheme="blue"
                        onClick={saveAllShifts}
                        isDisabled={shiftDays.length === 0 || isSaving}
                        isLoading={isSaving}
                    >
                        Save All Shifts ({shiftDays.length})
                    </Button>
                </ModalFooter>
            </ModalContent>
        </Modal>
    );
};

export default ShiftModal;
--- src/app/pos/management/[entityName]/ShiftManagementComponents/EmployeeList.tsx ---
// src/app/pos/management/[entityName]/ShiftManagementComponents/EmployeeList.tsx

"use client";

import React from 'react';
import { Box, Heading, VStack, Text, Badge } from '@chakra-ui/react';
import { Employee } from '../ShiftManagement';

interface EmployeeListProps {
    employees: Employee[];
    onEmployeeClick: (employee: Employee) => void;
}

const EmployeeListItem: React.FC<{ employee: Employee, onClick: (employee: Employee) => void }> = ({ employee, onClick }) => {
    return (
        <Box
            p={2}
            borderWidth="1px"
            borderRadius="lg"
            cursor="pointer"
            bg="white"
            mb={2}
            boxShadow="sm"
            _hover={{ bg: "gray.50" }}
            onClick={() => onClick(employee)}
        >
            <Text fontWeight="bold" fontSize="sm">{employee.name}</Text>
            <Badge
                colorScheme={
                    employee.role === 'Cashier' ? 'blue' :
                        employee.role === 'Waiter' ? 'green' :
                            employee.role === 'Kitchen Staff' ? 'red' : 'gray'
                }
                fontSize="xs"
            >
                {employee.role}
            </Badge>
        </Box>
    );
};

const EmployeeList: React.FC<EmployeeListProps> = ({ employees, onEmployeeClick }) => {
    // Add null/undefined check
    if (!employees || !Array.isArray(employees)) {
        return (
            <Box width="180px">
                <Heading size="sm" mb={3}>
                    Employees
                </Heading>
                <Text fontSize="sm">No employees available</Text>
            </Box>
        );
    }

    const groups = employees.reduce<Record<string, Employee[]>>((acc, e) => {
        const role = e.role || 'Other';
        if (!acc[role]) acc[role] = [];
        acc[role].push(e);
        return acc;
    }, {});

    return (
        <Box width="180px" minWidth="180px">
            <Heading size="sm" mb={3}>
                Employees
            </Heading>
            <VStack align="stretch" spacing={3}>
                {Object.keys(groups).map((role) => (
                    <Box key={role}>
                        <Text fontWeight="bold" fontSize="sm" mb={1}>{role}</Text>
                        <Box>
                            {groups[role].map((emp) => (
                                <EmployeeListItem
                                    key={emp.id}
                                    employee={emp}
                                    onClick={onEmployeeClick}
                                />
                            ))}
                        </Box>
                    </Box>
                ))}
            </VStack>
        </Box>
    );
};

export default EmployeeList;